<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mrli&#39;s Blog</title>
  
  <subtitle>别装作很努力，结局不会陪你演戏。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nymrli.top/"/>
  <updated>2022-04-02T15:56:34.396Z</updated>
  <id>https://nymrli.top/</id>
  
  <author>
    <name>Mrli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>开源项目代码阅读记录</title>
    <link href="https://nymrli.top/2022/03/29/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <id>https://nymrli.top/2022/03/29/开源项目代码阅读记录/</id>
    <published>2022-03-29T09:54:46.000Z</published>
    <updated>2022-04-02T15:56:34.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="taobao_seckill"><a class="markdownIt-Anchor" href="#taobao_seckill"></a> <strong><a href="https://github.com/jerry3747/taobao_seckill" target="_blank" rel="noopener"> taobao_seckill</a></strong></h2><blockquote><p>淘宝秒杀物品：分为selenium版和request网络请求版，微小的区别在于，api先请求的是购物车的物品信息，selenium则是勾选选择框。</p><p>流程大致都相同：①keep_wait等待临近抢购时间-----&gt;②将需要的信息缓存住，不再刷新（比如要抢购的物品信息、cookies…）-----&gt;③进行结算(/点击按钮)-----&gt;④提交订单(/点击按钮)-----&gt;⑤支付订单(/点击按钮)；</p></blockquote><ul><li><p><a href="https://www.cnblogs.com/amiza/p/10175543.html" target="_blank" rel="noopener">使用browsercookie来管理浏览器cookies</a>——从浏览器提取保存的cookies的工具。它是一个很有用的爬虫工具，通过加载你浏览器的cookies到一个cookiejar对象里面，让你轻松下载需要登录的网页内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cj = browsercookie.chrome()<span class="comment"># browsercookie.load() 在不知道或者不关心浏览器时使用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(url, cookies=cj)</span><br></pre></td></tr></table></figure><p>一般情况下，作为开发者的我们都是将cookies手动写入或者是传入程序的，而browsercookie用途，我想可以是将需要传入cookies的程序打包给不会提取Cookies的用户使用。（类似通过selenium登陆后，拿取cookies再发送网络请求，这边是让/借助用户自己的浏览器来拿取cookies）</p></li><li><p>使用tkinter搭建简单的GUI：点击“开始”的按钮后会将密码框和抢购设置时间框的内容传入，作为实例化ChromeDriverSpider的参数，并运行实例的sec_kill方法开始执行抢购</p></li><li><p>配置chromeDriver启动配置项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_chrome_options</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""配置启动项"""</span></span><br><span class="line">    chrome_options = webdriver.ChromeOptions()</span><br><span class="line">    chrome_options.accept_untrusted_certs = <span class="keyword">True</span></span><br><span class="line">    chrome_options.assume_untrusted_cert_issuer = <span class="keyword">True</span></span><br><span class="line">    arguments = [<span class="string">'--no-sandbox'</span>, <span class="string">'--disable-impl-side-painting'</span>, <span class="string">'--disable-setuid-sandbox'</span>, <span class="string">'--disable-seccomp-filter-sandbox'</span>,</span><br><span class="line">    <span class="string">'--disable-breakpad'</span>, <span class="string">'--disable-client-side-phishing-detection'</span>, <span class="string">'--disable-cast'</span>,</span><br><span class="line">    <span class="string">'--disable-cast-streaming-hw-encoding'</span>, <span class="string">'--disable-cloud-import'</span>, <span class="string">'--disable-popup-blocking'</span>,</span><br><span class="line">    <span class="string">'--ignore-certificate-errors'</span>, <span class="string">'--disable-session-crashed-bubble'</span>, <span class="string">'--disable-ipv6'</span>,</span><br><span class="line">    <span class="string">'--allow-http-screen-capture'</span>, <span class="string">'--start-maximized'</span>]</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> arguments:</span><br><span class="line">    chrome_options.add_argument(arg)</span><br><span class="line">    chrome_options.add_argument(<span class="string">f'--user-agent=<span class="subst">&#123;choice(get_useragent_data())&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> chrome_options</span><br></pre></td></tr></table></figure></li></ul><h2 id="taobao_api"><a class="markdownIt-Anchor" href="#taobao_api"></a> <strong><a href="https://github.com/gaoxt/taobao_api" target="_blank" rel="noopener">taobao_api</a></strong></h2><blockquote><p>selenium和api结合：登陆逻辑使用了selenium，刷新购物车和下单调用了手机淘宝taobao_api，自动付款也使用了selenium，能自动模拟触摸输入密码付款，接口签名sign生成方法参考get_sign_val。</p></blockquote><ul><li><p>同步阿里云时间服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一次性设置</span></span><br><span class="line">sudo sntp -sS ntp.aliyun.com</span><br><span class="line"><span class="comment">#永久设置</span></span><br><span class="line">sudo systemsetup -setnetworktimeserver ntp.aliyun.com</span><br><span class="line">sudo systemsetup -setusingnetworktime on</span><br></pre></td></tr></table></figure></li><li><p>展示QRCode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment"># 找到二维码图片的链接</span></span><br><span class="line">   img = WebDriverWait(browser, <span class="number">2</span>, <span class="number">0.1</span>).until(</span><br><span class="line">       EC.presence_of_element_located((By.XPATH, <span class="string">"//div[@id='J_QRCodeImg']/img"</span>))).get_attribute(<span class="string">'src'</span>)</span><br><span class="line">   <span class="comment"># 获得图片字节流内容</span></span><br><span class="line">   img_content = requests.get(img, timeout=<span class="number">5</span>).content</span><br><span class="line">   <span class="comment"># 保存到本地图片中</span></span><br><span class="line">   file_name = <span class="string">'taobao_qrcode.png'</span></span><br><span class="line">   fp = open(file_name, <span class="string">'wb'</span>)</span><br><span class="line">   fp.write(img_content)</span><br><span class="line">   fp.close()</span><br><span class="line"><span class="comment"># 将其解码成链接， pyzbar为二维码和条形码库 ==&gt; 个人觉得保存后可以直接转成PIL的Image然后img.show()</span></span><br><span class="line">   <span class="keyword">from</span> pyzbar.pyzbar <span class="keyword">import</span> decode</span><br><span class="line">   barcode_url = <span class="string">''</span></span><br><span class="line">   barcodes = decode(Image.open(file_name))</span><br><span class="line">   <span class="keyword">for</span> barcode <span class="keyword">in</span> barcodes:</span><br><span class="line">       <span class="comment"># 解析获得二维码后的内容；如果是条形码，则返回条形码数</span></span><br><span class="line">       barcode_url = barcode.data.decode(<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="comment"># 生成二维码并通过控制台打印</span></span><br><span class="line">   qr = qrcode.QRCode()</span><br><span class="line">   qr.add_data(barcode_url)</span><br><span class="line">   qr.print_ascii(invert=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>注：<a href="http://zbar.sourceforge.net/" target="_blank" rel="noopener">ZBar</a>是一个开源软件套件，用于从各种来源（如视频流、图像文件和原始强度传感器）读取条形码；<code>pyzbar</code> 是通过 <code>Python2</code>和<code>3</code>接口，使用 <code>ZBar</code> 库读取一维条形码和QR码 。=&gt;<a href="https://blog.csdn.net/qq_37924224/article/details/109582507" target="_blank" rel="noopener">读取条形码</a>、<a href="https://blog.csdn.net/hxj0323/article/details/112969622" target="_blank" rel="noopener">读取二维码</a></p></li></ul><h2 id="jd_seckill"><a class="markdownIt-Anchor" href="#jd_seckill"></a> <strong><a href="https://github.com/andyzys/jd_seckill" target="_blank" rel="noopener">jd_seckill</a></strong></h2><blockquote><ol><li>预约商品</li><li>秒杀抢购商品: ①<strong>访问</strong>商品的抢购<strong>链接</strong>（用于设置cookie等—&gt;②访问抢购订单<strong>结算页面</strong>----&gt;③<strong>提交抢</strong>购（秒杀）<strong>订单</strong> [_get_seckill_order_data生成提交抢购订单所需的请求体参数、获取秒杀初始化信息（包括：地址，发票，token）]</li></ol></blockquote><ul><li><p>从UAList中通过<code>random.choice(USER_AGENTS)</code>随机UA</p></li><li><p>使用内置configparser模块解析config.ini</p><ul><li>RawConfigParser是最基础的INI文件读取类；ConfigParser、SafeConfigParser<a href="https://blog.csdn.net/miner_k/article/details/77857292" target="_blank" rel="noopener">支持对%(value)s变量的解析</a>，SafeConfigParser类实现了ConfigParser相同的接口，新增如下方法：set存在保存的方法</li><li>section下的option(key)可以不填value值，即为空。</li><li>from: <a href="https://blog.csdn.net/tianzhu123/article/details/6893755" target="_blank" rel="noopener">python中RawConfigParser类、ConfigParser类、SafeConfigParser类中函数介绍</a>、</li></ul></li><li><p>多进程池：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ProcessPoolExecutor(work_count) <span class="keyword">as</span> pool:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(work_count):</span><br><span class="line">        pool.submit(self.seckill)</span><br></pre></td></tr></table></figure></li><li><p>秒杀时间比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buy_time = datetime.strptime(global_config.getRaw(<span class="string">'config'</span>,<span class="string">'buy_time'</span>), <span class="string">"%Y-%m-%d %H:%M:%S.%f"</span></span><br><span class="line">now_time = datetime.now</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">if</span> now_time() &gt;= buy_time:</span><br><span class="line">        logger.info(<span class="string">'时间到达，开始执行……'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">time.sleep(self.sleep_interval)</span><br></pre></td></tr></table></figure></li><li><p><a href="https://github.com/woxiqingxian/jd_seckill/pull/2/commits/63a41a0609912d5643bc11f3419fe7dd8e84a00a" target="_blank" rel="noopener">获取京东服务器时间</a>：<code>https://api.m.jd.com/client.action?functionId=queryMaterialProducts&amp;client=wh5</code></p></li></ul><h2 id="jd-assistant"><a class="markdownIt-Anchor" href="#jd-assistant"></a> <strong><a href="https://github.com/tychxn/jd-assistant" target="_blank" rel="noopener">jd-assistant★</a></strong></h2><blockquote><p>是<a href="#jd_seckill">jd_seckill</a>的优化进阶版本</p><ul><li><p>普通商品购买主要流程：<code>(1)清空购物车</code> --&gt; <code>(2)添加商品到购物车</code> --&gt; <code>(3)提交订单</code></p></li><li><p>预约抢购商品特点：</p><ol><li>需要提前点击预约</li><li>大部分此类商品在预约后自动加入购物车，但是无法勾选✓，也无法️进入到结算页面</li><li>到了抢购的时间点后将商品加入购物车，此时才能勾选并下单</li></ol></li><li><p>普通商品：能加入购物车🛒，然后进入购物车结算下单.</p></li><li><p>抢购商品：需提提前预约，开始抢购时有“立即抢购”按钮🔘，点击按钮后商品加入购物车，然后结算下单.</p></li></ul><p>⭐️抢购受多种因素影响：<strong>网速、账号质量、运气</strong>等等，仅供娱乐，认真就输了.</p></blockquote><ul><li><p>deprecated、check_login装饰器：传入了self参数，并通过self实例调用了类的其他成员方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_login</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""用户登陆态校验装饰器。若用户未登陆，则调用扫码登陆"""</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_func</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_login:</span><br><span class="line">            logger.info(<span class="string">"&#123;0&#125; 需登陆后调用，开始扫码登陆"</span>.format(func.__name__))</span><br><span class="line">            self.login_by_QRcode()</span><br><span class="line">        <span class="keyword">return</span> func(self, *args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> new_func</span><br></pre></td></tr></table></figure></li><li><p>密码加密——<strong><a href="https://github.com/Legrandin/pycryptodome" target="_blank" rel="noopener">pycryptodome</a></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_v1_5 <span class="keyword">as</span> Cipher_pkcs1_v1_5</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt_pwd</span><span class="params">(password, public_key=RSA_PUBLIC_KEY)</span>:</span></span><br><span class="line">    rsa_key = RSA.importKey(public_key)</span><br><span class="line">    encryptor = Cipher_pkcs1_v1_5.new(rsa_key)</span><br><span class="line">    cipher = b64encode(encryptor.encrypt(password.encode(<span class="string">'utf-8'</span>)))</span><br><span class="line">    <span class="keyword">return</span> cipher.decode(<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure></li><li><p>提供JS脚本文件来获取商品的信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码在订单结算页面的开发者工具Console中执行，用于获取必要的参数</span></span><br><span class="line"><span class="keyword">var</span> eid = $(<span class="string">'#eid'</span>).val();</span><br><span class="line"><span class="keyword">var</span> fp = $(<span class="string">'#fp'</span>).val();</span><br><span class="line"><span class="keyword">var</span> trackId = getTakId();</span><br><span class="line"><span class="keyword">var</span> riskControl = $(<span class="string">'#riskControl'</span>).val();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`eid = <span class="subst">$&#123;eid&#125;</span>\nfp = <span class="subst">$&#123;fp&#125;</span>\ntrack_id = <span class="subst">$&#123;trackId&#125;</span>\nrisk_control = <span class="subst">$&#123;riskControl&#125;</span>`</span>);</span><br></pre></td></tr></table></figure></li><li><p>cookies验证-通过读取本地保存的cookies时要先验证下cookies是否有效：requests库的使用方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_validate_cookies</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""验证cookies是否有效（是否登陆）</span></span><br><span class="line"><span class="string">    通过访问用户订单列表页进行判断：若未登录，将会重定向到登陆页面。</span></span><br><span class="line"><span class="string">    :return: cookies是否有效 True/False</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    url = <span class="string">'https://order.jd.com/center/list.action'</span></span><br><span class="line">    payload = &#123;</span><br><span class="line">        <span class="string">'rid'</span>: str(int(time.time() * <span class="number">1000</span>)),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        resp = self.sess.get(url=url, params=payload, allow_redirects=<span class="keyword">False</span>)</span><br><span class="line">        <span class="keyword">if</span> resp.status_code == requests.codes.OK:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(e)</span><br><span class="line">    <span class="comment"># 创建新的session</span></span><br><span class="line">    self.sess = requests.session()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></li><li><p>二维码登录：下载二维码<code>_get_QRcode</code>–&gt;询问获取二维码扫描状态<code>_get_QRcode_ticket</code>—&gt;验证二维码信息(<code>_validate_QRcode_ticket</code>)–&gt;设置<code>is_login=True和save_cookies</code>（二维码有效期约120s，浏览器大约2s发送一个请求询问扫描状态）——看代码是assistant参考了2018年的**<a href="https://github.com/adyzng/jd-autobuy" target="_blank" rel="noopener">jd-autobuy</a>**</p></li><li><p>扫描二维码：写入图片和打开图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_image</span><span class="params">(resp, image_file)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(image_file, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 从网络请求中下载内容</span></span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> resp.iter_content(chunk_size=<span class="number">1024</span>):</span><br><span class="line">            f.write(chunk)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_image</span><span class="params">(image_file)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> os.name == <span class="string">"nt"</span>:</span><br><span class="line">        os.system(<span class="string">'start '</span> + image_file)  <span class="comment"># for Windows</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> os.uname()[<span class="number">0</span>] == <span class="string">"Linux"</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"deepin"</span> <span class="keyword">in</span> os.uname()[<span class="number">2</span>]:</span><br><span class="line">                os.system(<span class="string">"deepin-image-viewer "</span> + image_file)  <span class="comment"># for deepin</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                os.system(<span class="string">"eog "</span> + image_file)  <span class="comment"># for Linux</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            os.system(<span class="string">"open "</span> + image_file)  <span class="comment"># for Mac</span></span><br></pre></td></tr></table></figure><p>注：判断操作系统还可以借助内置的platform库<code>platform.system().lower()</code>得到[linux、windows、mac]</p></li></ul><p>▲cookies和二维码结合使用：</p><ol><li>如果登陆成功则吧cookies持久化</li><li>使用二维码登陆前，先加载验证之前持久化的cookies是否有效，如果有效则无需再次扫码登陆(在QRCode_login的起始位置判断validation中修改的is_login是否为True)</li></ol><h2 id="jd-seckill-maotai"><a class="markdownIt-Anchor" href="#jd-seckill-maotai"></a> <strong><a href="https://github.com/hello8817/jd-seckill-maotai" target="_blank" rel="noopener"> jd-seckill-maotai</a></strong></h2><blockquote><ul><li><h2 id="主要功能"><a class="markdownIt-Anchor" href="#主要功能"></a> 主要功能</h2><ul><li>登陆京东商城（<a href="http://www.jd.com" target="_blank" rel="noopener">www.jd.com</a>）<ul><li>用京东APP扫码给出的二维码</li></ul></li><li>预约茅台<ul><li>定时自动预约</li></ul></li><li>秒杀预约后等待抢购<ul><li>定时开始自动抢购</li></ul></li></ul></li></ul><p><strong>特别声明：</strong></p><ul><li>本仓库发布的<code>jd_seckill_maotai</code>项目中涉及的任何脚本，仅用于测试和学习研究，禁止用于商业用途，不能保证其合法性，准确性，完整性和有效性，请根据情况自行判断。</li><li>本项目内所有资源文件，禁止任何公众号、自媒体进行任何形式的转载、发布。</li><li><code>ChinaVolvocars</code> 对任何脚本问题概不负责，包括但不限于由任何脚本错误导致的任何损失或损害.</li><li>请勿将<code>jd_seckill_maotai</code>项目的任何内容用于商业或非法目的，否则后果自负。</li><li>如果任何单位或个人认为该项目的脚本可能涉嫌侵犯其权利，则应及时通知并提供身份证明，所有权证明，我们将在收到认证文件后删除相关脚本。</li><li>您必须在下载后的24小时内从计算机或手机中完全删除以上内容。</li><li>本项目遵循<code>GPL-3.0 License</code>协议，如果本特别声明与<code>GPL-3.0 License</code>协议有冲突之处，以本特别声明为准。</li><li><em><strong>您使用或者复制了本仓库且本人制作的任何代码或项目，则视为<code>已接受</code>此声明，请仔细阅读</strong></em><br><em><strong>您在本声明未发出之时点使用或者复制了本仓库且本人制作的任何代码或项目且此时还在使用，则视为<code>已接受</code>此声明，请仔细阅读</strong></em></li></ul></blockquote><blockquote><p>根据12月14日以来抢茅台的日志分析，大胆推断再接再厉返回Json消息中<code>resultCode</code>与<strong>小白信用</strong>的关系。<br>这里主要分析出现频率最高的<code>90016</code>和<code>90008</code>。</p><table><thead><tr><th>案例</th><th>小白信用</th><th>90016</th><th>90008</th><th>抢到耗时</th></tr></thead><tbody><tr><td>张三</td><td>63.8</td><td>59.63%</td><td>40.37%</td><td>暂未抢到</td></tr><tr><td>李四</td><td>92.9</td><td>72.05%</td><td>27.94%</td><td>4天</td></tr><tr><td>王五</td><td>99.6</td><td>75.70%</td><td>24.29%</td><td>暂未抢到</td></tr><tr><td>赵六</td><td>103.4</td><td>91.02%</td><td>8.9%</td><td>2天</td></tr></tbody></table><p>风控放行后才会进行抢购，这时候用的应该是水库计数模型，假设无法一次性拿到所有数据的情况下来尽量的做到抢购成功用户的均匀分布，这样就和概率相关了。</p><p><strong>抢购结果确认</strong></p><p>抢购是否成功通常在程序开始的一分钟内可见分晓！<br>搜索日志，出现“抢购成功，订单号xxxxx&quot;，代表成功抢到了，务必半小时内支付订单！程序暂时不支持自动停止，需要手动STOP！<br>若两分钟还未抢购成功，基本上就是没抢到！程序暂时不支持自动停止，需要手动STOP！</p></blockquote><ul><li><p>在程序开始运行后，会检测本地时间与京东服务器时间，输出的差值为【本地时间-京东服务器时间】，即-50为本地时间比京东服务器时间慢50ms。 本代码的执行的抢购时间以本地电脑/服务器时间为准</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ...)</span>:</span></span><br><span class="line">    <span class="comment"># 初始化误差</span></span><br><span class="line">self.diff_time = self.local_time() - self.jd_time()</span><br><span class="line"><span class="comment"># ....</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 本地时间减去与京东的时间差(ms)，能够将时间误差提升到0.1秒附近, 具体精度依赖获取京东服务器时间的网络时间损耗</span></span><br><span class="line">    <span class="keyword">if</span> self.local_time() - self.diff_time &gt;= self.buy_time_ms:</span><br><span class="line">        logger.info(<span class="string">'时间到达，开始执行……'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            time.sleep(self.sleep_interval)</span><br></pre></td></tr></table></figure><p>补充：Python的时间戳默认都是秒级别的，如果要ms级别的，则要乘以1000</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">通过time，以元组（struct_time）为核心实现时间戳和格式化时间字符串的相互转换。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 获得10位秒级时间戳</span></span><br><span class="line">seconds = time.time()</span><br><span class="line"><span class="comment"># 获得13位毫秒级时间戳==&gt;java默认13位</span></span><br><span class="line">millis = int(round(time.time() * <span class="number">1000</span>))</span><br><span class="line"><span class="comment"># 同样，time下的mktime也需要*1000</span></span><br><span class="line">time.mktime(self.buy_time.timetuple()) * <span class="number">1000.0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">通过datetime，以datetime类实例对象为核心实现时间戳和格式化时间字符串的相互转换。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment"># 获得当前时间</span></span><br><span class="line">now = datetime.now()</span><br><span class="line">timestamp = datetime.timestamp(now)</span><br><span class="line">print(<span class="string">"时间戳 ="</span>, timestamp)</span><br><span class="line"><span class="comment"># 也是10位s级</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1648622589.624272</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="jd_mask"><a class="markdownIt-Anchor" href="#jd_mask"></a> <strong><a href="https://github.com/Lasx/jd_mask" target="_blank" rel="noopener">jd_mask</a></strong></h2><blockquote><p>此tool只单独支持<strong>预约-抢购-成功后直接提交订单</strong>的商品，如[口罩]，只提供学习参考用途.</p></blockquote><p>Ⓜ️阅读了多份京东抢购的代码后，发现基本都是从一个模板里不断优化发展出来的，反应了开源的意义，也反应了京东部分细节的修改，同时也能得到一个告示：在实现相同功能前，不妨多看看、借鉴下以往可行的代码。</p><h2 id="automatic_ticket_purchase"><a class="markdownIt-Anchor" href="#automatic_ticket_purchase"></a> <strong><a href="https://github.com/MakiNaruto/Automatic_ticket_purchase" target="_blank" rel="noopener">Automatic_ticket_purchase</a></strong></h2><p>大麦网抢购流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[开始] --&gt; B(登陆)</span><br><span class="line">    B --&gt; C&#123;是否利用cookies登陆&#125;</span><br><span class="line">    C --&gt; |否| D[页面登陆]</span><br><span class="line">    C --&gt; |是| E[登陆验证]</span><br><span class="line">    D --&gt; E</span><br><span class="line">    E --&gt; G&#123;是否登陆成功&#125;</span><br><span class="line">    G --&gt; |是| F[获取购票必要信息]</span><br><span class="line">    G --&gt; |否|ED</span><br><span class="line">    F --&gt; L[检测抢票现在购票状态]</span><br><span class="line">    L --&gt; M&#123;目标票可进行抢购&#125;</span><br><span class="line">    M --&gt; |即将开抢|L</span><br><span class="line">    M --&gt; |缺货登记|ED((结束))</span><br><span class="line">M --&gt; |立刻购买|N&#123;抢购&#125;</span><br></pre></td></tr></table></figure><blockquote><p>跟限时、定时秒杀不同的是，大麦网的抢购信息是靠不断刷新的，需要通过不断检测页面内容，判断目前票的可否购买情况。如果刷新为可购买则进行抢购购买。</p></blockquote><ul><li><p>点击购买是对指定接口发送请求，并更新cookies(cookies嫌少不嫌多)：step2_click_buy_now</p></li><li><p>提交订单：step3_submit_order</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">response = self.session.post(<span class="string">'https://buy.damai.cn/multi/trans/createOrder'</span>,</span><br><span class="line">                             headers=headers,</span><br><span class="line">                             params=params,</span><br><span class="line">                             data=submit_order_info,</span><br><span class="line">                             cookies=self.login_cookies)</span><br><span class="line">buy_status = json.loads(response.text)</span><br><span class="line"><span class="keyword">if</span> buy_status.get(<span class="string">'success'</span>) <span class="keyword">is</span> <span class="keyword">True</span> <span class="keyword">and</span> buy_status.get(<span class="string">'module'</span>).get(<span class="string">'alipayOrderId'</span>):</span><br><span class="line">    print(<span class="string">'-'</span> * <span class="number">10</span>, <span class="string">'抢票成功, 请前往 大麦网-&gt;我的大麦-&gt;交易中心-&gt;订单管理 确认订单'</span>, <span class="string">'-'</span> * <span class="number">10</span>)</span><br><span class="line">    print(<span class="string">'alipayOrderId: '</span>, buy_status.get(<span class="string">'module'</span>).get(<span class="string">'alipayOrderId'</span>))</span><br><span class="line">    print(<span class="string">'支付宝支付链接: '</span>, buy_status.get(<span class="string">'module'</span>).get(<span class="string">'alipayWapCashierUrl'</span>))</span><br></pre></td></tr></table></figure></li></ul><h2 id="nikerobot"><a class="markdownIt-Anchor" href="#nikerobot"></a> <strong><a href="https://github.com/cxiaoer/NikeRobot" target="_blank" rel="noopener"> NikeRobot</a></strong></h2><ul><li><p>pdb调试断点：==&gt;实际上Pycharm的调试更加好用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">pdb.set_trace()</span><br></pre></td></tr></table></figure></li><li><p>将类成员属性转成字典形式: <code>NikeLoginParam().__dict__</code></p></li><li><p>自己管理线程：创建继承Thread的执行类，重写run方法，在main中进行创建多个实例MyThread().start()，并join住。</p></li></ul><h2 id="hpv4g"><a class="markdownIt-Anchor" href="#hpv4g"></a> <strong><a href="https://github.com/xiangmingzhe0928/hpv4g" target="_blank" rel="noopener">hpv4g</a></strong></h2><ul><li><p>是否使用代理：<code>init_ip_proxy_pool</code></p></li><li><p>多线程参数设置: python3.8中ThreadPoolExecutor的默认worker：<code>max_workers = min(32, os.cpu_count() + 4)</code></p></li><li><p>线程池：ThreadPoolExecutor</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, wait, FIRST_COMPLETED</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=max_workers) <span class="keyword">as</span> t:</span><br><span class="line">    fs = [t.submit(sec_kill_task, miao_miao, params[i % _params_len],</span><br><span class="line">                   <span class="keyword">None</span> <span class="keyword">if</span> <span class="keyword">not</span> _ip_proxys_len <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="string">'http'</span>: <span class="keyword">None</span> <span class="keyword">if</span> (index := i % _ip_proxys_len) == <span class="number">0</span> <span class="keyword">else</span> ip_proxys[index]&#125;) <span class="keyword">for</span> i <span class="keyword">in</span></span><br><span class="line">          range(max_workers + <span class="number">5</span>)]</span><br><span class="line">    <span class="comment"># 120S后结束任务, 有一个完成则完成</span></span><br><span class="line">    wait(fs, <span class="number">120</span>, return_when=FIRST_COMPLETED)</span><br><span class="line">    <span class="keyword">global</span> KILL_FLAG</span><br><span class="line">    KILL_FLAG = <span class="keyword">True</span></span><br><span class="line">    print(<span class="string">'&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;本轮未成功秒杀到疫苗&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;'</span>)</span><br></pre></td></tr></table></figure></li><li><p>缓存配置——非默认参数的装饰器：考虑提前缓存疫苗列表 秒杀开始后跳过查询列表等操作 直接调用秒杀接口</p></li><li><p>获取服务器当前时间戳</p></li><li><p>设置log</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="comment"># 设置配置</span></span><br><span class="line">logging.basicConfig(handlers=[logging.FileHandler(filename=LOG_NAME,</span><br><span class="line">                                                  encoding=<span class="string">'utf-8'</span>, mode=<span class="string">'a+'</span>)],</span><br><span class="line">                    format=<span class="string">'%(asctime)s %(message)s'</span>,</span><br><span class="line">                    level=getattr(logging, args.log))</span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">logging.info(<span class="string">"xxx"</span>)</span><br><span class="line">logging.debug(<span class="string">"yyy"</span>)</span><br></pre></td></tr></table></figure></li><li><p>argueparser使用：</p><ul><li>action参数: <code>parser.add_argument('-reload_cache', action='store_true', help='刷新--region_code疫苗列表本地缓存')</code>，出现reload_cache参数则为true，所以默认为false</li><li><code>parser.add_argument('--log', default='WARNING', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR'],help='日志级别 默认WARNING')</code></li></ul></li><li><p>requests使用：</p><ul><li><p><code>raise_for_status</code>状态码非成功时抛出异常</p></li><li><p>自定义<code>_get(url, params=None, error_exit=True, **kwargs)</code>方法，添加参数：error_exit:返回4XX 5XX错误时 是否退出</p></li><li><p>cookies除了放在requests.get(cookies=xxxCookieDict)，还可以作为字符串设置在header[“<strong>cookie</strong>”]中（无s），如<code>self._headers[&quot;cookie&quot;]=&quot;k1=v1;_xxhm_=%7B%2x%7D;k3=wxapptoken:v3&quot;</code>，通过<code>;</code>来分割</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># disable ssl warnings</span></span><br><span class="line">requests.packages.urllib3.disable_warnings()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="抢购型代码总结"><a class="markdownIt-Anchor" href="#抢购型代码总结"></a> 抢购型代码总结：</h2><ul><li><p>实现主要分为selenium(自动测试工具)模拟点击；api模拟网络请求</p></li><li><p>登陆之后会对cookies进行持久化，使用pickle的好处是无法明文看懂、复制</p></li><li><p>可以通过持久化的cookies来登陆，但会检测cookies是否仍然有效</p></li><li><p>定时抢购会等待sleep到临近时间(while True+sleep(time)的方式 or sleepUntil+while try)，然后再进行多次抢购请求（如果抢购的2分钟内没抢到，大多没希望了，只好等待下次）；如果是<a href="#Automatic_ticket_purchase">等待页面刷新的</a>，则不断请求页面，等到结果改变。</p><ul><li>注意：等待间隔不要超过时间阈值，如180s前检查，如果不符合不能让其等待190s</li></ul></li><li><p>推送工具：提供一个自己写的</p><p>config.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[pusher]</span></span><br><span class="line"><span class="attr">pusher_type</span> = pushplus</span><br><span class="line"></span><br><span class="line"><span class="section">[serverchan]</span></span><br><span class="line"><span class="comment"># https://sct.ftqq.com/</span></span><br><span class="line"><span class="attr">sec_key</span> =</span><br><span class="line"></span><br><span class="line"><span class="section">[dingding]</span></span><br><span class="line"><span class="attr">access_token</span> =</span><br><span class="line"><span class="attr">secret</span> =</span><br><span class="line"></span><br><span class="line"><span class="section">[pushplus]</span></span><br><span class="line"><span class="comment"># http://www.pushplus.plus/</span></span><br><span class="line"><span class="attr">pushplus_token</span> = fedcf6b08f6f4aaeb2948b7d7010eb93</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">pusher.py</span><br><span class="line">  </span><br><span class="line">  ```python</span><br><span class="line">  import base64</span><br><span class="line">  import hashlib</span><br><span class="line">  import hmac</span><br><span class="line">  import os.path</span><br><span class="line">  import time</span><br><span class="line">  import urllib.parse</span><br><span class="line">  from datetime import date</span><br><span class="line">  from functools import reduce</span><br><span class="line">  </span><br><span class="line">  import requests</span><br><span class="line">  </span><br><span class="line">  CONFIG_INI_FILENAME = &quot;config.ini&quot;</span><br><span class="line">  REMIND_MSG = &quot;&quot;&quot;</span><br><span class="line">  [pusher]</span><br><span class="line">  pusher_type = pushplus</span><br><span class="line">  </span><br><span class="line">  [serverchan]</span><br><span class="line">  sec_key =</span><br><span class="line">  </span><br><span class="line">  [dingding]</span><br><span class="line">  access_token =</span><br><span class="line">  secret =</span><br><span class="line">  </span><br><span class="line">  [pushplus]</span><br><span class="line">  pushplus_token = </span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  class PusherException(Exception):</span><br><span class="line">      def __init__(self, message) -&gt; None:</span><br><span class="line">          super().__init__(message)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  class IPushUtil:</span><br><span class="line">      def push(self, title: str = &quot;&quot;, content: str = &quot;&quot;) -&gt; bool:</span><br><span class="line">          pass</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  class PushplusPush(IPushUtil):</span><br><span class="line">      def __init__(self, options: dict):</span><br><span class="line">          self.pushplus_token = options.get(&quot;pushplus_token&quot;)</span><br><span class="line">  </span><br><span class="line">      def push(self, title: str = &quot;&quot;, content: str = &quot;&quot;) -&gt; bool:</span><br><span class="line">          d = &#123;</span><br><span class="line">              &quot;token&quot;: self.pushplus_token,</span><br><span class="line">              &quot;template&quot;: &quot;markdown&quot;,</span><br><span class="line">              &quot;title&quot;: &quot;&#123;date&#125;.&#123;title&#125;&quot;.format(date=date.today(), title=title),</span><br><span class="line">              &quot;content&quot;: content</span><br><span class="line">          &#125;</span><br><span class="line">          res = requests.post(&quot;http://www.pushplus.plus/send&quot;, data=d)</span><br><span class="line">          if not (200 &lt;= res.json().get(&quot;code&quot;) &lt; 300):</span><br><span class="line">              print(res.json())</span><br><span class="line">          return 200 &lt;= res.json().get(&quot;code&quot;) &lt; 300</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  class ServerChanPush(IPushUtil):</span><br><span class="line">      def __init__(self, options: dict):</span><br><span class="line">          self.sec_key = options.get(&quot;sec_key&quot;)</span><br><span class="line">  </span><br><span class="line">      def push(self, title: str = &quot;&quot;, content: str = &quot;&quot;) -&gt; bool:</span><br><span class="line">          data = &#123;</span><br><span class="line">              &apos;text&apos;: &quot;&#123;date&#125;.&#123;title&#125;&quot;.format(date=date.today(), title=title),</span><br><span class="line">              &apos;desp&apos;: content</span><br><span class="line">          &#125;</span><br><span class="line">          res = requests.post(url=&apos;https://sc.ftqq.com/&#123;&#125;.send&apos;.format(self.sec_key), data=data)</span><br><span class="line">          if not (res.json().get(&quot;errmsg&quot;) == &quot;success&quot;):</span><br><span class="line">              print(res.json())</span><br><span class="line">          return res.json().get(&quot;errmsg&quot;) == &quot;success&quot;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  class DingDingPush(IPushUtil):</span><br><span class="line">      URL = &quot;https://oapi.dingtalk.com/robot/send&quot;</span><br><span class="line">  </span><br><span class="line">      def __init__(self, options: dict):</span><br><span class="line">          self.access_token = options.get(&quot;access_token&quot;)</span><br><span class="line">          self.secret = options.get(&quot;secret&quot;)</span><br><span class="line">          self.target_url = self.get_url()</span><br><span class="line">  </span><br><span class="line">      def get_url(self):</span><br><span class="line">          timestamp = round(time.time() * 1000)</span><br><span class="line">          secret_enc = bytes(self.secret, encoding=&quot;utf-8&quot;)</span><br><span class="line">          string_to_sign = &quot;&#123;&#125;\n&#123;&#125;&quot;.format(timestamp, self.secret)</span><br><span class="line">          string_to_sign_enc = bytes(string_to_sign, encoding=&quot;utf-8&quot;)</span><br><span class="line">          hmac_code = hmac.new(</span><br><span class="line">              secret_enc, string_to_sign_enc, digestmod=hashlib.sha256</span><br><span class="line">          ).digest()</span><br><span class="line">          sign = urllib.parse.quote_plus(base64.b64encode(hmac_code))</span><br><span class="line">          return self.URL + &quot;?access_token=&#123;access_token&#125;&amp;timestamp=&#123;timestamp&#125;&amp;sign=&#123;sign&#125;&quot;.format(</span><br><span class="line">              access_token=self.access_token, timestamp=timestamp, sign=sign)</span><br><span class="line">  </span><br><span class="line">      def push(self, title: str = &quot;&quot;, content: str = &quot;&quot;) -&gt; bool:</span><br><span class="line">          msg = self.gen_markdown_msg(title, content)</span><br><span class="line">          return self.send(msg)</span><br><span class="line">  </span><br><span class="line">      def send(self, message):</span><br><span class="line">          resp = requests.post(self.target_url, json=message)</span><br><span class="line">          return resp.json()</span><br><span class="line">  </span><br><span class="line">      @staticmethod</span><br><span class="line">      def gen_text_msg(content, at=None, at_all=False):</span><br><span class="line">          if at is None:</span><br><span class="line">              at = []</span><br><span class="line">          return &#123;</span><br><span class="line">              &quot;msgtype&quot;: &quot;text&quot;,</span><br><span class="line">              &quot;text&quot;: &#123;&quot;content&quot;: content&#125;,</span><br><span class="line">              &quot;at&quot;: &#123;&quot;atMobiles&quot;: at, &quot;isAtAll&quot;: at_all&#125;,</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">      @staticmethod</span><br><span class="line">      def gen_markdown_msg(title, text, at=None, at_all=False):</span><br><span class="line">          def generateText():</span><br><span class="line">              res = &quot;&quot;</span><br><span class="line">              # 最顶行显示标题</span><br><span class="line">              res += &quot;# &quot; + title + &quot;\n&quot;</span><br><span class="line">              # 内容</span><br><span class="line">              res += text</span><br><span class="line">              # at对象</span><br><span class="line">              res += reduce(lambda x, y: x + &quot;@&quot; + y, at, &quot;&quot;)</span><br><span class="line">              return res</span><br><span class="line">  </span><br><span class="line">          return &#123;</span><br><span class="line">              &quot;msgtype&quot;: &quot;markdown&quot;,</span><br><span class="line">              &quot;markdown&quot;: &#123;</span><br><span class="line">                  &quot;title&quot;: title,</span><br><span class="line">                  &quot;text&quot;: generateText()</span><br><span class="line">              &#125;,</span><br><span class="line">              &quot;at&quot;: &#123;&quot;atMobiles&quot;: at, &quot;isAtAll&quot;: at_all&#125;,</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  class Pusher:</span><br><span class="line">      def __init__(self):</span><br><span class="line">          self.pusher = self.init()</span><br><span class="line">  </span><br><span class="line">      def init(self):</span><br><span class="line">          &quot;&quot;&quot;</span><br><span class="line">          实例化pusher</span><br><span class="line">          :return:</span><br><span class="line">          &quot;&quot;&quot;</span><br><span class="line">          from configparser import RawConfigParser</span><br><span class="line">          cp = RawConfigParser()</span><br><span class="line">          if not os.path.exists(CONFIG_INI_FILENAME):</span><br><span class="line">              raise PusherException(f&quot;请创建config.ini配置文件\npusher配置信息如下:\n&#123;REMIND_MSG&#125;&quot;)</span><br><span class="line">          cp.read(CONFIG_INI_FILENAME, encoding=&quot;utf8&quot;)</span><br><span class="line">          pusher_type = cp.get(&quot;pusher&quot;, &quot;pusher_type&quot;).lower()</span><br><span class="line">          generator_info = dict(cp.items(pusher_type))</span><br><span class="line">          # 检查pusher配置</span><br><span class="line">          if not pusher_type or not self._valid(generator_info):</span><br><span class="line">              raise PusherException(&quot;&#123;&#125;_pusher配置错误，不能为空~&quot;.format(pusher_type))</span><br><span class="line">  </span><br><span class="line">          if pusher_type == &quot;serverchan&quot;:</span><br><span class="line">              return ServerChanPush(generator_info)</span><br><span class="line">          elif pusher_type == &quot;dingding&quot;:</span><br><span class="line">              return DingDingPush(generator_info)</span><br><span class="line">          elif pusher_type == &quot;pushplus&quot;:</span><br><span class="line">            return PushplusPush(generator_info)</span><br><span class="line">          else:</span><br><span class="line">              raise PusherException(&quot;不可知pusher类型~&quot;)</span><br><span class="line">  </span><br><span class="line">      def _valid(self, config_dict: dict):</span><br><span class="line">          &quot;&quot;&quot;</span><br><span class="line">          判断字典值是否为空</span><br><span class="line">          :param dict:</span><br><span class="line">          :return:</span><br><span class="line">          &quot;&quot;&quot;</span><br><span class="line">          for v in config_dict.values():</span><br><span class="line">              if not v:</span><br><span class="line">                  return False</span><br><span class="line">          return True</span><br><span class="line">  </span><br><span class="line">      def push(self, title=&quot;&quot;, content=&quot;&quot;) -&gt; bool:</span><br><span class="line">          return self.pusher.push(title, content)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  # 如果需要push功能，则配置完成后打开注释，在别的文件中将p引入</span><br><span class="line">  # p = Pusher()</span><br></pre></td></tr></table></figure><h2 id="proxy_pool"><a class="markdownIt-Anchor" href="#proxy_pool"></a> <strong><a href="https://github.com/jhao104/proxy_pool" target="_blank" rel="noopener">proxy_pool</a></strong></h2><blockquote><p>爬虫代理IP池项目,主要功能为定时采集网上发布的免费代理验证入库，定时验证入库的代理保证代理的可用性，提供API和CLI两种使用方式。同时你也可以扩展代理源以增加代理池IP的质量和数量。</p></blockquote><ul><li><p><code>@LazyProperty</code>懒加载属性的装饰器： 只有用到时才会加载并将值注入到<code>__dict__</code>、加载一次后值就不再变化、；讲解可见：<a href="https://www.jianshu.com/p/708dc26f9b92%E2%80%94%E2%80%94%E6%8F%8F%E8%BF%B0%E7%AC%A6or%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">https://www.jianshu.com/p/708dc26f9b92——描述符or修饰符实现</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyProperty</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 在被注解类被解释器运行的时候就会创建LazyProperty实例，并进行初始化init</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="string">"""通过python描述符来实现"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            value = self.func(instance)</span><br><span class="line">            setattr(instance, self.func.__name__, value)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigHandler</span><span class="params">(withMetaclass<span class="params">(Singleton)</span>)</span>:</span></span><br><span class="line"><span class="meta">    @LazyProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serverHost</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> os.environ.get(<span class="string">"HOST"</span>, setting.HOST)</span><br></pre></td></tr></table></figure><p><code>__get__</code>只有访问类属性的时候才会生效，这边是通过setattr将serverHost设置成了ConfigHandler的类属性</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;taobao_seckill&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#taobao_seckill&quot;&gt;&lt;/a&gt; &lt;strong&gt;&lt;a href=&quot;https://github.com/jerry3747/taobao_seckil
      
    
    </summary>
    
    
      <category term="代码阅读" scheme="https://nymrli.top/tags/%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶</title>
    <link href="https://nymrli.top/2022/03/27/Python%E8%BF%9B%E9%98%B6/"/>
    <id>https://nymrli.top/2022/03/27/Python进阶/</id>
    <published>2022-03-27T14:30:39.000Z</published>
    <updated>2022-04-02T15:56:33.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="xxxatrr家族"><a class="markdownIt-Anchor" href="#xxxatrr家族"></a> xxxatrr家族</h2><h3 id="hasattr"><a class="markdownIt-Anchor" href="#hasattr"></a> hasattr()</h3><blockquote><p>用于判断对象是否包含对应的属性。</p></blockquote><p>hasattr 语法：<code>hasattr(object, name)</code></p><h3 id="setattr"><a class="markdownIt-Anchor" href="#setattr"></a> setattr()</h3><blockquote><p><strong>setattr()</strong> 函数对应函数 <a href="https://www.runoob.com/python/python-func-getattr.html" target="_blank" rel="noopener">getattr()</a>，用于设置属性值，该属性不一定是存在的。如果属性不存在会创建一个新的对象属性，并对属性进行赋值。</p></blockquote><p>setattr() 语法：<code>setattr(object, name, value)</code></p><h3 id="getattr"><a class="markdownIt-Anchor" href="#getattr"></a> getattr()</h3><blockquote><p><strong>getattr()</strong> 函数用于返回一个对象<strong>属性值</strong>。</p></blockquote><p><code>getattr(object, name[, default])</code></p><ul><li>object – 对象。</li><li>name – 字符串，对象属性。</li><li>default – 默认返回值，如果不提供该参数，在没有对应属性时，将触发 <u>AttributeError</u>。</li></ul><h2 id="__get____getattr____getattribute__"><a class="markdownIt-Anchor" href="#__get____getattr____getattribute__"></a> <a href="https://www.cnblogs.com/pyhai/p/9243551.html" target="_blank" rel="noopener"><code>__get__,__getattr__,__getattribute__</code>及区别</a></h2><h3 id="1object__getattribute__self-name"><a class="markdownIt-Anchor" href="#1object__getattribute__self-name"></a> <strong>1.<code>object.__getattribute__(self, name)</code></strong></h3><p>无条件被调用，通过实例访问属性、函数（点和getattr函数都会触发）。如果class中定义了<code>__getattribute__()</code>和<code>__getattr__()</code>，则只有在显式调用或引发AttributeError异常才会调用<code>__getattr__()</code></p><p>注：</p><ul><li>只要定义了<code>__getattribute__</code>方法，不管你访问一个存在的还是不存在的属性，都由这个方法返回，比如访问<code>t.a</code>，虽然a存在，但是只要定义了这个访问，那么就不是访问最开始的a了</li><li>如果<code>__getattribute__</code>抛出了<code>AttributeError</code>异常，并且定了了<code><strong>getattr</strong></code>函数，那么会调用<code><strong>getattr</strong></code>这个函数并返回getattr函数的返回值</li><li>属性访问的一个大致优先级是：<code>__getattribute__</code> &gt; <code>__getattr__</code> &gt; <code>__dict__</code></li></ul><h3 id="2object__getattr__self-name"><a class="markdownIt-Anchor" href="#2object__getattr__self-name"></a> <strong>2.<code>object.__getattr__(self, name)</code></strong></h3><p>为内置方法，当使用点号获取实例属性时，如果<u>属性不存在</u>(找不到attribute)的时候，会调用<code>__getattr__</code>，返回一个值或AttributeError异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">p</span><span class="params">()</span>:</span></span><br><span class="line">    s = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span></span><br><span class="line">d = p()</span><br><span class="line">print(d.s)<span class="comment"># ==&gt; 2</span></span><br><span class="line">print(d.p)  <span class="comment"># ==&gt; hello</span></span><br></pre></td></tr></table></figure><p>注：如果属性不存在，则不管是否有<code>__getattribute__</code>，都会调用<code>__getattr__</code></p><h3 id="3object__get__self-instance-owner"><a class="markdownIt-Anchor" href="#3object__get__self-instance-owner"></a> <strong>3.<code>object.__get__(self, instance, owner)</code></strong></h3><blockquote><p>Python 内置的 <code>property</code> 函数可以说是最著名的描述器之一，几乎所有讲述描述器的文章都会拿它做例子。而我们可以通过实现<code>__set__</code>、<code>__get__</code>、<code>__delete__</code>来实现自己的描述器。</p><ul><li>描述器只对新式类起作用；</li></ul><p>方法的第一个参数instance是实际拥有者的descriptor<strong>实例</strong>，如果是Descriptor类(定义了描述器协议的描述器类)则为<code>None</code>，第二个参数owner是实际所属的<strong>类本身</strong>(所有者类)。</p></blockquote><p>一个类只要实现了<code>__get__、 __set__,__delete__</code>中任意一个方法，我们就可以叫它描述器（descriptor），他是一个可以<strong>描述一个属性操作</strong>的<strong>对象</strong>。如果只定义了<code>__get__</code>我们叫非资料描述器（non-data descriptor），如果<code>__set__、 __delete__</code>：任意一个或者同时出现，叫资料描述器（data descriptor）。</p><p>首先明确一点，拥有<code>__get__</code>的类，应该**（也可以说是必须）产生一个实例**，并且这个实例是另外一个类的<strong>类属性</strong>（注意一定是类属性，通过self的方式产生就不属于<code>__get__</code>范畴了）。也就是说拥有这个方法的类，那么它的实例应该属于另外一个类/对象的一个属性。</p><p>owner是所有者的类，instance是访问descriptor的实例，如果不是通过实例访问，而是通过类访问的话，instance则为None。（descriptor的实例自己访问自己是不会触发<code>__get__</code>，而会触发<code>__call__</code>，只有descriptor作为其它类的属性才有意义。）（所以下文的d是作为C2的一个属性被调用）</p><p>将描述器作为一个独立对象，并不能展现出描述器的魔力，只有在描述器作为另一个对象的属性的时候，描述器的魔力才能真正展现出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDes</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(instance, owner)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'TestDes:__get__'</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMain</span>:</span></span><br><span class="line">    des = TestDes()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = TestMain()</span><br><span class="line">    <span class="comment"># des虽然被定义成类变量，但t.des还是跟实例相关的，对其增删改都会走到其描述器对象的__get__、__set__、__delete__中处理</span></span><br><span class="line">    print(t.des)</span><br><span class="line">    print(TestMain.des)</span><br><span class="line"><span class="comment"># 其中TestDes定义了__get__方法，在TestMain中，定义了一个类属性des，是TestDes的一个实例，我们访问t.des或者TestMain.des的时候访问的就是访问了TestDes的__get__方法。</span></span><br></pre></td></tr></table></figure><p>▲描述器往往以装饰器的方式被使用，导致二者常被混淆。描述器类和不带参数的装饰器类一样，都传入函数对象作为参数，并返回一个<strong>类实例</strong>，所不同的是，装饰器类返回 <u>callable 的实例</u>，描述器则返回<u>描述器实例</u>。</p><p>Q:如果实例中有和描述器重名的属性 <code>x</code> 怎么办？</p><p>A:资料和非资料描述器的区别在于，相对于实例字典的优先级不同。当描述器和实例字典中的某个属性重名，按访问优先级，资料描述器 &gt; 同名实例字典中的属性 &gt; 非资料描述器 or (数据描述符 &gt; 实例变量 &gt; 非数据描述符)，优先级小的会被大的覆盖。==&gt;类的方法实际就是一个仅实现了 <code>__get__()</code> 的非资料描述器，所以如果实例 <code>c</code> 中同时定义了名为 <code>foo</code> 的方法和属性，那么 <code>c.foo</code> 访问的是属性而非方法。</p><p>描述器more：<a href="https://www.jianshu.com/p/58f1df955bda" target="_blank" rel="noopener">Python 描述器解析</a></p><p>针对描述器的说明： 描述器是被<code>__getattribute__</code>调用的，如果重写了这个方法，将会阻止自动调用描述器，资料描述器总是覆盖了实例的<code>__dict__</code>， 非资料描述器可能覆盖实例的<code>__dict__</code>。</p><p>小结：访问存在的属性，如果是描述器，描述器生效</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDes</span>:</span></span><br><span class="line">    <span class="comment"># 方法的第一个参数是实际拥有者的实例，如果没有则为None，第二个参数是实际所属的类。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(instance, owner)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'TestDes:__get__'</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMain</span>:</span></span><br><span class="line">    des = TestDes()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = TestMain()</span><br><span class="line">    print(t.des)</span><br><span class="line">    print(TestMain.des)<span class="comment"># 调用时instance输出None</span></span><br></pre></td></tr></table></figure><ul><li>非资料描述器，也就是只有<code>__get__</code>，不管是类还是实例去访问，默认都获得的是<code>__get__</code>的返回值，但是，如果中间有任何一次重新赋值<code>(t.des = 1)</code>，那么，这个实例获得的是新的值(对象)，已经和原来的描述器完全脱离了关系(描述器<code>__get__</code>函数失效)</li><li>资料描述器，比如有<code>__set__</code>方法，后期通过实例对描述器进行赋值，那么访问的是<code>__set__</code>，并且永远关联起来==&gt;针对上述问题的修复。但是如果通过修改类属性的方式复制(TestMain.des = 1)，那么也会被重新获取新的值(对象)，即<code>__set__</code>函数失效。</li></ul><p><strong>总结：</strong></p><ul><li>可以看出，每次通过实例访问属性，都会经过<code>__getattribute__</code>函数。而当属性不存在时，仍然需要访问<code>__getattribute__</code>，不过接着要访问<code>__getattr__</code>，就好像是一个异常处理函数。</li><li>每次访问descriptor（即实现了<code>__get__</code>的类），都会先经过<code>__get__</code>函数。</li><li>需要注意的是，当使用类访问不存在的变量是，不会经过<code>__getattr__</code>函数。而descriptor不存在此问题，只是把instance标识为none而已。</li></ul><p>至于三者区别，首先关注：a.x时发生了什么?=&gt;属性的lookup顺序如下:</p><ul><li>如果重载了<code>__getattribute__</code>,则调用.</li><li><code>a.__dict__</code>, 实例中是不允许有descriptor的,所以不会遇到descriptor</li><li><code>A.__dict__</code>, 也即<code>a.__class__.__dict__</code>.如果遇到了descriptor,优先调用descriptor.</li><li>沿着继承链搜索父类.搜索<code>a.__class__.__bases__</code>中的所有<code>__dict__</code>. 如果有多重继承且是菱形继承的情况,按MRO(Method Resolution Order)顺序搜索.</li></ul><p>参考：</p><ul><li><a href="https://www.cnblogs.com/andy1031/p/10923834.html" target="_blank" rel="noopener">python的__get__方法看这一篇就足够了</a></li><li>more：<a href="https://www.cnblogs.com/Meanwey/p/9898222.html" target="_blank" rel="noopener">Python进阶-----描述符(<strong>get</strong>(),<strong>set</strong>(),<strong>delete</strong>())</a></li></ul><h2 id="__dict__"><a class="markdownIt-Anchor" href="#__dict__"></a> <code>__dict__</code></h2><blockquote><p>Python中大多以对象的形式存在，而对象的<strong>属性</strong>则是存在<code>__dict__</code>属性中</p></blockquote><ul><li>类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在**类<code>__dict__</code>**里的</li><li><strong>对象</strong>的<code>__dict__</code>中存储了一些self.xxx的一些东西</li></ul><p>注意</p><ul><li>内置的数据类型没有<code>__dict__</code>属性，如list、dict、int</li><li>每个类有自己的<code>__dict__</code>属性，就算存着继承关系，父类的<code>__dict__</code> 并不会影响子类的<code>__dict__</code></li><li>对象也有自己的<code>__dict__</code>属性， <a href="http://xn--self-p07f497c.xxx" target="_blank" rel="noopener">存储self.xxx</a> 信息，父子类对象公用<code>__dict__</code></li><li>对象的<code>__dict__</code>优先于类的<code>__dict__</code>调用，如<code>self.__dict__['a']=1</code>，而<code>Class.__dict__['a']=&quot;func&quot;</code>，则c.a输出的是1，而不是func</li></ul><h2 id="可变参数与unpack"><a class="markdownIt-Anchor" href="#可变参数与unpack"></a> 可变参数与unpack</h2><ol><li><p>函数的可变参数</p><p>当函数的参数前面有一个星号<code>*</code>的时候表示这是一个可变的位置参数，两个星号<code>**</code>表示是可变的关键字参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saySomething</span><span class="params">(word, *args, **kwargs)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="comment"># word会被赋值成hello word, </span></span><br><span class="line"><span class="comment"># mrli和mrdu被打包进args数组中</span></span><br><span class="line"><span class="comment"># size=15; color=white会被作为kv传到kwargs的字典中</span></span><br><span class="line">saySomething(<span class="string">"hello word"</span>, <span class="string">"mrli"</span>, <span class="string">"mrdu"</span>, size=<span class="number">15</span>, color=<span class="string">"white"</span>)</span><br></pre></td></tr></table></figure></li><li><p>unpack参数</p><p>星号<code>*</code>把序列/集合解包（unpack）成位置参数，两个星号<code>**</code>把字典解包成关键字参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">txtOptions = &#123;</span><br><span class="line"><span class="string">"fontSize"</span>: <span class="number">15</span>,</span><br><span class="line"><span class="string">"color"</span>: <span class="string">"white"</span></span><br><span class="line">&#125;</span><br><span class="line">addtional_text = (<span class="string">"mrli"</span>, <span class="string">"mrdu"</span>)</span><br><span class="line"><span class="comment"># unpack的形式传参数</span></span><br><span class="line">saySomething(<span class="string">"hello word"</span>, *addtional_text, **txtOptions)</span><br><span class="line"><span class="comment"># 两句话是等价的</span></span><br><span class="line">saySomething(<span class="string">"hello word"</span>, <span class="string">"mrli"</span>, <span class="string">"mrdu"</span>, size=<span class="number">15</span>, color=<span class="string">"white"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拓展-我们经常在开源库的doc中看到某个函数能接收xxx参数，但是点进去一看，最底层的参数传的是**kwargs。按道理我们是什么参数都可以传的，大不了函数不解析这些无用参数罢了，但是实际上当我们传API中没有写到的参数时会报错。 ==&gt; 这个是由于kwargs能传递的参数受限于最底层的参数需求，以requests.get为例</span></span><br><span class="line"><span class="comment"># requests.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(url, params=None, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> request(<span class="string">'get'</span>, url, params=params, **kwargs)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(method, url, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> session.request(method=method, url=url, **kwargs)</span><br><span class="line"><span class="comment"># get中能传的**关键字参数**实际上只能是这些关键字参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self, method, url,</span></span></span><br><span class="line"><span class="function"><span class="params">            params=None, data=None, headers=None, cookies=None, files=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            auth=None, timeout=None, allow_redirects=True, proxies=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            hooks=None, stream=None, verify=None, cert=None, json=None)</span>:</span></span><br><span class="line"><span class="comment"># Python也是通过这两个特性从而实现了**重写overrided**</span></span><br></pre></td></tr></table></figure><ul><li>至于星号(<code>*</code>)还有一个用途是来明确写明位置参数的截断位置，<code>*</code>后的参数也不能再以位置参数的形式给出，必须以关键字参数的形式给出——见<a href="https://blog.csdn.net/weixin_40796925/article/details/107654347" target="_blank" rel="noopener">Python3 函数参数列表单独一个星号 * 的作用</a></li></ul></li></ol><p>类比Go中的<code>...</code>语法</p><h2 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h2><blockquote><p>装饰器(Decorators)是 Python 的一个重要部分，通过他们可以在不用更改原函数的代码前提下，修改、拓展其他函数的功能的函数，他们有助于让我们的代码更简洁。==&gt;切面编程的方式</p></blockquote><p><strong>闭包</strong></p><blockquote><p>Python查找变量会一层层地向外层查找，直到global全局也没有时raise <code>NameError: name 'xxx' is not defined</code></p></blockquote><p>在装饰器中运用到了闭包的思想。闭包，一句话说就是，在函数中再嵌套一个函数，并且引用<strong>外部函数</strong>的变量，这就是一个闭包了。(从而使得内部函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起)</p><p>执行闭包后，闭包实例将会维持了一个词法环境，其中包含对局部变量的引用，使得原本就应该失效的局部变量仍然存活。</p><p><strong>闭包的应用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">2</span>)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>从本质上讲，<code>makeAdder</code> 是一个函数工厂 — 他创建了将指定的值和它的参数相加求和的函数。在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。</p><p><code>add5</code> 和 <code>add10</code> 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在 <code>add5</code> 的环境中，<code>x</code> 为 5。而在 <code>add10</code> 中，<code>x</code> 则为 10。</p><p>more： <a href="https://www.bilibili.com/video/BV1ZJ411y7Te?from=search&amp;seid=15415737541054747822&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener">5句口诀理解记忆Python闭包和装饰器</a></p><p>[<strong>装饰器类型</strong>](<a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p05_define_decorator_with_user_adjustable_attributes.html" target="_blank" rel="noopener">9.5 可自定义属性的装饰器 — python3-cookbook 3.0.0 文档</a>)</p><p>闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。<strong>外部函数相当于给内部函数提供了一个额外数据的执行环境</strong>，使得内部函数（被装饰函数）拥有了获得外层函数的数据or执行了外层函数。根据参数[或是叫环境不同]，可以分成如下几种装饰器：</p><ul><li><p>无参数</p><ul><li><p>常见的有输出日志</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_log</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"do before"</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">"do after"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@do_log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(word)</span>:</span></span><br><span class="line">    print(word)</span><br><span class="line">say(<span class="string">"hello world"</span>)</span><br><span class="line"><span class="comment"># 等价于下面两局</span></span><br><span class="line"><span class="comment"># say = do_log(say)</span></span><br><span class="line"><span class="comment"># say("hello world") ===&gt; do_log(say)("hello world")</span></span><br></pre></td></tr></table></figure><p>这个可以类比JS</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">word</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(word);</span><br><span class="line">&#125;</span><br><span class="line">play = <span class="function"><span class="keyword">function</span>(<span class="params">w</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我要开始笑啦"</span>);</span><br><span class="line">    say(w);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我不笑了"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// play相当于装饰了一层say, 同比上面的do_log也是。在之后的执行中play和do_log才是真正的执行函数, 只不过Python语法糖@，让do_log又赋值给了say, 所以我们又可以直接使用say，从而增加了函数原本的功能</span></span><br></pre></td></tr></table></figure></li><li><p>@语法糖：它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作</p></li></ul></li><li><p>默认参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createLogger</span><span class="params">()</span>:</span></span><br><span class="line">    logger = logging.getLogger(<span class="string">"decorate"</span>)</span><br><span class="line">    formatter = logging.Formatter(<span class="string">'%(asctime)s-%(name)s-%(levelname)s-%(message)s'</span>)</span><br><span class="line">    sh = logging.StreamHandler()</span><br><span class="line">    sh.setLevel(logging.DEBUG)</span><br><span class="line">    sh.setFormatter(formatter)</span><br><span class="line">    logger.addHandler(sh)</span><br><span class="line">    <span class="keyword">return</span> logger</span><br><span class="line">logger = createLogger()</span><br><span class="line">logger.warning(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_by_level</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="comment"># 创建新环境：多提供了一个level变量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_log</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            getattr(logger, level)(<span class="string">"do before"</span>)</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">            getattr(logger, level)(<span class="string">"do after"</span>)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> do_log</span><br><span class="line"></span><br><span class="line"><span class="meta">@log_by_level("warning")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(word)</span>:</span></span><br><span class="line">    print(word)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">do_log = log_by_level(<span class="string">"warning"</span>) <span class="comment"># 作用是提供了一个level=warning的环境</span></span><br><span class="line">say = do_log(say)</span><br><span class="line">say(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure></li><li><p>可自定义属性的装饰器：</p><blockquote><p>允许用户提供参数在<strong>运行时</strong>控制装饰器行为。比如前端设置一个单选，可以控制日志输出级别，此时则需要在运行时修改装饰器行为</p></blockquote></li><li><p>可选参数</p><blockquote><p>既可以不传参数给它，比如 <code>@decorator</code> ， 也可以传递可选参数给它，比如 <code>@decorator(x,y,z)</code> 。</p></blockquote><p>实现见：<a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p06_define_decorator_that_takes_optional_argument.html" target="_blank" rel="noopener">9.6 带可选参数的装饰器 — python3-cookbook 3.0.0 文档</a></p></li><li><p>类装饰器：</p><blockquote><p>使用一个装饰器去包装函数，返回的是一个可调用的<strong>实例</strong></p></blockquote><p>类装饰器主要依靠类的<code>__call__</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassDecorator</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"enter"</span>)</span><br><span class="line">        self.func()</span><br><span class="line">        print(<span class="string">"end"</span>)</span><br><span class="line"><span class="meta">@ClassDecorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'bar'</span>)</span><br><span class="line"><span class="comment"># bar = ClassDecorator(bar)</span></span><br><span class="line"><span class="comment"># bar() ==&gt; ClassDecorator(bar)()  调用实例==&gt;即触发__call__方法</span></span><br></pre></td></tr></table></figure></li><li><p>类中装饰器:</p><blockquote><p>在类中定义装饰器，并将其作用在其他函数或方法上</p></blockquote><p>跟无参数的装饰器一样写法，只不过定义在类中；并且在使用的时候是以<code>@Decorator.decortae</code>的形式</p></li><li><p>类方法、静态方法装饰器：跟无参数的装饰器一样写法，但是需要在@staticmethod、@classmethod之前标注</p></li></ul><p>▲<strong>注意：</strong></p><ul><li><p>装饰器只会在<strong>函数定义</strong>时被调用一次</p></li><li><p>可以看到的是，在装饰器代码中总有一行<code>@wraps(func)</code>的代码，其目的：是你写了一个装饰器作用在某个函数上，但是这个函数的重要的元信息比如名字、文档字符串、注解和参数签名都丢失了----&gt;任何时候你定义装饰器的时候，都应该使用functools库中的@wraps装饰器来注解底层包装函数</p></li><li><p>装饰器的执行是依次的，离函数签名越近，则越先被定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@a</span></span><br><span class="line"><span class="meta">@b</span></span><br><span class="line"><span class="meta">@c</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span> <span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 等价于 f = a(b(c(f)))</span></span><br></pre></td></tr></table></figure></li></ul><p>总结：</p><p>理解装饰器应该从①<code>@</code>语法糖到底做了什么；②闭包是什么，有什么作用；③装饰器如何等价表示；来理解</p><h2 id="懒加载属性"><a class="markdownIt-Anchor" href="#懒加载属性"></a> <a href="https://www.jianshu.com/p/708dc26f9b92" target="_blank" rel="noopener">懒加载属性</a></h2><p><strong>描述符+<a href="#%E8%A3%85%E9%A5%B0%E5%99%A8">类装饰器</a>实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyProperty</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化func为serverHost函数</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            value = self.func(instance)</span><br><span class="line">            <span class="comment"># 会将结果值通过setattr方法存入到instance实例的__dict__中</span></span><br><span class="line">            setattr(instance, self.func.__name__, value)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigHandler</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 返回一个LazyProperty实例 </span></span><br><span class="line"><span class="meta">    @LazyProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serverHost</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> os.environ.get(<span class="string">"HOST"</span>, setting.HOST)</span><br><span class="line"></span><br><span class="line">setting = namedtuple(<span class="string">"setting"</span>, [<span class="string">"HOST"</span>])</span><br><span class="line">setting.HOST = <span class="string">"g"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试一</span></span><br><span class="line">a = ConfigHandler()</span><br><span class="line">print(a.__dict__)</span><br><span class="line"><span class="comment"># 1. 注解先是创建了LazyProperty(serverHost)的实例</span></span><br><span class="line"><span class="comment"># 2. 再是语法糖进行了赋值serverHost = LazyProperty(serverHost)</span></span><br><span class="line"><span class="comment"># 3. 当第一次进行调用的时候, instance = configHandler**实例**, self.func(instance实例) == 调用serverHost(instance实例)从而获得了真正值value。而之后的 setattr处将self实例的__dict__中添加了serverHost-value，再次访问self.serverHost时, 已经不再是函数, 而是value值(serverHost不再从ConfigHandler.__dict__中取, 而是实例a.__dict__中取)</span></span><br><span class="line">print(a.serverHost)</span><br><span class="line">print(<span class="string">"say"</span>)</span><br><span class="line">print(a.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试二</span></span><br><span class="line"><span class="comment"># 如果先执行类的__dict__能看到类的serverHost是一个**描述器对象实例**=&gt; 'serverHost': &lt;__main__.LazyProperty object at 0x0000020A1AEB7FD0&gt;</span></span><br><span class="line">print(ConfigHandler.__dict__)</span><br><span class="line"><span class="comment"># 通过__dir__能见到serverHost为实例的一个方法</span></span><br><span class="line">print(a.__dir__())</span><br><span class="line"><span class="comment"># 此时a.__dict__为空</span></span><br><span class="line">print(a.serverHost)</span><br><span class="line"><span class="comment"># 等到调用过a.serverHost后可以发现a.__dict__中多了serverHost</span></span><br><span class="line">print(a.__dict__)</span><br><span class="line"><span class="comment"># 由于实例__dict__会优先于类的__dict__使用，所以直接返回了value值</span></span><br></pre></td></tr></table></figure><p>重点：</p><ol><li>跟[<code>print(t.des)</code>](#3.<code>object.__get__(self, instance, owner)</code>)会触发t.des指向的descriptor实例的<code>__get__</code>一样，通过类<code>__dict__[&quot;serverHost&quot;]</code>，其也是个描述器实例，因此也会触发LazyProperty object的<code>__get__</code></li><li>实例<a href="#%60__dict__%60"><code>__dict__</code></a>会优先于类的<code>__dict__</code>使用，如果实例<code>__dict__</code>找不到，会往上类<code>__dict__</code>找</li></ol><p><strong>修饰符(方法装饰器)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_property</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="comment"># 创建protected属性</span></span><br><span class="line">    attr_name = <span class="string">"_lazy_"</span> + func.__name__</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_lazy_property</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># print("done")</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, attr_name):</span><br><span class="line">            <span class="comment"># print("set")</span></span><br><span class="line">            setattr(self, attr_name, func(self))</span><br><span class="line">        <span class="keyword">return</span> getattr(self, attr_name)</span><br><span class="line">    <span class="keyword">return</span> _lazy_property</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, radius)</span>:</span></span><br><span class="line">        self.radius = radius</span><br><span class="line"></span><br><span class="line"><span class="meta">    @lazy_property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * self.radius ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当解析Circle类、定义area方法的时候，会将Circle.area = @property修饰的_lazy_property函数</span></span><br><span class="line">c = Circle(<span class="number">4</span>)</span><br><span class="line">print(<span class="string">'before calculate area'</span>)</span><br><span class="line">print(c.__dict__)</span><br><span class="line"><span class="comment"># 当调用c.area时，会输出done, 此时会执行_lazy_property内的具体函数, 此次会进行setattr</span></span><br><span class="line">print(c.area)</span><br><span class="line"><span class="comment"># 此次不会调用setattr</span></span><br><span class="line">print(c.area)</span><br><span class="line">print(<span class="string">'after calculate area'</span>)</span><br><span class="line">print(c.__dict__)</span><br><span class="line">c.radius = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>借鉴：<a href="https://www.jianshu.com/p/708dc26f9b92" target="_blank" rel="noopener">Python中的lazy property</a></p><h2 id="__new__"><a class="markdownIt-Anchor" href="#__new__"></a> <code>__new__</code></h2><blockquote><p><code>__new__()</code> 是一种负责<strong>创建类实例</strong>的静态方法，它无需使用 staticmethod 装饰器修饰，且该方法会优先 <code>__init__()</code> 初始化方法被调用。</p></blockquote><p><code>__new__()</code>通常会返回该类的一个实例，但有时也可能会返回其他类的实例，其<code>super().__new__(cls)</code>中会调用<code>__init__</code>，因此我们可以通过改写子类的<code>__new__</code>添加一些逻辑来控制实例的产生，然后通过<code>super().__new__(cls)</code>来生成一个instance并返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demoClass</span>:</span></span><br><span class="line">    instances_created = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># __new__(): &lt;class '__main__.demoClass'&gt; ('abc',) &#123;&#125;</span></span><br><span class="line">        print(<span class="string">"__new__():"</span>, cls, args, kwargs)</span><br><span class="line">        <span class="comment"># 1. 通过父类__new__生成一个实例</span></span><br><span class="line">        <span class="comment"># 在super().__new__(cls)中会调用__init__并生成实例</span></span><br><span class="line">        instance = super().__new__(cls)</span><br><span class="line">        <span class="comment"># 2. 自己重写要实现的逻辑</span></span><br><span class="line">        instance.number = cls.instances_created</span><br><span class="line">        cls.instances_created += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 3. 将父类生成的实例返回</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, attribute)</span>:</span></span><br><span class="line">        <span class="comment"># __init__(): &lt;__main__.demoClass object at 0x00000185A6466EB0&gt; abc</span></span><br><span class="line">        print(<span class="string">"__init__():"</span>, self, attribute)</span><br><span class="line">        self.attribute = attribute</span><br><span class="line"></span><br><span class="line">test1 = demoClass(<span class="string">"abc"</span>)</span><br><span class="line">test2 = demoClass(<span class="string">"xyz"</span>)</span><br><span class="line">print(test1.number, test1.instances_created)</span><br><span class="line">print(test2.number, test2.instances_created)</span><br></pre></td></tr></table></figure><p>Q:什么情况下使用<code>__new__()</code>呢？答案很简单，在<code>__init__()</code>不够用的时候。</p><p><code>__new__()</code>通常会返回该类的一个实例，但有时也可能会返回其他类的实例，如果发生了这种情况，则会跳过对 <code>__init__()</code>方法的调用。而在某些情况下（比如需要修改<strong>不可变类实例</strong>（<a href="http://c.biancheng.net/python/" target="_blank" rel="noopener">Python</a> 的某些内置类型）的创建行为），利用这一点会事半功倍。比如：<a href="http://c.biancheng.net/view/5484.html%EF%BC%8C%E5%AF%B9" target="_blank" rel="noopener">http://c.biancheng.net/view/5484.html，对</a> Python 不可变的内置类型（如 int、str、float 等）进行了子类化，这是因为一旦创建了这样不可变的对象实例，就无法在<code>__init__()</code>方法中对其进行修改。</p><p>注：由于 <code>__new__()</code> 不限于返回同一个类的实例，所以很容易被滥用，不负责任地使用这种方法可能会对代码有害，所以要谨慎使用。</p><h2 id="metaclass元类"><a class="markdownIt-Anchor" href="#metaclass元类"></a> <a href="http://c.biancheng.net/view/2293.html" target="_blank" rel="noopener">MetaClass元类</a></h2><blockquote><p>承接上文<code>__new__</code>，Python中大量使用<code>__new__()</code>方法且合理的，就是 MetaClass 元类。</p><p>MetaClass元类，本质也是一个类，但和普通类的用法不同，它可以对<strong>类内部的定义</strong>（包括类属性和类方法）进行<strong>动态的修改</strong>。可以这么说，使用元类的主要目的就是为了实现在创建类时，能够动态地改变类中定义的属性或者方法。</p></blockquote><p>举个例子，根据实际场景的需要，我们要为多个类添加一个 name 属性和一个 say() 方法。显然有多种方法可以实现，但其中一种方法就是使用 MetaClass 元类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstMetaClass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="comment"># cls代表动态修改的类</span></span><br><span class="line">    <span class="comment"># name代表动态修改的类名</span></span><br><span class="line">    <span class="comment"># bases代表被动态修改的类的所有父类</span></span><br><span class="line">    <span class="comment"># attr代表被动态修改的类的所有属性、方法组成的字典</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        <span class="comment"># 动态为该类添加一个name属性</span></span><br><span class="line">        attrs[<span class="string">'name'</span>] = <span class="string">"C语言中文网"</span></span><br><span class="line">        attrs[<span class="string">'say'</span>] = <span class="keyword">lambda</span> self: print(<span class="string">"调用 say() 实例方法"</span>)</span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls,name,bases,attrs)</span><br><span class="line">        </span><br><span class="line"><span class="comment">#定义类时，指定元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLanguage</span><span class="params">(object,metaclass=FirstMetaClass)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">clangs = CLanguage()</span><br><span class="line">print(clangs.name)</span><br><span class="line">clangs.say()</span><br></pre></td></tr></table></figure><p>可以看到，在创建类时，通过在标注父类的同时指定元类（格式为<code>metaclass=元类名</code>），则当 <a href="http://c.biancheng.net/python/" target="_blank" rel="noopener">Python</a> 解释器在创建这该类时，FirstMetaClass 元类中的<code>__new__</code>方法就会被调用，从而实现动态修改类属性或者类方法的目的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMeta3</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        print(cls)    <span class="comment"># 当前类 </span></span><br><span class="line">        print(<span class="string">"name"</span>, name)<span class="comment"># 如果是通过metaclass触发的，此处为调用metaclass的类的类型</span></span><br><span class="line">        print(<span class="string">"bases"</span>, bases)<span class="comment"># 如果是通过metaclass触发的，此处为调用metaclass的类的父类</span></span><br><span class="line">        print(<span class="string">"attrs"</span>, attrs)<span class="comment"># 如果是通过metaclass触发的，此处为调用metaclass的类的属性</span></span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pa3</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># python3中可以直接通过metaclass关键字参数来指定类的元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eg3</span><span class="params">(Pa3, metaclass=TestMeta3)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        kkk = []</span><br><span class="line">        kkk.append(self.__skiless__)</span><br><span class="line">        <span class="keyword">return</span> kkk</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">acc2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'a2'</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出</span></span><br><span class="line"><span class="string">&lt;class '__main__.TestMeta3'&gt;</span></span><br><span class="line"><span class="string">name Eg3</span></span><br><span class="line"><span class="string">bases (&lt;class '__main__.Pa3'&gt;,)</span></span><br><span class="line"><span class="string">attrs &#123;'__module__': '__main__', '__qualname__': 'Eg3', 'get': &lt;classmethod object at 0x00000263511C6FA0&gt;, 'acc2': &lt;function Eg3.acc2 at 0x00000263511C5310&gt;&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>在定义的时候，发现竟然有输出。因为定义的时候，python解释器会在当前类中查找metaclass[3]，如果找到了，就<strong>使用该metaclass创建Eg3类</strong>。所以打印出来的name、bases、attrs都和Eg3有关。</p><p><strong>元类和父类的区别：</strong></p><p>在定义子类的时候，我们有两个选择：①是传需要继承的父类；②自定义的元类。</p><ul><li>父类是子类的模板，子类的功能是跟父类紧耦合的，子类和父类一般是一一对应的</li><li>元类是子类的修饰器，可以为该子类和其他子类都添加自定义功能，并且不在继承关系中(<code>Class.__mro__</code>查看)，子类和元类是一对多的关系。元类并不是特地为某个子类服务的</li></ul><p><strong>with_metaclass</strong></p><blockquote><p>由于python2和python3中元类使用方法的不同，我们需要使用一种兼容的方式[1]，如下所示：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">withMetaclass</span><span class="params">(meta, *bases)</span>:</span></span><br><span class="line">    <span class="string">"""Create a base class with a metaclass."""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># This requires a bit of explanation: the basic idea is to make a dummy</span></span><br><span class="line">    <span class="comment"># metaclass for one level of class instantiation that replaces itself with</span></span><br><span class="line">    <span class="comment"># the actual metaclass.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MetaClass</span><span class="params">(meta)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, this_bases, d)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> meta(name, bases, d)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type.__new__(MetaClass, <span class="string">'temporary_class'</span>, (), &#123;&#125;)</span><br></pre></td></tr></table></figure><p><code>with_metaclass</code>返回的临时类中，本身无任何属性，但包含了元类和基类的所有信息，并在<strong>下一步定义类时</strong>将所有信息解包出来[1]。</p><p>见：<a href="https://zhuanlan.zhihu.com/p/354828950" target="_blank" rel="noopener">Python 元类及with_metaclass</a></p><h2 id="__type__"><a class="markdownIt-Anchor" href="#__type__"></a> <a href="http://c.biancheng.net/view/2292.html" target="_blank" rel="noopener"><code>__type__</code>动态创建类</a></h2><ul><li>type() 函数属于 <a href="http://c.biancheng.net/python/" target="_blank" rel="noopener">Python</a> 内置函数，通常用来查看某个变量的具体类型。<ul><li><code>type(obj)</code></li></ul></li><li>其实，type() 函数还有一个更高级的用法，即<strong>创建</strong>一个自定义<strong>类型</strong>（也就是创建一个类）。<ul><li><code>type(name, bases, dict)</code>：其中 name 表示类的名称；bases 表示一个元组，其中存储的是该类的父类；dict 表示一个字典，用于表示类内定义的属性或者方法。</li></ul></li></ul><p>实际上<code>type(name, bases, dict)</code>是调用了type类的<code>type.__init__(cls, what, bases=None, dict=None)</code>方法，创建了一个type的实例（类类型就是一个type实例），类型是<code>&lt;class 'type'&gt;</code></p><ul><li>此外type还有<code>__new__(*args, **kwargs)</code>，其作用是<code>Create and return a new object.</code>，可以写成<code>type.__new__(ClassTpye, name, base, dicts)</code>，但ClassType必须是type的子类。会返回一个ClassType的<strong>instance</strong>，此类为ClassTpye的实例，self属性有dicts中的值</li></ul><p>此外补充一下: <strong>&lt;class ‘type’&gt;是所有类型的类型。&lt;class ‘object’&gt;也是所有对象的超类（除了它自己，包括type）</strong></p><h2 id="通过元类创建单例类"><a class="markdownIt-Anchor" href="#通过元类创建单例类"></a> 通过元类创建单例类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意这边继承了type, 所以下面的__call__是重写type的__call__，即创建实例的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Singleton Metaclass</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    _inst = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._inst:</span><br><span class="line">            cls._inst[cls] = super(Singleton, cls).__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._inst[cls]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">withMetaclass</span><span class="params">(meta, *bases)</span>:</span></span><br><span class="line">    <span class="string">"""Create a base class with a metaclass."""</span></span><br><span class="line">    <span class="comment"># 这需要一点解释：基本思想是为一个级别的类实例化创建一个虚拟元类，用实际的元类替换它自己。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># KeyPoint1. 继承meta类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MetaClass</span><span class="params">(meta)</span>:</span></span><br><span class="line">        <span class="comment"># 实际上下面的__new__不影响</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, this_bases, d)</span>:</span></span><br><span class="line">            <span class="comment"># cls为withMetaclass; name为使用者的类型; this_bases为使用者的父类们; d为使用者的属性</span></span><br><span class="line">            <span class="keyword">return</span> meta(name, bases, d)</span><br><span class="line">    <span class="comment"># KeyPoint2. type.__new__创建一个名称叫temporary_class，类型为MetaClass的类</span></span><br><span class="line">    <span class="comment"># ▲注意type.__new__中的类类型必须是type的子类</span></span><br><span class="line">    <span class="keyword">return</span> type.__new__(MetaClass, <span class="string">'temporary_class'</span>, (), &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigHandler</span><span class="params">(withMetaclass<span class="params">(Singleton)</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"__init__"</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="meta">    @LazyProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serverHost</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> os.environ.get(<span class="string">"HOST"</span>, setting.HOST)</span><br><span class="line"><span class="comment"># res=withMetaclass(Singleton)的类型为&lt;class 'util.six.withMetaclass.&lt;locals&gt;.MetaClass'&gt;</span></span><br><span class="line"><span class="comment"># 将其传给ConfigHandler作为父类，在定义 ConfigHandler 时会触发MetaClass.__new__, 于是调用meta(name, bases, d)，此处的meta为Singleton，而name为ConfigHandler类, bases为空, d为ConfigHandler的属性和方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(type(ConfigHandler)) ==&gt;  &lt;class 'util.singleton.Singleton'&gt;</span></span><br><span class="line"><span class="comment"># 因此 c = ConfigHandler() ==&gt; Singleton的__call__方法，</span></span><br><span class="line">当c = ConfigHandler()时会因为type.__new__(MetaClass, <span class="string">'temporary_class'</span>, (), &#123;&#125;)去找MetaClass的__call__进行调用，MetaClass没有__call__则找到了其父类meta(Singleton)的__call__</span><br></pre></td></tr></table></figure><p>注：类也是对象，是元类的对象，即我们实例化一个类时，调用其元类的<code>__call__(cls, *args, **kwargs)</code>方法进行创建对象。</p><h2 id="__call__"><a class="markdownIt-Anchor" href="#__call__"></a> <code>__call__</code></h2><blockquote><p>一个非常特殊的实例方法，即<code>__call__()</code>。该方法的功能类似于在类中重载 () 运算符，使得类实例对象可以像调用普通函数那样，以“<strong>对象名()</strong>”的形式使用。</p></blockquote><p>实际上，如果不重写<code>__call__</code>的话，<code>Class.__call__(*args, **kwargs)</code>还承担着产生类实例的功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认继承的是object, 而不是type</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">"init"</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"call"</span>)</span><br><span class="line"><span class="comment"># 当没有重写__call__时</span></span><br><span class="line">res = Meta.__call__(<span class="string">"asd"</span>)</span><br><span class="line">print(res, type(res))</span><br><span class="line">res = Meta(<span class="string">"asd"</span>)</span><br><span class="line">print(res, type(res))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">init</span></span><br><span class="line"><span class="string">&lt;__main__.Meta object at 0x0000014FB5115EE0&gt; &lt;class '__main__.Meta'&gt;</span></span><br><span class="line"><span class="string">init</span></span><br><span class="line"><span class="string">&lt;__main__.Meta object at 0x0000014FB5115A90&gt; &lt;class '__main__.Meta'&gt;</span></span><br><span class="line"><span class="string">上述两种都能创建对象</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 当重写__call__以后, __call__()返回实例的效果就失效了</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">call</span></span><br><span class="line"><span class="string">None &lt;class 'NoneType'&gt;</span></span><br><span class="line"><span class="string">init</span></span><br><span class="line"><span class="string">&lt;__main__.Meta object at 0x0000016CC2745EE0&gt; &lt;class '__main__.Meta'&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 当继承type时，所有都失效了，没办法再以__call__和Meta()来创建实例了</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   res = Meta("asd")</span></span><br><span class="line"><span class="string">TypeError: type.__new__() takes exactly 3 arguments (1 given)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>Q:我们在实例化一个对象的时候<code>f = Foo(1, y=2)</code>，可以发现在<code>__init__()</code>中并没有返回实例，但调用<code>Foo(1, y=2)</code><strong>确实</strong>返回了一个对象，而且，<code>__init__</code>预期一个<code>self</code>参数，但是当我们调用<code>Foo(1, y=2)</code>时这里并没有这个参数。那么类实例化的过程到底是怎么样的呢？</p><p>A:构造顺序——<a href="https://www.jianshu.com/p/f63ad9d550f1" target="_blank" rel="noopener">理解python的类实例化</a></p><p>首先明确一点，Python中的<strong>类也是对象</strong>！类、函数、方法以及实例都是对象——type的对象，并且无论何时你将一对括号放在它们的名字后面时，就会调用它们的<code>__call__</code>方法。所以<code>Foo(1, y=2)</code>是等价于<code>Foo.__call__(1, y=2)</code>的。<code>__call__</code>方法是定义在<code>Foo</code>的类中的。<code>Foo</code>的类是什么呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">type</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>所以<code>Foo</code>是类型<code>type</code>的一个对象，并且调用type类的<code>__call__(self, *args, **kwargs)</code>返回一个<code>Foo</code>类的对象。让我们看下<code>type</code>中的<code>__call__</code>方法是什么样的。这个方法相当的复杂，但是我们尝试尽量简化它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这边的obj_type跟cls一样</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(obj_type, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># 通过__new__创建一个空的类实例，如果obj_type没有__new__则使用type.__new__</span></span><br><span class="line">    obj = obj_type.__new__(*args, **kwargs)</span><br><span class="line">    <span class="comment"># 进行类型检查</span></span><br><span class="line">    <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> issubclass(obj, obj_type):</span><br><span class="line">        <span class="comment"># 对类进行__init__初始化</span></span><br><span class="line">        obj.__init__(*args, **kwargs)</span><br><span class="line">    <span class="comment"># 返回类实例</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure><p>可见<code>__new__</code>方法为对象分配了内存空间，构建它为一个“空&quot;对象然后<code>__init__</code>方法被调用来初始化它。</p><p>总的来说：</p><ol><li><code>Foo(*args, **kwargs)</code>等价于<code>Foo.__call__(*args, **kwargs)</code></li><li>既然<code>Foo</code>是一个<code>type</code>的实例，<code>Foo.__call__(*args, **kwargs)</code>实际调用的是<code>type.__call__(Foo, *args, **kwargs)</code></li><li><code>type.__call__(Foo, *args, **kwargs)</code>调用<code>obj_type.__new__(*args, **kwargs)</code>也就是<code>type.__new__(Foo, *args, **kwargs)</code>，然后返回一个对象实例obj。</li><li><code>obj</code>随后通过调用<code>obj.__init__(*args, **kwargs)</code>被初始化。</li><li><code>obj</code>被<code>type.__call__</code>中返回。</li></ol><p>需要注意的是，正是因为都用到了原型type中的<code>__call__</code>，如果类对<code>__call__</code>进行了<strong>定义</strong>(注意不是重写，<code>print(dir(Class))</code>时能看到<code>__call__</code>并不在其中)，比如 <code>Foo</code> 定义了一个 <code>__call__</code>方法，<code>Foo.__call__(*args, **kwargs)</code>不再等于<code>Foo(*args, **kwargs)</code> ，因为其<code>Foo.__call__</code>定义中明确指出需要一个self变量===&gt; 实际上不管是不是定义了<code>__call__</code>，进行<code>Foo(*args, **kwargs)</code>创建实例时都进行了<code>type.__call__</code>的逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class A(type):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;init&quot;)</span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;end&quot;)</span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(&quot;A call&quot;)</span><br><span class="line">        return self</span><br><span class="line">class Meta(A):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">res = type.__new__(Meta, &quot;instance&quot;, (), &#123;&#125;)</span><br><span class="line"># 当A有__call__时，res.__call__()和res()都会执行__call__里的逻辑</span><br><span class="line">print(res, type(res))</span><br><span class="line">print(res.__call__())</span><br><span class="line">print(type(res()))</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">&lt;class &apos;__main__.instance&apos;&gt; &lt;class &apos;__main__.Meta&apos;&gt;</span><br><span class="line">&lt;class &apos;__main__.instance&apos;&gt;</span><br><span class="line">&lt;class &apos;__main__.Meta&apos;&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># 当没有__call__时，将会调用type.__call__创建一个实例</span><br><span class="line">&lt;class &apos;__main__.instance&apos;&gt; &lt;class &apos;__main__.Meta&apos;&gt;</span><br><span class="line">&lt;__main__.instance object at 0x0000027186E65B20&gt;</span><br><span class="line">&lt;class &apos;__main__.instance&apos;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;xxxatrr家族&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#xxxatrr家族&quot;&gt;&lt;/a&gt; xxxatrr家族&lt;/h2&gt;
&lt;h3 id=&quot;hasattr&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#h
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>JS逆向-webpack打包网站实战</title>
    <link href="https://nymrli.top/2022/03/23/JS%E9%80%86%E5%90%91-webpack%E6%89%93%E5%8C%85%E7%BD%91%E7%AB%99%E5%AE%9E%E6%88%98/"/>
    <id>https://nymrli.top/2022/03/23/JS逆向-webpack打包网站实战/</id>
    <published>2022-03-23T08:21:50.000Z</published>
    <updated>2022-04-03T09:25:42.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack逆向"><a class="markdownIt-Anchor" href="#webpack逆向"></a> Webpack逆向</h1><p><a href="https://so.csdn.net/so/search?q=webpack&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">webpack</a>打包是前端js模块化压缩打包常用的手段，特征明显，比如下方的形式的代码就是webpack<strong>分发器</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分发器</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">xx</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ..call(**.exports, ***, ***.exports, xx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>又或者更直观的表现n[“xxx”]这种，你可以大概知道了这是调用了webpack打包的js模块代码。</p><p><strong>webpack打包后JS依赖模块代码的固定结构</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">this</span>[<span class="string">"webpackJsonpzsgk-pc"</span>] = <span class="keyword">this</span>[<span class="string">"webpackJsonpzsgk-pc"</span>] || []).push([[<span class="number">15</span>], [<span class="function"><span class="keyword">function</span>(<span class="params">e, t, n</span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    e.exports = n(<span class="number">693</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数固定为e, t, n</span></span><br><span class="line">, <span class="function"><span class="keyword">function</span>(<span class="params">e, t, n</span>) </span>&#123;</span><br><span class="line">    e.exports = n(<span class="number">697</span>)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说个逆向webpack的通用方法：</p><ol><li><p>先去找加密网站的<strong>加密入口</strong>。这应该是加密网站都必须要做的==&gt; 直接根据参数名搜索参数</p></li><li><p>找到<strong>分发器的位置</strong>，或者说是加载器，n[“xxx”]这种的n就是分发器，就比如下方中的exports的位置，最后执行了d函数==&gt;一般是runtimexxx.js中(提供环境)；一般以<code>! function(e) {</code>的形式出现</p><p><img src="/2022/03/23/JS逆向-webpack打包网站实战/%E5%88%86%E5%8F%91%E5%99%A8.jpg" alt="分发器"></p></li><li><p>寻找分发编号、加密使用模块（用到了哪些模块就导入哪些模块）==&gt;一般在chunk-lib.js，以<code>(window.webpackJsonp = window.webpackJsonp || []).push([</code>的形式出现</p></li><li><p>将函数入口的地方返回全局变量，最终返回: <code>var sign; var window = global;!function(){... sign = d}</code>， 赋值为分发器返回的d</p></li><li><p>使用自定义的sign代替webpack代码中的n进行加密</p></li></ol><p>from: <a href="https://blog.csdn.https" target="_blank" rel="noopener">https://blog.csdn.https</a>😕/blog.csdn.net/weixin_41586984/article/details/116268341net/weixin_41586984/article/details/116268341</p><h2 id="调试技巧"><a class="markdownIt-Anchor" href="#调试技巧"></a> 调试技巧</h2><h3 id="定位请求参数"><a class="markdownIt-Anchor" href="#定位请求参数"></a> 定位请求参数</h3><ol><li><p>打开开发者工具后，F5刷新后<code>Ctrl + Shift + F</code>搜索参数名，如signdata，会显示多个JS文件，选择后仔细查看(点击左下角<code>{}</code>美观格式化按钮)。</p><p>more： 如果文件太多，则直接通过请求的链接去找，比如<code>user/login</code></p></li><li><p>Network找到新发出的xhr条目后，查看Initiator里的调用栈信息，如Login；</p></li></ol><p>注： 如果加密参数名称比较简单如s，比较难定位的话，可以借助请求的其他参数来查找，比如verificationCode</p><h3 id="调试工具"><a class="markdownIt-Anchor" href="#调试工具"></a> 调试工具</h3><ul><li>断点调试breakpoints</li><li>XHR断点： XHR/fetch breakpoints</li></ul><h2 id="附录-js记录"><a class="markdownIt-Anchor" href="#附录-js记录"></a> 附录-Js记录</h2><ul><li><p>时间戳: <code>(new Date).getTime()</code></p></li><li><p><code>var a = (f1(), f2(), f3())</code>后，f1、f2、f3函数都会执行，而a最后的结果为f3的返回值</p></li><li><p>javascript:void(0):  <strong>void</strong> 是 JavaScript 中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值。</p></li><li><p><code>TypeError: window.btoa is not a function</code></p><p>btoa-atob 模块没有输出一个编程接口，它只提供命令行工具。</p><p>如果你需要转换为Base64，你可以用Buffer来完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Buffer.from(<span class="string">'Hello World!'</span>).toString(<span class="string">'base64'</span>));</span><br></pre></td></tr></table></figure><p>相反的，假设你要解码的内容是一个base64编码过的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Buffer.from(b64Encoded, <span class="string">'base64'</span>).toString());</span><br></pre></td></tr></table></figure></li></ul><h1 id="做题记录"><a class="markdownIt-Anchor" href="#做题记录"></a> 做题记录</h1><h2 id="nstr题型"><a class="markdownIt-Anchor" href="#nstr题型"></a> n[“str”]题型：</h2><h3 id="天安财险"><a class="markdownIt-Anchor" href="#天安财险"></a> 天安财险</h3><blockquote><p><code>var m = this.newEncrypt(JSON.stringify(h));</code></p></blockquote><ul><li><p>需要对this.privaKey的值细化下，传入拿到固定的str</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//           , p = t("NFKh")          , s = t("cg2h")</span></span><br><span class="line">l.prototype.newEncrypt = <span class="function"><span class="keyword">function</span>(<span class="params">l</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> n = p.enc.Utf8.parse(<span class="keyword">this</span>.privaKey)</span><br><span class="line">                  , t = p.enc.Utf8.parse(<span class="keyword">this</span>.privaKey)</span><br><span class="line">                  , e = p.enc.Utf8.parse(l)</span><br><span class="line">                  , a = p.AES.encrypt(e, n, &#123;</span><br><span class="line">                    iv: t,</span><br><span class="line">                    mode: p.mode.CBC,</span><br><span class="line">                    padding: p.pad.Pkcs7</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> p.enc.Base64.stringify(a.ciphertext)</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="财新网"><a class="markdownIt-Anchor" href="#财新网"></a> 财新网</h3><blockquote><p><code>password: this.encode(this.encrypt(this.form.password)),</code></p></blockquote><ul><li><code>c = a(&quot;3452&quot;)</code>、<code>n = a.n(c)</code>，看到需要依赖3452后立马Ctrl+shift+F全局搜3452，然后把整个webpack模块扒下来</li></ul><h3 id="中远海运"><a class="markdownIt-Anchor" href="#中远海运"></a> 中远海运</h3><ul><li>n(“MuMZ”)中又有<code>r = n(&quot;XBrZ&quot;);</code>，在另一个文件中，module需要放两个</li></ul><h3 id="天翼云"><a class="markdownIt-Anchor" href="#天翼云"></a> 天翼云：</h3><blockquote><p><code>var t = encodeURIComponent(c[&quot;c&quot;].Des.encrypt(this.form.email, this.form.pwd)),</code></p></blockquote><p>webpack实现</p><p><code>c = (mycode(&quot;ac6a&quot;), mycode(&quot;b3ae&quot;))</code></p><ul><li>分发器和ac6a模块在同一个文件中、而ac6a模块依赖模块在另一个文件内；</li><li>分发器()({})，无感叹号</li><li>分发器()({})大括号中自带较多依赖模块</li></ul><p>自己实现：直接扒下来encrypt加密的JS内容</p><h3 id="看准网"><a class="markdownIt-Anchor" href="#看准网"></a> 看准网</h3><ul><li>分发器n(“xxx”)定位后跟一般的固定格式返回a、n、r不同，写的是个函数==&gt;还是可以根据obj.Func来赋值<code>mycode = obj;</code></li><li><a href="https://www.bilibili.com/video/BV1bb4y127bc?spm_id_from=333.999.0.0" target="_blank" rel="noopener">JS逆向实战分析–看准网webpack加解密分析</a>——Python中使用execjs示范</li></ul><h3 id="企名片"><a class="markdownIt-Anchor" href="#企名片"></a> <a href="https://www.qimingpian.cn/finosda/project/pinvestment" target="_blank" rel="noopener">企名片</a></h3><blockquote><ul><li><code>u = i(&quot;x4Ab&quot;)</code></li><li><code>return e.encrypt_data &amp;&amp; (e.data = Object(u.a)(e.encrypt_data)),</code></li></ul></blockquote><ul><li><p>x4Ab模块依赖aqBw，aqBw又依赖YuTi、yLpj，因此依赖项中放&quot;x4Ab&quot;、“aqBw”、“YuTi”、&quot;yLpj&quot;函数定义</p></li><li><p>模拟解析函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encrypt</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data &amp;&amp; (<span class="built_in">Object</span>(u.a)(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="nnum题型"><a class="markdownIt-Anchor" href="#nnum题型"></a> n[num]题型：</h2><h3 id="大麦"><a class="markdownIt-Anchor" href="#大麦"></a> 大麦</h3><ul><li>删除分发器多余代码</li><li><code>var navigator = {}</code></li></ul><h3 id="掌上高考"><a class="markdownIt-Anchor" href="#掌上高考"></a> <a href="https://www.gaokao.cn/school/263/provinceline" target="_blank" rel="noopener">掌上高考</a>：</h3><ol><li>分发器在html文件内</li><li><code>o = (u=a(42), a.n(u))</code>，使用到了<code>a.n(u)</code>即点n函数</li><li>依赖函数的给出是以数组的形式，而不是字典的形式</li><li>模块中依赖更多模块==&gt;引入整个模块文件，但是跟&quot;xxx&quot;模式不同的是，由于没有用字典<code>{&quot;xxx&quot;: function()}</code>的形式，因此直接require也没用<code>TypeError: Cannot read property '42' of undefined</code>，而是将依赖模块数组作为参数写入到分发器依赖函数中<code>!function(e){}([...])</code>即方括号中，从而才能找到42函数</li></ol><h3 id="酷我"><a class="markdownIt-Anchor" href="#酷我"></a> <a href="https://www.bilibili.com/video/BV1gq4y1D781?from=search&amp;seid=7720105602891609746&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener">酷我</a></h3><blockquote><p><code>t.data.reqId = n,</code></p></blockquote><ul><li><p>直接通过n(109)定位可能不那么准确(双击后定位的函数)，可以试着直接在分发器位置进行断点，然后console输出e[“109”]</p></li><li><p>只要分发器定义部分(其他的删了，因为只用了<code>l=n(109)、c=n.n(l)</code>)+依赖模块中定义109函数(整个function而不是t.exports)，以及观察其中还依赖什么如n(202)、n(203)就补充拿什么</p><ul><li>n.n(l)是传入什么就返回什么:<a href="https://www.bilibili.com/video/BV1gq4y1D781?from=search&amp;seid=7720105602891609746&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1gq4y1D781?from=search&amp;seid=7720105602891609746&amp;spm_id_from=333.337.0.0</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不删分发器中其他部分</span></span><br><span class="line">l = mycode(<span class="number">109</span>)</span><br><span class="line">c = mycode.n(l)<span class="comment">// ==&gt;得到l</span></span><br><span class="line"><span class="keyword">var</span> r = c()();</span><br><span class="line"><span class="built_in">console</span>.log(r)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于只用到了n.n(l)，所以可以删分发器大代码中其他部分, 在使用时直接让c=l</span></span><br><span class="line">l = mycode(<span class="number">109</span>)</span><br><span class="line">c = l();</span><br><span class="line"><span class="built_in">console</span>.log(c)<span class="comment">// 等价于 r = l(); console(r)</span></span><br></pre></td></tr></table></figure></li></ul><p>文章: <a href="https://blog.csdn.net/weixin_43189702/article/details/119860838" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43189702/article/details/119860838</a></p><h2 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意：</h2><ul><li><p>require模块内容可以放在逆向JS文件里一起，而不是一定得创建新的JS文件导入</p></li><li><p>先登录然后找到加密处加断点，这个断点会在发起登录请求时才触发；往上找分发器，加上断点，分发器位置的断点是在页面刷新时触发，因此要触发这个断点需要刷新页面</p></li><li><p>找加密函数<code>c[&quot;c&quot;].Des.encrypt(this.form.email, this.form.pwd)</code>的时候，找完整的函数如c[“c”].Des.encrypt，而不是直接找c</p></li><li><p>n(42), 或者n(“xxx”)，可以直接搜xxx，也可以在console里面输出后找到对应的FunctionLocation来快速定位</p></li><li><p>如果依赖模块是字典的形式，则分发器依赖中写字典，如<code>!function(e){..}({ 32:function(){...}})</code>（一般情况<code>n(32)、n(&quot;ABCD&quot;)</code>）， 如果不是则需要传函数数组，如<code>n(42)</code>，此处42表示的是第42个函数，见掌上高考。</p></li><li><p><code>var mycode;</code>后赋值的位置直接在分发器的下方即可，不用在最后面</p></li><li><p>提示缺少<code>window</code>时，定义全局变量<code>var window = global;</code>，（JS逆向文件、依赖文件）</p><ul><li><p>window表示<strong>浏览器</strong>打开的窗口，在客户端JavaScript中window对象是全局的对象，所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。但在nodejs中直接调用window是不存在的，而代替的是global，所以要用nodejs运行时，得用<code>var window = global;</code></p></li><li><p><code>var navigator = this</code>等价于<code>var navigator = {}</code>，因为在NodeJS文件中运行输出this后可以发现<code>this={}</code>，而在浏览器中this默认为window（函数或类作用域内为函数或者类实例）</p></li><li><p>from：<a href="https://blog.csdn.net/mystric594/article/details/72519788" target="_blank" rel="noopener">JS中document和window的区别</a></p></li></ul></li></ul><p><strong>心得</strong></p><p>①所有webpack打包的的js都要先看懂打包后<strong>代码运行</strong>的顺序，找到加密处；②找到webpack对象，一般是 n(数字) 调用③确定分发器。④找依赖模块，有时候各包的依赖关系太多，可以直接把文件爬下来引入，如果各个包的依赖关系不多，就可以只把调用到的函数找出来放到依赖中。⑤最后剩下的就是找到你要的代码，慢慢复现调用加密/解密函数就好了。</p><h2 id="做题案例学习视频"><a class="markdownIt-Anchor" href="#做题案例学习视频"></a> 做题案例学习视频</h2><ul><li>webpack师承：<a href="https://space.bilibili.com/453818250/video?tid=0&amp;page=1&amp;keyword=&amp;order=pubdate" target="_blank" rel="noopener">爬取webpack流程-视频</a>——大多都是n(“Xvmd”)</li><li>而如果n中调用的不是字典的形式，而是列表的形式，则看<a href="https://www.cnblogs.com/Eeyhan/p/15562632.html" target="_blank" rel="noopener">js逆向安全指南（3）-- webpack解包指南</a>、<a href="https://www.bilibili.com/video/BV1gq4y1D781?from=search&amp;seid=7720105602891609746&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener">使用 webpack 的 js 加密参数的分析——酷我</a></li></ul><h2 id="进阶资料"><a class="markdownIt-Anchor" href="#进阶资料"></a> 进阶资料</h2><ul><li><a href="https://www.cnblogs.com/borntodie/p/15042669.html" target="_blank" rel="noopener">9-爬虫高级实战【js逆向】 </a></li><li><a href="https://blog.csdn.net/Qiled/article/details/109610726" target="_blank" rel="noopener">JS逆向学习笔记 - 持续更新中</a></li><li>webpack补充依赖项做法：<ul><li><a href="https://www.jianshu.com/p/5c42730a4e84" target="_blank" rel="noopener">https://www.jianshu.com/p/5c42730a4e84</a></li><li><a href="https://zhuanlan.zhihu.com/p/79706247" target="_blank" rel="noopener">webpack4之《模块运行机制原理》</a></li></ul></li><li>JS逆向视频<ul><li><a href="https://www.bilibili.com/video/BV1wp4y1z7L6?p=42" target="_blank" rel="noopener">爬虫工程师进阶必会之JS逆向(反爬)</a></li><li><a href="https://www.bilibili.com/video/BV1XR4y147fQ?p=85" target="_blank" rel="noopener">遇到网站加密爬不了？？这几个视频教你如何学会爬虫高阶内容js逆向，入狱必学！</a></li></ul></li></ul><h2 id="掌上高考解密过程"><a class="markdownIt-Anchor" href="#掌上高考解密过程"></a> 掌上高考解密过程</h2><h3 id="解析响应datatext"><a class="markdownIt-Anchor" href="#解析响应datatext"></a> 解析响应data.text</h3><blockquote><p>相应的data.text是加密的，页面通过JS解密后渲染</p></blockquote><ol><li><p>确定加密位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="literal">null</span> != l &amp;&amp; <span class="literal">null</span> !== (a = l.data) &amp;&amp; <span class="keyword">void</span> <span class="number">0</span> !== a &amp;&amp; a.text &amp;&amp; (l.data = (n = (e = &#123;</span><br><span class="line">            iv: u.uri,</span><br><span class="line">            text: l.data.text,</span><br><span class="line">            SIGN: h</span><br><span class="line">        &#125;).iv,</span><br></pre></td></tr></table></figure></li><li><p>确定分发器位置，在html内</p><p>通过打断<code>o = (u=a(42), a.n(u))// 等价于 o = a(42)</code></p></li><li><p>确定依赖模块：给<code>return e[a].call(c.exports, c, c.exports, r),</code>打断点后console输出<code>e[&quot;42&quot;]</code>查看a(42)位置：</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">e, t, n</span>) </span>&#123;</span><br><span class="line">    e.exports = (e = n(<span class="number">21</span>),</span><br><span class="line">    n(<span class="number">201</span>),</span><br><span class="line">    n(<span class="number">825</span>),</span><br><span class="line">    ...</span><br><span class="line">    n(<span class="number">847</span>),</span><br><span class="line">    e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到需要依赖多个，因此直接把整个文件引入</p><ol start="4"><li>扣解密函数：注意<code>return</code>表达式后是逗号的情况：会从左到右执行执行，并返回最后一个。注意：JS函数并<strong>不能返回多个返回值</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">then((<span class="function"><span class="keyword">function</span>(<span class="params">l</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> e, a, t, b, n;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span> != l &amp;&amp; <span class="literal">null</span> !== (a = l.data) &amp;&amp; <span class="keyword">void</span> <span class="number">0</span> !== a &amp;&amp; a.text &amp;&amp; (l.data = (n = (e = &#123;</span><br><span class="line">            iv: u.uri,</span><br><span class="line">            text: l.data.text,</span><br><span class="line">            SIGN: h</span><br><span class="line">        &#125;).iv,</span><br><span class="line">        a = e.text,</span><br><span class="line">        e = e.SIGN,</span><br><span class="line">        e = o.a.PBKDF2(e, <span class="string">"secret"</span>, &#123;</span><br><span class="line">            keySize: <span class="number">8</span>,</span><br><span class="line">            iterations: <span class="number">1e3</span>,</span><br><span class="line">            hasher: o.a.algo.SHA256</span><br><span class="line">        &#125;).toString(),</span><br><span class="line">        n = o.a.PBKDF2(n, <span class="string">"secret"</span>, &#123;</span><br><span class="line">            keySize: <span class="number">4</span>,</span><br><span class="line">            iterations: <span class="number">1e3</span>,</span><br><span class="line">            hasher: o.a.algo.SHA256</span><br><span class="line">        &#125;).toString(),</span><br><span class="line">        a = o.a.lib.CipherParams.create(&#123;</span><br><span class="line">            ciphertext: o.a.enc.Hex.parse(a)</span><br><span class="line">        &#125;),</span><br><span class="line">        n = o.a.AES.decrypt(a, o.a.enc.Hex.parse(e), &#123;</span><br><span class="line">            iv: o.a.enc.Hex.parse(n)</span><br><span class="line">        &#125;),</span><br><span class="line"><span class="comment">// data.text解析结果</span></span><br><span class="line">        <span class="built_in">JSON</span>.parse(n.toString(o.a.enc.Utf8)))),</span><br><span class="line">    v &amp;&amp; (t = r,</span><br><span class="line">        b = l,</span><br><span class="line">        <span class="literal">null</span> !== (n = <span class="built_in">window</span>.apiConfig) &amp;&amp; <span class="keyword">void</span> <span class="number">0</span> !== n &amp;&amp; <span class="literal">null</span> !== (n = n.filterCacheList) &amp;&amp; <span class="keyword">void</span> <span class="number">0</span> !== n &amp;&amp; n.length ? <span class="built_in">window</span>.apiConfig.filterCacheList.forEach((<span class="function"><span class="keyword">function</span>(<span class="params">l</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">RegExp</span>(l).test(t) || d.set(t, b)</span><br><span class="line">        &#125;)) : d.set(t, b)),</span><br><span class="line">    l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>难点：</p><ul><li><p>跟&quot;xxx&quot;模式不同的是，由于没有用字典<code>{&quot;xxx&quot;: function()}</code>的形式，因此直接require也没用<code>TypeError: Cannot read property '42' of undefined</code>，而是将依赖模块函数数组作为参数写入到分发器依赖函数中<code>!function(e){}([...])</code>即方括号中，从而才能找到42函数</p><ul><li><p>挑选push后第二个<code>[]</code>中的函数数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">this</span>[<span class="string">"webpackJsonpzsgk-pc"</span>] = <span class="keyword">this</span>[<span class="string">"webpackJsonpzsgk-pc"</span>] || []).push([[<span class="number">15</span>], [<span class="function"><span class="keyword">function</span>(<span class="params">e, t, n</span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    e.exports = n(<span class="number">693</span>)</span><br><span class="line">&#125;,</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">]]);<span class="comment">// 第一个]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>理解了a.n的含义后，可以直接把<code>o = (u=a(42), a.n(u))</code>转化为<code>o=a(42)</code></p></li></ul><h3 id="获得加密参数signsafe"><a class="markdownIt-Anchor" href="#获得加密参数signsafe"></a> 获得加密参数signsafe</h3><blockquote><p>大致流程跟data.text差不多，但是<code>p = c()(g)</code>执行时，会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; Md5.prototype.update = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">if</span> (!<span class="keyword">this</span>.finalized) &#123;</span><br><span class="line">&gt;         <span class="keyword">var</span> t, n = <span class="keyword">typeof</span> e;</span><br><span class="line">&gt;         <span class="keyword">if</span> (<span class="string">"string"</span> != n) &#123;</span><br><span class="line">&gt;             <span class="keyword">if</span> (<span class="string">"object"</span> != n)</span><br><span class="line">&gt;                 <span class="keyword">throw</span> ERROR;</span><br><span class="line">&gt;             <span class="keyword">if</span> (<span class="literal">null</span> === e)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>根据一步步调试之后发现，还是<code>c = (u=a(291),a.n(u))</code>直接替换出的问题</p></blockquote><ol><li><p>Ctrl + shift + F定位参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">g = <span class="keyword">void</span> <span class="number">0</span>,</span><br><span class="line">    g = (t = &#123;</span><br><span class="line">    SIGN: h,</span><br><span class="line">    str: f.replace(<span class="regexp">/^\/|https?:\/\/\/?/</span>, <span class="string">""</span>)</span><br><span class="line">&#125;).SIGN,</span><br><span class="line">    t = t.str,</span><br><span class="line">    g = o.a.HmacSHA1(o.a.enc.Utf8.parse(t), g),</span><br><span class="line">    g = o.a.enc.Base64.stringify(g).toString(),</span><br><span class="line">    p = c()(g),</span><br><span class="line">    u.signsafe = p,</span><br></pre></td></tr></table></figure></li><li><p>往上找c和o.a: <code>o = (u = a(42),a.n(u))</code>, <code>c = (u = a(291),a.n(u))</code></p></li><li><p>找到分发器扣出==&gt;这次不能删除分发器中多余的函数，比如r.a、r.d、r.n因为后面得用</p></li><li><p>将依赖模块跟data.text一样，放入分发器依赖模块中</p></li><li><p>扣加密函数</p><blockquote><p>网页上是return后多段内容，以及g变量不断被修改，因此通过一步步调试确定入参，以及分解return抽离出真正的加密参数signsafe</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">h = <span class="string">"D23ABC@#56"</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;</span><br><span class="line"></span><br><span class="line">o.a = mycode(<span class="number">42</span>)</span><br><span class="line"><span class="comment">// ▲</span></span><br><span class="line">c = (u = mycode(<span class="number">291</span>), mycode.n(u))</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对url进行加密</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encrypt</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    g = (t = &#123;</span><br><span class="line">            SIGN: h,</span><br><span class="line">            str: f.replace(<span class="regexp">/^\/|https?:\/\/\/?/</span>, <span class="string">""</span>)</span><br><span class="line">        &#125;).SIGN,</span><br><span class="line">        t = t.str;</span><br><span class="line">    <span class="comment">// console.log(t, g);</span></span><br><span class="line">    g = o.a.HmacSHA1(o.a.enc.Utf8.parse(t), g);</span><br><span class="line">    <span class="comment">// console.log(g)</span></span><br><span class="line">    g = o.a.enc.Base64.stringify(g).toString();</span><br><span class="line">    <span class="comment">// console.log(g)</span></span><br><span class="line">    p = c()(g);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = encrypt(<span class="string">"https://api.eol.cn/web/api/counter?cid=1&amp;did=263"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure></li></ol><p>可以看到o.a和c的赋值是不一样的，虽然说大多数情况x = a.n(u)等价于x=u，但难免有时会有不一样，因此谨慎期间，还是还原到底最好。</p><h4 id="python调用"><a class="markdownIt-Anchor" href="#python调用"></a> Python调用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_signsafe_by_javascript</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="comment"># 两个 JavaScript 脚本，两种方法均可</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'gk_signsafe.js'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        exec_js = f.read()</span><br><span class="line">    signsafe = execjs.compile(exec_js).call(<span class="string">'encrypt'</span>, url)</span><br><span class="line">    <span class="keyword">return</span> signsafe</span><br><span class="line">signsafe = get_encrypted_password_by_javascript(<span class="string">"https://api.eol.cn/web/api/counter?cid=1&amp;did=263"</span>)</span><br><span class="line">print(signsafe)</span><br></pre></td></tr></table></figure><h2 id="rsa的加密步骤"><a class="markdownIt-Anchor" href="#rsa的加密步骤"></a> RSA的加密步骤</h2><ol><li>获取公钥</li><li>实例化  ===&gt; 扣出网站RSA实例化对象的代码</li><li>设置公钥</li><li>对文本进行加密 ==&gt; 扣出复现RSA加密的逻辑代码</li></ol><p>注： <code>var window=global</code>、<code>var navigator={}</code></p><ul><li><p><a href="https://www.bilibili.com/video/BV1jB4y1K7uw?spm_id_from=333.999.0.0" target="_blank" rel="noopener">B站RSA</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// window.JSEncrypt is not a constructor 在抠出来的JS Encrypt代码中加上</span></span><br><span class="line"><span class="built_in">window</span>.JSEncrpt = ze</span><br><span class="line"><span class="comment">// 网页中位var n = new JSEncrypt ==&gt; JSEncrypt is not defined</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">window</span>.JSEncrypt;</span><br><span class="line">n.setPublicKey...</span><br><span class="line"><span class="keyword">var</span> a = n.encrypt(t.data.hash + password);</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure></li><li><p><a href="https://www.bilibili.com/video/BV1Qh411B77h?spm_id_from=333.999.0.0" target="_blank" rel="noopener">网易云爬评论</a>：python通过execjs来调用JS代码，代码中用到了<code>CryptoJS</code>库， 需要<code>os.environ[&quot;NODE_PATH&quot;]=&quot;F:/..../node_modules&quot;</code>把库导入</p></li><li><p><a href="https://www.bilibili.com/video/BV1eQ4y1Q7RE?spm_id_from=333.999.0.0" target="_blank" rel="noopener">JS逆向实战分析–某铁网分析</a>：document返回类型，initiator是一条条文本(Other)，因为其没有用ajax(XHR)，而是通过原生的网页表单提交</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loginForm.password.value = encryptByDES(loginForm.password.value), loginForm.publickey.value);</span><br><span class="line">loginForm.submit();</span><br></pre></td></tr></table></figure><ul><li><p>直接require导入CryptoJS模块</p></li><li><p>or直接扣encryptByDES的加密函数==&gt;出现<code>cannot read property 'createEncryptor' of undefined</code></p></li><li><p>MD5加密：</p><ul><li><p>JS: <code>const crypto = require(&quot;CryptoJS&quot;); crypto.MD5('待加密字符串').toString()</code></p></li><li><p>Python: <a href="https://blog.csdn.net/weixin_44799217/article/details/112486097" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44799217/article/details/112486097</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 法一：创建md5对象</span></span><br><span class="line">hl = hashlib.md5()</span><br><span class="line"><span class="comment"># Tips</span></span><br><span class="line"><span class="comment"># 此处必须声明encode，若写法为hl.update(str) 报错为： Unicode-objects must be encoded before hashing</span></span><br><span class="line">hl.update(str.encode(encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法二：</span></span><br><span class="line">str_md5 = hashlib.md5(str.encode(encoding=<span class="string">'utf-8'</span>)).hexdigest()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>base64编码</p><ul><li><p>JS: <code>CryptoJS.enc.Base64.parse(&quot;待解密字符串&quot;).toString(CryptoJS.enc.Utf8)</code></p></li><li><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串</span></span><br><span class="line">encode_str = base64.encodebytes(test_str.encode(<span class="string">'utf8'</span>))  <span class="comment"># b'aGVsbG8gd29ybGQh\n'</span></span><br><span class="line">print(encode_str.decode())  <span class="comment"># 默认以utf8解码，结果 aGVsbG8gd29ybGQh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"D:\\redis.png"</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    encode_img = base64.b64encode(f.read())</span><br><span class="line">    file_ext = os.path.splitext(<span class="string">"D:\\redis.png"</span>)[<span class="number">1</span>]</span><br><span class="line">    print(<span class="string">'data:image/&#123;&#125;;base64,&#123;&#125;'</span>.format(file_ext[<span class="number">1</span>:], encode_img.decode()))</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="加密-摘要算法结果特征"><a class="markdownIt-Anchor" href="#加密-摘要算法结果特征"></a> 加密、摘要算法结果特征</h2><h3 id="urlencode"><a class="markdownIt-Anchor" href="#urlencode"></a> urlencode</h3><blockquote><p>urlencode是一个函数，可将字符串以<a href="https://baike.baidu.com/item/URL%E7%BC%96%E7%A0%81/3703727" target="_blank" rel="noopener">URL编码</a>，用于编码处理。</p><p>URL编码(URL encoding)，也称作<strong>百分号编码</strong>(Percent-encoding)， 是特定上下文的<a href="https://baike.baidu.com/item/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6/4438100" target="_blank" rel="noopener">统一资源定位符</a> (URL)的编码机制。</p></blockquote><h3 id="base64特征"><a class="markdownIt-Anchor" href="#base64特征"></a> Base64特征</h3><blockquote><p>最常见的用于传输8Bit<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E7%A0%81/9953683" target="_blank" rel="noopener">字节码</a>的<strong>编码方式</strong>之一</p></blockquote><ul><li>相同内容，结果是相同的</li><li>a-zA-Z,0-9,+/共64个字符进行编码；每3个字节编码成4个字节，不足的在<strong>结尾</strong>有无意义的**=**来填补<ul><li>一般情况下结尾都会有1个或者2个等号，明文长度是3的倍数时没有=；</li></ul></li><li>内容越长，结果越长</li></ul><p>注：跟下面的算法区分一下，base64是编码方式，并不能算加密算法。应用场景还有传输图片:<code>data:image/jpg;base64,/9j/4QMZRXhpZgAASUk...</code></p><h3 id="md5特征"><a class="markdownIt-Anchor" href="#md5特征"></a> md5特征</h3><blockquote><p><strong>消息摘要算法</strong></p></blockquote><ul><li>确定唯一性：相同内容，结果是相同的；但一般会有时间戳等参数，所以导致了每次不同</li><li>不可逆性：有损的加密过程，理论上无法解密（逆向推出），除非暴力破解。安全，这也是其成为校验是否被修改的最关键的性质</li><li>碰撞性：原始数据与其MD5值并不是一一对应的，有可能多个原始数据计算出来的MD5值是一样的，这就是碰撞。</li><li>一般MD5值是32位，由数字“0-9”和字母“a-f”所组成的字符串；字母可以是全大写或者全小写<ul><li>密文一般为 16 位或者 32 位，其中 16 位是取的 32 位第 9~25 位的值；</li></ul></li><li>长度：32个<strong>十六进制</strong>字符组成的字符串 (128位)</li></ul><h3 id="rsa特征"><a class="markdownIt-Anchor" href="#rsa特征"></a> RSA特征</h3><ul><li>相同内容，结果也是不同的</li><li>明文长度需要小于密钥长度，而密文长度则等于密钥长度。一般为1024、2048、3072、4096或512（低于1024的安全不建议）</li><li>通过公钥加密结果，必须私钥解密。 同样私钥加密结果，公钥可以解密</li></ul><p>注：RSA加解密中必须考虑到的密钥长度、明文长度和密文长度问题；</p><p>▲.一般会使用 JSEncrypt 库，会有 new 一个实例对象的操作；</p><h3 id="sha-系列"><a class="markdownIt-Anchor" href="#sha-系列"></a> SHA 系列</h3><blockquote><p>SHA 是比 MD5 更安全一点的摘要算法，SHA 通常指 SHA 家族算法，</p></blockquote><p><strong>sha1</strong></p><blockquote><p>字母（a-f）和数字（0-9）混合</p><p>密文特征跟MD5差不多，只不过数字是40位，bit位数（160）==&gt;4位<strong>十六进制</strong>表示一个数</p></blockquote><p><strong>Sha256</strong></p><blockquote><p>字母（a-f）和数字（0-9）混合</p><p>对于任意长度的消息，SHA256都会产生一个256位的哈希值，即64位十六进制数，称作消息摘要。</p></blockquote><p><strong>HMAC</strong></p><blockquote><p>在md5和sha1加密的基础上引入了秘钥，而秘钥又只有传输双方才知道，所以基本上是破解不了的，常用于接口签名验证</p></blockquote><h3 id="aes-des-3des-rc4-rabbit-等"><a class="markdownIt-Anchor" href="#aes-des-3des-rc4-rabbit-等"></a> AES、DES、3DES、RC4、Rabbit 等</h3><p>AES、DES、3DES、RC4、Rabbit 等加密算法的密文通常没有固定的长度，他们通常使用<code>crypto-js</code>库来实现</p><p>参考：<a href="https://juejin.cn/post/7052978567390429215" target="_blank" rel="noopener">https://juejin.cn/post/7052978567390429215</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;webpack逆向&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#webpack逆向&quot;&gt;&lt;/a&gt; Webpack逆向&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://so.csdn.net/so/search?q=webpack&amp;am
      
    
    </summary>
    
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>2022年3月19~20日-爬虫项目记录</title>
    <link href="https://nymrli.top/2022/03/19/2022%E5%B9%B43%E6%9C%8819%E6%97%A5-20%E6%97%A5%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    <id>https://nymrli.top/2022/03/19/2022年3月19日-20日爬虫项目记录/</id>
    <published>2022-03-19T11:06:06.000Z</published>
    <updated>2022-04-03T09:25:24.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2022年3月20日公告存网站页面到数据库"><a class="markdownIt-Anchor" href="#2022年3月20日公告存网站页面到数据库"></a> 2022年3月20日——公告存网站页面到数据库</h1><h2 id="文件存储"><a class="markdownIt-Anchor" href="#文件存储"></a> 文件存储</h2><ol><li>文件夹不允许出现<code>/\:*?|&lt;&gt;&quot;</code></li><li>a标签中href不能有, 因为通过etree.tostring会被转义成%5C===&gt;进行了str.replace(&quot;\&quot;, “/”)</li><li>windows下路径分隔符是<code>\\</code>, 所以save_path中会有<code>\\</code>, 因此使用<code>save_path.replace(&quot;\\&quot;, &quot;/&quot;)</code>可以解决</li><li>多级创建文件夹<code>os.makedirs()</code>、单层创建<code>os.mkdir()</code><br>5文件名称问题: 乱码太长报错, 将其取a标签中内容解决</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 乱码太长报错</span></span><br><span class="line">s = <span class="string">".\\attaches\\11963218-2021年09月22日华能能源交通产业控股有限公司集团物资供应中心（甘肃区域）07月份集中物资供应--八零三电厂阀门询价采购（包093）询价书询价公告\\������������������������������������������07������������������������--���������������������������������������093���.wps"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(s, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">b"ggg"</span>)</span><br></pre></td></tr></table></figure><h2 id="数据库表"><a class="markdownIt-Anchor" href="#数据库表"></a> 数据库表</h2><p><strong>varchar能存多少汉字、数字？</strong></p><p>具体还是要看版本的，一个字符占用3个字节  ，一个汉字（包括数字）占用3个字节=一个字符</p><ul><li><strong>4.0版本以下</strong>，varchar(100)，指的是<strong>100字节</strong>，如果存放UTF8汉字时，只能存33个（每个汉字3字节）</li><li><strong>5.0版本以上</strong>**，varchar(100)，指的是<strong>100字符</strong>，⭐️无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放100个。</li><li><strong>UTF8编码中一个汉字（包括数字）占用3个字节</strong></li><li><em>GBK编码中一个汉字（包括数字）占用2个字节</em>*</li></ul><p><strong>varchar的最大长度是多少呢？</strong></p><p>mysql的vachar字段的类型虽然最大长度是65535，但是并不是能存这么多数据，最大可以到65533，其中需要1到2个字节来存储数据长度（如果列声明的长度超过255，则使用两个字节来存储长度，否则1个）字节，当不允许非空字段的时候（因为要用一个字节来存储不可为空的标识），当允许非空字段的时候只能到65532(省下了存储非空的那个字节)。</p><h3 id="mysql字段类型存储需要多少字节"><a class="markdownIt-Anchor" href="#mysql字段类型存储需要多少字节"></a> mysql字段类型存储需要多少字节？</h3><p><strong>数字类型</strong></p><table><thead><tr><th style="text-align:left">列类型</th><th style="text-align:left">需要的存储量</th></tr></thead><tbody><tr><td style="text-align:left">TINYINT</td><td style="text-align:left">1 字节</td></tr><tr><td style="text-align:left">SMALLINT</td><td style="text-align:left">2 个字节</td></tr><tr><td style="text-align:left">MEDIUMINT</td><td style="text-align:left">3 个字节</td></tr><tr><td style="text-align:left">INT</td><td style="text-align:left">4 个字节</td></tr><tr><td style="text-align:left">INTEGER</td><td style="text-align:left">4 个字节</td></tr><tr><td style="text-align:left">BIGINT</td><td style="text-align:left">8 个字节</td></tr><tr><td style="text-align:left">FLOAT(X)</td><td style="text-align:left">4 如果 X &lt; = 24 或 8 如果 25 &lt; = X &lt; = 53</td></tr><tr><td style="text-align:left">FLOAT</td><td style="text-align:left">4 个字节</td></tr><tr><td style="text-align:left">DOUBLE</td><td style="text-align:left">8 个字节</td></tr><tr><td style="text-align:left">DOUBLE PRECISION</td><td style="text-align:left">8 个字节</td></tr><tr><td style="text-align:left">REAL</td><td style="text-align:left">8 个字节</td></tr><tr><td style="text-align:left">DECIMAL(M,D)</td><td style="text-align:left">M字节(D+2 , 如果M &lt; D)</td></tr><tr><td style="text-align:left">NUMERIC(M,D)</td><td style="text-align:left">M字节(D+2 , 如果M &lt; D)</td></tr></tbody></table><p><strong>日期和时间类型</strong></p><table><thead><tr><th style="text-align:left">列类型</th><th style="text-align:left">需要的存储量</th></tr></thead><tbody><tr><td style="text-align:left">DATE</td><td style="text-align:left">3 个字节</td></tr><tr><td style="text-align:left">DATETIME</td><td style="text-align:left">8 个字节</td></tr><tr><td style="text-align:left">TIMESTAMP</td><td style="text-align:left">4 个字节</td></tr><tr><td style="text-align:left">TIME</td><td style="text-align:left">3 个字节</td></tr><tr><td style="text-align:left">YEAR</td><td style="text-align:left">1 字节</td></tr></tbody></table><p><strong>串类型</strong></p><table><thead><tr><th style="text-align:left">列类型</th><th style="text-align:left">需要的存储量</th></tr></thead><tbody><tr><td style="text-align:left">CHAR(M)</td><td style="text-align:left">M字节，1 &lt;= M &lt;= 255</td></tr><tr><td style="text-align:left">VARCHAR(M)</td><td style="text-align:left">L+1 字节, 在此L &lt;= M和1 &lt;= M &lt;= 255</td></tr><tr><td style="text-align:left">TINYBLOB, TINYTEXT</td><td style="text-align:left">L+1 字节, 在此L&lt; 2 ^ 8</td></tr><tr><td style="text-align:left">BLOB, TEXT</td><td style="text-align:left">L+2 字节, 在此L&lt; 2 ^ 16</td></tr><tr><td style="text-align:left">MEDIUMBLOB, MEDIUMTEXT</td><td style="text-align:left">L+3 字节, 在此L&lt; 2 ^ 24</td></tr><tr><td style="text-align:left">LONGBLOB, LONGTEXT</td><td style="text-align:left">L+4 字节, 在此L&lt; 2 ^ 32</td></tr><tr><td style="text-align:left">ENUM(‘value1’,‘value2’,…)</td><td style="text-align:left">1 或 2 个字节, 取决于枚举值的数目(最大值65535）</td></tr><tr><td style="text-align:left">SET(‘value1’,‘value2’,…)</td><td style="text-align:left">1，2，3，4或8个字节, 取决于集合成员的数量(最多64个成员）</td></tr></tbody></table><h3 id="mysql中类型后面的数字含义"><a class="markdownIt-Anchor" href="#mysql中类型后面的数字含义"></a> <a href="https://www.itdaan.com/blog/2019/04/08/7762d501e9d5c7cc0316743eaaab6b54.html" target="_blank" rel="noopener">MySQL中类型后面的数字含义</a></h3><p>形式：类型(m)</p><ol><li>整数型的<strong>数值类型</strong>已经<strong>限制了取值范围</strong>，有符号整型和无符号整型都有，而M值并不代表可以存储的数值字符长度，它代表的是<strong>数据在显示时显示的最小长度</strong>，当存储的字符长度超过M值时，没有任何的影响，只要不超过数值类型限制的范围。当存储的字符长度小于M值时，<u>只有在设置了zerofill用0来填充，才能够看到效果，换句话就是说，没有zerofill，M值就是无用的</u>。</li><li>字符型如varchar(50) 可以储存50个字符，表示的是可变不定长的。</li></ol><h3 id="mysql默认字符集"><a class="markdownIt-Anchor" href="#mysql默认字符集"></a> mySQL默认字符集</h3><blockquote><p>MySQL对于字符集的指定可以细化到一个数据库，一张表，一列，应该用什么字符集。 但是，传统的程序在创建数据库和数据表时并没有使用那么复杂的配置，它们用的是默认的配置，那么，默认的配置从何而来呢？</p></blockquote><ol><li>编译MySQL 时，指定了一个默认的字符集，这个字符集是 latin1；</li><li>安装MySQL 时，可以在配置文件 (my.ini) 中指定一个默认的的字符集，如果没指定，这个值继承自编译时指定的；</li><li>启动mysqld 时，可以在命令行参数中指定一个默认的的字符集，如果没指定，这个值继承自配置文件中的配置,此时 character_set_server 被设定为这个默认的字符集；</li><li>当创建一个新的数据库时，除非明确指定，这个数据库的字符集被缺省设定为character_set_server；</li><li>当选定了一个数据库时，character_set_database被设定为这个数据库默认的字符集；</li><li>在这个数据库里创建一张表时，表默认的字符集被设定为 character_set_database，也就是这个数据库默认的字符集；</li><li>当在表内设置一栏时，除非明确指定，否则此栏缺省的字符集就是表默认的字符集；</li></ol><h3 id="最终createsql文件"><a class="markdownIt-Anchor" href="#最终createsql文件"></a> 最终create.sql文件</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">NAMES</span> utf8mb4;</span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">EXISTS</span>  <span class="string">`huaneng`</span> ;</span><br><span class="line"><span class="keyword">use</span> <span class="string">`huaneng`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for quotation_inone</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`quotation_inone`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`quotation_inone`</span>  (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`date`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`content`</span> LONGTEXT <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`proclamation_url`</span> <span class="built_in">VARCHAR</span>(<span class="number">512</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> (<span class="string">`proclamation_url`</span>),</span><br><span class="line"></span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span> AUTO_INCREMENT = <span class="number">1</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4 <span class="keyword">COLLATE</span> = utf8mb4_general_ci ROW_FORMAT = Dynamic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1 id="2022年3月20日-护士题目下载存word"><a class="markdownIt-Anchor" href="#2022年3月20日-护士题目下载存word"></a> 2022年3月20日-护士题目下载存Word</h1><h3 id="索引报错"><a class="markdownIt-Anchor" href="#索引报错"></a> 索引报错</h3><ul><li>MySQL 添加索引报错：<code>BLOB/TEXT column used in key specification without a key length</code><ol><li>当我们对一个名称为platform的字段，类型为 text 添加unique唯一性约束和索引约束时，会报错。 原因：MySQL只能将BLOB/TEXT类型字段设置索引数据的前N个字符，因此，只需要通过sql在增加索引时指定对应字段的长度即可，如：<br><code>ALTER TABLE hello_world ADD INDEX key1(platform(250), platform2(250), type);</code>, 其中，platform 和 platform2 就是 text 类型的数据<ul><li>more: <a href="https://www.cnblogs.com/wqbin/p/11903878.html" target="_blank" rel="noopener">https://www.cnblogs.com/wqbin/p/11903878.html</a></li></ul></li><li>根本原因： 错误发生的原因是因为MySQL只能将BLOB/TEXT类型字段设置索引为BLOB/TEXT数据的前N个字符，因此错误常常发生在字段被定义为TEXT/BLOB类型或者和TEXT/BLOB同质的数据类型，如TINYTEXT,MEDIUMTEXT,LONGTEXT ,TINYBLOB,MEDIUMBLOB 和LONGBLOB，并且当前操作是将这个字段设置成主键或者是索引的操作。在未指定TEXT/BLOB‘键长’的情况下，字段是变动的并且是动态的大小所以MySQL不能够保证字段的唯一性。因此当使用TEXT/BLOB类型字段做为索引时，N的值必须提供出来才可以让MySQL决定键长，但是MySQL不支持在TEXT/BLOB限制，TEXT(88)是不行的。<ul><li>解决方案是<strong>将unique限制和索引从TEXT/BLOB字段中移除</strong>，或者是<strong>设置另一个字段为主键</strong>，如果你不愿意这样做并且想在TEXT/BLOB上加限制，那么你可以尝试将这个字段更改为VARCHAR类型，同时给他一个限制长度，默认VARCHAR最多可以限定在255个字符，并且限制要在声明类型的右边指明，如VARCHAR(200)将会限制仅仅200个字符.(注: 但是mysql不支持对TEXT/BLOB长度的限制。)</li><li><a href="https://blog.csdn.net/u012069924/article/details/28858337" target="_blank" rel="noopener">https://blog.csdn.net/u012069924/article/details/28858337</a><br>▲. 在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度即可。Java 开发手册 33/44 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</li></ul></li></ol></li></ul><h3 id="数据库插入数据"><a class="markdownIt-Anchor" href="#数据库插入数据"></a> 数据库插入数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- \\表示一个\</span></span><br><span class="line"><span class="keyword">use</span> xian_nurse;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`question`</span> (<span class="string">`path`</span>) <span class="keyword">VALUES</span> (<span class="string">'书籍\\C-《传染病护理学习指导与习题集》-选择题'</span>), (<span class="string">'书籍\\C-《传染病护理技术学习指导与习题集》-选择题'</span>), (<span class="string">'书籍\\C-《传染病护理技术学习指导与习题集》-题干题'</span>), (<span class="string">'书籍\\C-《成人护理学学习指导与习题集-人民卫生出版社》-选择题'</span>), (<span class="string">'书籍\\C-《成人护理学学习指导与习题集-人民卫生出版社》-题干题'</span>), (<span class="string">'书籍\\E -《儿科护理学实践与学习指导（十三五）》—选择题'</span>), (<span class="string">'书籍\\E -《儿科护理学实践与学习指导（十三五）》—题干题'</span>);</span><br></pre></td></tr></table></figure><h2 id="操作word"><a class="markdownIt-Anchor" href="#操作word"></a> 操作word</h2><blockquote><p>使用<code>python-docx</code>: <code>python -m pip install python-docx</code>， <a href="https://python-docx.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://python-docx.readthedocs.io/en/latest/</a></p></blockquote><ol><li>添加1-9级标题</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新的docx文件</span></span><br><span class="line">document = Document()</span><br><span class="line">document.add_heading(<span class="string">'1级标题'</span>, <span class="number">1</span>)  <span class="comment"># 添加1级标题</span></span><br><span class="line">document.add_heading(<span class="string">'2级标题'</span>, <span class="number">2</span>)  <span class="comment"># 添加2级标题</span></span><br><span class="line">document.add_heading(<span class="string">'3级标题'</span>, <span class="number">3</span>)  <span class="comment"># 添加3级标题</span></span><br><span class="line">document.add_heading(<span class="string">'4级标题'</span>, <span class="number">4</span>)  <span class="comment"># 添加4级标题</span></span><br><span class="line">document.add_heading(<span class="string">'5级标题'</span>, <span class="number">5</span>)  <span class="comment"># 添加5级标题</span></span><br><span class="line">document.add_heading(<span class="string">'6级标题'</span>, <span class="number">6</span>)  <span class="comment"># 添加6级标题</span></span><br><span class="line">document.add_heading(<span class="string">'7级标题'</span>, <span class="number">7</span>)  <span class="comment"># 添加7级标题</span></span><br><span class="line">document.add_heading(<span class="string">'8级标题'</span>, <span class="number">8</span>)  <span class="comment"># 添加8级标题</span></span><br><span class="line">document.add_heading(<span class="string">'9级标题'</span>, <span class="number">9</span>)  <span class="comment"># 添加9级标题</span></span><br><span class="line">document.save(<span class="string">'&#123;&#125;.docx'</span>.format(datetime.now().strftime(<span class="string">'%Y%m%d%H%M%S'</span>)))</span><br></pre></td></tr></table></figure><ol start="2"><li>添加段落</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新的docx文件</span></span><br><span class="line">document = Document()</span><br><span class="line">paragraph = <span class="string">"""这是一个段落</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">paragraph2 = <span class="string">"""这是一个新的段落"""</span></span><br><span class="line">paragraph3 = <span class="string">"""这是一个新的段落。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">document.add_paragraph(paragraph)</span><br><span class="line">document.add_paragraph(paragraph2)</span><br><span class="line">document.add_paragraph(paragraph3)</span><br><span class="line">document.save(<span class="string">'&#123;&#125;.docx'</span>.format(datetime.now().strftime(<span class="string">'%Y%m%d%H%M%S'</span>)))</span><br></pre></td></tr></table></figure><ol start="3"><li>设置字体大小和样式</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"><span class="comment"># 创建新的docx文件</span></span><br><span class="line"><span class="keyword">from</span> docx.shared <span class="keyword">import</span> Pt</span><br><span class="line"></span><br><span class="line">document = Document()</span><br><span class="line">document.add_paragraph(<span class="string">"这是一个段落"</span>)  <span class="comment"># 添加段落</span></span><br><span class="line">paragraph = document.add_paragraph(<span class="string">"这是一个段落,"</span>)  <span class="comment"># 添加段落</span></span><br><span class="line">run = paragraph.add_run(<span class="string">'设置了字体的段落'</span>)  <span class="comment"># 在同一段添加内容, 即为了操作段落或单词的子字符串. 概念上讲，您需要为段落/文本的run每个部分创建一个实例。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Append a run to this paragraph containing *text* and having character</span></span><br><span class="line"><span class="string">style identified by style ID *style*. *text* can contain tab</span></span><br><span class="line"><span class="string">(``\\t``) characters, which are converted to the appropriate XML form</span></span><br><span class="line"><span class="string">for a tab. *text* can also include newline (``\\n``) or carriage</span></span><br><span class="line"><span class="string">return (``\\r``) characters, each of which is converted to a line</span></span><br><span class="line"><span class="string">break.</span></span><br><span class="line"><span class="string">大概意思就是追加一个段落, 包含text, 且设置了格式, 我感觉是这样</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">run.font.name = <span class="string">u'宋体'</span>  <span class="comment"># 设置字体</span></span><br><span class="line">run.font.size = Pt(<span class="number">20</span>)  <span class="comment"># 设置字号</span></span><br><span class="line"><span class="comment"># run.font.color.rgb = RGBColor(255, 0, 0)# 设置红色</span></span><br><span class="line">run.font.underline = <span class="keyword">True</span><span class="comment"># 设置下划线</span></span><br><span class="line"></span><br><span class="line">run1 = paragraph.add_run(<span class="string">'\t粗体'</span>)</span><br><span class="line">run1.bold = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">run2 = paragraph.add_run(<span class="string">'\t斜体'</span>)</span><br><span class="line">run2.italic = <span class="keyword">True</span></span><br><span class="line"> <span class="comment">#图片居中设置</span></span><br><span class="line">paragraph.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Doc = Document() </span><br><span class="line">Doc.styles[<span class="string">'Normal'</span>].font.name = <span class="string">u'宋体'</span></span><br><span class="line">Doc.styles[<span class="string">'Normal'</span>]._element.rPr.rFonts.set(qn(<span class="string">'w:eastAsia'</span>), <span class="string">u'宋体'</span>)</span><br><span class="line">Doc.styles[<span class="string">'Normal'</span>].font.size = Pt(<span class="number">10.5</span>)</span><br><span class="line">Doc.styles[<span class="string">'Normal'</span>].font.color.rgb = RGBColor(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">Head = Doc.add_heading(<span class="string">""</span>,level=<span class="number">1</span>)<span class="comment"># 这里不填标题内容</span></span><br><span class="line">run  = Head.add_run(<span class="string">"刚来csdn，这就是博客么，I了"</span>)</span><br><span class="line">run.font.name=<span class="string">u'Cambria'</span></span><br><span class="line">run.font.color.rgb = RGBColor(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">run._element.rPr.rFonts.set(qn(<span class="string">'w:eastAsia'</span>), <span class="string">u'Cambria'</span>)</span><br><span class="line">Doc.add_paragraph(<span class="string">"Python "</span>)</span><br><span class="line">Doc.add_paragraph(<span class="string">"Python 对word进行操作"</span>)</span><br><span class="line">Doc.save(<span class="string">"Python_word.docx"</span>)</span><br></pre></td></tr></table></figure><p>from : <a href="https://www.pythonheidong.com/blog/article/692569/99875f167810b45f17e8/" target="_blank" rel="noopener">https://www.pythonheidong.com/blog/article/692569/99875f167810b45f17e8/</a></p><ol start="4"><li>有序(无序)列表和引用</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加引用</span></span><br><span class="line">document.add_paragraph(<span class="string">'123'</span>, style=<span class="string">'Intense Quote'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加有序列表</span></span><br><span class="line">document.add_paragraph(<span class="string">u'有序列表元素1'</span>, style=<span class="string">'List Number'</span>)</span><br><span class="line">document.add_paragraph(<span class="string">u'有序列别元素2'</span>, style=<span class="string">'List Number'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加无序列表</span></span><br><span class="line">document.add_paragraph(<span class="string">u'无序列表元素1'</span>, style=<span class="string">'List Bullet'</span>)</span><br><span class="line">document.add_paragraph(<span class="string">u'无序列表元素2'</span>, style=<span class="string">'List Bullet'</span>)</span><br></pre></td></tr></table></figure><ol start="5"><li>表格和分页</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加图片（此处使用相对位置）</span></span><br><span class="line"><span class="comment"># document.add_picture('jdb.jpg', width=Inches(1.25))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加表格</span></span><br><span class="line">table = document.add_table(rows=<span class="number">3</span>, cols=<span class="number">3</span>)  <span class="comment"># 3行3列</span></span><br><span class="line">hdr_cells1 = table.rows[<span class="number">0</span>].cells  <span class="comment"># 第一行</span></span><br><span class="line">hdr_cells1[<span class="number">0</span>].text = <span class="string">"第一行,第一列"</span></span><br><span class="line">hdr_cells1[<span class="number">1</span>].text = <span class="string">"第一行,第二列"</span></span><br><span class="line">hdr_cells1[<span class="number">2</span>].text = <span class="string">"第一行,第三列"</span></span><br><span class="line"></span><br><span class="line">hdr_cells2 = table.rows[<span class="number">1</span>].cells  <span class="comment"># 第二行</span></span><br><span class="line">hdr_cells2[<span class="number">0</span>].text = <span class="string">"第二行,第一列"</span></span><br><span class="line">hdr_cells2[<span class="number">1</span>].text = <span class="string">"第二行,第二列"</span></span><br><span class="line">hdr_cells2[<span class="number">2</span>].text = <span class="string">"第二行,第三列"</span></span><br><span class="line"></span><br><span class="line">hdr_cells3 = table.rows[<span class="number">2</span>].cells  <span class="comment"># 第三行</span></span><br><span class="line">hdr_cells3[<span class="number">0</span>].text = <span class="string">"第三行,第一列"</span></span><br><span class="line">hdr_cells3[<span class="number">1</span>].text = <span class="string">"第三行,第二列"</span></span><br><span class="line">hdr_cells3[<span class="number">2</span>].text = <span class="string">"第三行,第三列"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加分页</span></span><br><span class="line">document.add_page_break()</span><br></pre></td></tr></table></figure><h3 id="提取文字"><a class="markdownIt-Anchor" href="#提取文字"></a> 提取文字</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"></span><br><span class="line">path = <span class="string">'/media/bobo/自动化办公/wordOperation/wordDemo/test2.docx'</span></span><br><span class="line"></span><br><span class="line">doc = Document(path)</span><br><span class="line">print(doc.paragraphs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出的是列表，列表中一共有4份内容</span></span><br><span class="line"><span class="comment"># [&lt;docx.text.paragraph.Paragraph object at 0x7fca95f0aba8&gt;,</span></span><br><span class="line"><span class="comment"># &lt;docx.text.paragraph.Paragraph object at 0x7fca95f0abe0&gt;,</span></span><br><span class="line"><span class="comment"># &lt;docx.text.paragraph.Paragraph object at 0x7fca95f0ab70&gt;, </span></span><br><span class="line"><span class="comment">#&lt;docx.text.paragraph.Paragraph object at 0x7fca95f0ac50&gt;,]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> paragraph <span class="keyword">in</span> doc.paragraphs:</span><br><span class="line">print(paragraph.text)</span><br></pre></td></tr></table></figure><p>from :</p><ul><li><a href="https://www.cnblogs.com/rainbow-tan/p/14981998.html" target="_blank" rel="noopener">https://www.cnblogs.com/rainbow-tan/p/14981998.html</a></li><li><a href="https://www.cnblogs.com/wenshi-jj/p/15388808.html" target="_blank" rel="noopener">https://www.cnblogs.com/wenshi-jj/p/15388808.html</a></li><li><a href="https://www.cnblogs.com/rencm/p/6285304.html" target="_blank" rel="noopener">https://www.cnblogs.com/rencm/p/6285304.html</a></li><li><a href="https://blog.csdn.net/weixin_44576802/article/details/86552550%E2%80%94%E2%80%94%E9%A2%9C%E8%89%B2" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44576802/article/details/86552550——颜色</a></li><li>参考：<a href="https://www.cnblogs.com/wenshi-jj/p/15388808.html%E2%80%94%E2%80%94%E9%A1%B5%E8%BE%B9%E8%B7%9D%E3%80%81%E9%A1%B5%E7%9C%89%E5%92%8C%E9%A1%B5%E8%84%9A%E3%80%81%E5%88%86%E6%A0%8F" target="_blank" rel="noopener">https://www.cnblogs.com/wenshi-jj/p/15388808.html——页边距、页眉和页脚、分栏</a></li></ul><h1 id="共同点处理"><a class="markdownIt-Anchor" href="#共同点处理"></a> 共同点处理</h1><h2 id="文件保存"><a class="markdownIt-Anchor" href="#文件保存"></a> 文件保存</h2><blockquote><p>由于文件夹、文件名不允许有<code>/\:*?|&lt;&gt;&quot;</code>，因此需要保存时如果出现这些字符得特别处理。</p></blockquote><ol><li>项目一：<code>xxxx阻垢剂\反渗透阻垢剂\25KG询价书询价公告\zxc.doc</code> ==&gt; <code>xxx阻垢剂、反渗透阻垢剂、25KG询价书询价公告\zxc.doc</code>，存储在<code>attaches\xxx阻垢剂、反渗透阻垢剂、25KG询价书询价公告\zxc.doc</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">format_name</span><span class="params">(name: str)</span> -&gt; [bool, str]:</span></span><br><span class="line">       <span class="string">"""</span></span><br><span class="line"><span class="string">       文件和文件夹名规范化</span></span><br><span class="line"><span class="string">       :param name:</span></span><br><span class="line"><span class="string">       :return:</span></span><br><span class="line"><span class="string">       """</span></span><br><span class="line">   invalid_char = [<span class="string">"/"</span>, <span class="string">"\\"</span>, <span class="string">":"</span>, <span class="string">"*"</span>, <span class="string">"?"</span>, <span class="string">"|"</span>, <span class="string">"&lt;"</span>, <span class="string">"&gt;"</span>, <span class="string">"\""</span>]</span><br><span class="line">       rename = name</span><br><span class="line">       valid = <span class="keyword">True</span></span><br><span class="line">       <span class="keyword">for</span> ch <span class="keyword">in</span> invalid_char:</span><br><span class="line">           <span class="keyword">if</span> ch <span class="keyword">in</span> rename:</span><br><span class="line">               <span class="keyword">if</span> ch == <span class="string">"?"</span>:</span><br><span class="line">                   rename = rename.replace(<span class="string">"?"</span>, <span class="string">"？"</span>)</span><br><span class="line">               <span class="keyword">elif</span> ch == <span class="string">"&lt;"</span>:</span><br><span class="line">                   rename = rename.replace(<span class="string">"&lt;"</span>, <span class="string">"["</span>)</span><br><span class="line">               <span class="keyword">elif</span> ch == <span class="string">"&gt;"</span>:</span><br><span class="line">                   rename = rename.replace(<span class="string">"&gt;"</span>, <span class="string">"]"</span>)</span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                   rename = rename.replace(ch, <span class="string">"、"</span>)</span><br><span class="line">               valid = <span class="keyword">False</span></span><br><span class="line">       <span class="keyword">return</span> valid, rename</span><br></pre></td></tr></table></figure><ol start="2"><li>项目二：<code>'.\\docx/专科题库\\儿科\\[书籍]\\S-《实用临床护理三基-&quot;应知应会&quot;》—名词解释、简答(规02）\\something.docx'</code>===&gt;<code>'.\\docx/专科题库\\儿科\\[书籍]\\S-《实用临床护理三基-'应知应会'》—名词解释、简答(规02）\\something.docx'</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_file_path</span><span class="params">(path: str)</span> -&gt; [bool, str]:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    文件和文件夹名规范化</span></span><br><span class="line"><span class="string">    :param name:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    invalid_char = [<span class="string">"/"</span>, <span class="string">"\\"</span>, <span class="string">":"</span>, <span class="string">"*"</span>, <span class="string">"?"</span>, <span class="string">"|"</span>, <span class="string">"&lt;"</span>, <span class="string">"&gt;"</span>, <span class="string">"\""</span>]</span><br><span class="line">    rename = path</span><br><span class="line">    valid = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> invalid_char:</span><br><span class="line">        <span class="keyword">if</span> ch <span class="keyword">in</span> rename:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">"?"</span>:</span><br><span class="line">                rename = rename.replace(<span class="string">"?"</span>, <span class="string">"？"</span>)</span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">"&lt;"</span>:</span><br><span class="line">                rename = rename.replace(<span class="string">"&lt;"</span>, <span class="string">"["</span>)</span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">"&gt;"</span>:</span><br><span class="line">                rename = rename.replace(<span class="string">"&gt;"</span>, <span class="string">"]"</span>)</span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">'"'</span>:</span><br><span class="line">                rename = rename.replace(<span class="string">"\""</span>, <span class="string">"\'"</span>)</span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">"\\"</span> <span class="keyword">or</span> ch == <span class="string">"/"</span>:</span><br><span class="line">                <span class="comment"># 注意跟 上一个的区别， 由于上一个项目中的/和\都是分隔符，而不是真实的分隔目录，因此需要替换，但本项目是真实路径分隔符，所以不需要转换</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rename = rename.replace(ch, <span class="string">"、"</span>)</span><br><span class="line">            valid = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> valid, rename</span><br></pre></td></tr></table></figure><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><h3 id="lxml库的使用"><a class="markdownIt-Anchor" href="#lxml库的使用"></a> lxml库的使用</h3><ul><li><p>提取Element中最近标签中的文本(不包含标签本身): <code>ele.xpath('//*[@id=&quot;xxx&quot;]/text()')</code></p></li><li><p>提取Element中所有标签(标签嵌套)中的文本(不包含标签本身): <code>ele.xpath('//*[@id=&quot;xxx&quot;]/string(.)')</code></p><ul><li>注：跟<code>//text()</code>区别在于，<code>string(.)</code>的结果为合并后的str，<code>//text()</code>为未合并的list</li></ul></li><li><p>提取Element中所有内容(标签本身): <code>etree.tostring(ele, method=&quot;html&quot;)</code></p></li><li><p>修改Element某一属性:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendixs = html_content.xpath(<span class="string">'/html/body/div[4]/div/div[4]/div/div/div[1]/div[4]/p/a'</span>)</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> appendixs:</span><br><span class="line">    href = a.xpath(<span class="string">"@href"</span>)[<span class="number">0</span>]</span><br><span class="line">    save_path = self.download_file(ReUtil.extra_announcement_id(detail_article_url), href, title)</span><br><span class="line">    <span class="comment"># html中会对\进行转义</span></span><br><span class="line">    a.attrib[<span class="string">"href"</span>] = save_path</span><br></pre></td></tr></table></figure><p>注: 修改子element的某属性后，root节点tostring的结果中element也会被修改。(root抱有element的引用)</p></li><li><p>Element的XML标记名通过对象的属性访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = &apos;&lt;a href=&quot;http://baidu.com&quot;&gt;hh&lt;span&gt;gg&lt;/span&gt;&lt;/a&gt;&apos;</span><br><span class="line">res = &#123;_Element: 1&#125; &lt;Element html at 0x1de3a6b9800&gt;</span><br><span class="line">     attrib = &#123;_Attrib: 0&#125; &#123;&#125;</span><br><span class="line">     base = &#123;NoneType&#125; None</span><br><span class="line">     nsmap = &#123;dict: 0&#125; &#123;&#125;</span><br><span class="line">     prefix = &#123;NoneType&#125; None</span><br><span class="line">     sourceline = &#123;int&#125; 1</span><br><span class="line">     tag = &#123;str&#125; &apos;html&apos;</span><br><span class="line">     tail = &#123;NoneType&#125; None</span><br><span class="line">     text = &#123;NoneType&#125; None</span><br></pre></td></tr></table></figure></li><li><p>Element被组织在XML树结构中。增加子Element并指定它们的父Element，使用append方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 法一</span></span><br><span class="line">root = etree.Element(<span class="string">"root"</span>)</span><br><span class="line">root.append(etree.Element(<span class="string">"child1"</span>))</span><br><span class="line"><span class="comment"># 法二</span></span><br><span class="line">childNode = etree.SubElement(root, <span class="string">"child"</span>)</span><br></pre></td></tr></table></figure></li><li><p>删除Element下某一节点内容，与添加相同，也有实例方法和工厂方法两种</p><ul><li><p><code>parentnode.remove(node)</code></p></li><li><p><code>etree.strip_elements(html, 'element_name', with_tag=True/False)</code></p></li></ul></li></ul><h3 id="timeit模块使用"><a class="markdownIt-Anchor" href="#timeit模块使用"></a> <code>timeit</code>模块使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spider = HuaNengSpider(ifend=<span class="string">"in"</span>)</span><br><span class="line"><span class="comment"># 记得setup导入 </span></span><br><span class="line">run_time = timeit.timeit(<span class="string">"spider.run_parallelly()"</span>, <span class="string">"from __main__ import spider"</span>, number=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 输出的单位为s </span></span><br><span class="line">print(<span class="string">"耗时: &#123;&#125;s"</span>.format(run_time))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run_time = timeit.timeit(<span class="string">'HuaNengSpider(ifend="notin", is_in_one=True).run_with_concurrent()'</span>,</span><br><span class="line">                         <span class="string">"from __main__ import HuaNengSpider"</span>, number=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="python中操作sqlalchemysqlalchemy中文技术文档"><a class="markdownIt-Anchor" href="#python中操作sqlalchemysqlalchemy中文技术文档"></a> Python中操作SQLAlchemy,SQLAlchemy中文技术文档</h3><p>参考：<a href="https://www.jianshu.com/p/0ad18fdd7eed%E3%80%81" target="_blank" rel="noopener">https://www.jianshu.com/p/0ad18fdd7eed、</a><a href="https://www.cnblogs.com/yc-c/p/9627968.html" target="_blank" rel="noopener">python3 SQLAlchemy模块使用</a></p><h3 id="argumentparser使用"><a class="markdownIt-Anchor" href="#argumentparser使用"></a> <code>ArgumentParser</code>使用</h3><ul><li><p><code>parser.add_argument(&quot;-o&quot;, &quot;--is_in_one&quot;, action=&quot;store_true&quot;, help=&quot;数据存放在一张表中&quot;)</code>, 其中action的<code>store_true</code>表示，如果出现–is_in_one(action)则设置未true, 所以默认为False</p><ul><li>参数设置为True、False的最好不使用choice参数：因为</li><li><code>parser.add_argument(&quot;-o&quot;, &quot;--is_in_one&quot;, choices=[True, False], help=&quot;数据存放在一张表中&quot;)</code>, choice中为True、False时， 可以选择不填，此时is_in_one为None， 如果必须要这两个则选一个则加上<code>required=True</code>选项</li><li>加上required效果===&gt;<code>爬虫脚本: error: argument -o/--is_in_one: invalid choice: 'q' (choose from True, False)</code>， 但是如果输入True同样会报错: 爬虫脚本: error: argument -o/–is_in_one: invalid choice: ‘True’ (choose from True, False)</li></ul><p>所以只有<code>choices=[&quot;True&quot;, &quot;False&quot;]</code>才能生效， 好在的是Python中对true判断比较宽容，下面三种都可以，因此使得choice传str类型的True也可以成功判定，即能实现相同效果，但是还是存在些歧义的，得谨慎使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"true"</span></span><br><span class="line">b = <span class="keyword">True</span></span><br><span class="line">c = <span class="string">"True"</span></span><br><span class="line"><span class="keyword">if</span> a:</span><br><span class="line">    print(<span class="string">"a yes"</span>)</span><br><span class="line"><span class="keyword">if</span> b:</span><br><span class="line">    print(<span class="string">"b yes"</span>)</span><br><span class="line"><span class="keyword">if</span> c:</span><br><span class="line">    print(<span class="string">"c yes"</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="其他sql文件"><a class="markdownIt-Anchor" href="#其他sql文件"></a> 其他SQL文件</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`auto_bilibili`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`userid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建的任务名'</span>,</span><br><span class="line">  <span class="string">`sessdata`</span> longtext <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`bili_jct`</span> longtext <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`dedeuserid`</span> longtext <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`taskIntervalTime`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'10'</span> <span class="keyword">COMMENT</span> <span class="string">'任务之间的执行间隔'</span>,</span><br><span class="line">  <span class="string">`numberOfCoins`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'5'</span> <span class="keyword">COMMENT</span> <span class="string">'每日投币数量'</span>,</span><br><span class="line">  <span class="string">`reserveCoins`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'50'</span> <span class="keyword">COMMENT</span> <span class="string">'预留的硬币数'</span>,</span><br><span class="line">  <span class="string">`selectLike`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'投币时是否点赞，默认 0, 0：否 1：是'</span>,</span><br><span class="line">  <span class="string">`monthEndAutoCharge`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'true'</span> <span class="keyword">COMMENT</span> <span class="string">'年度大会员月底是否用 B 币券给自己充电，默认 true，即充电对象是你本人。'</span>,</span><br><span class="line">  <span class="string">`giveGift`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'true'</span> <span class="keyword">COMMENT</span> <span class="string">'直播送出即将过期的礼物，默认开启'</span>,</span><br><span class="line">  <span class="string">`upLive`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'直播送出即将过期的礼物，指定 up 主，为 0 时则随随机选取一个 up 主'</span>,</span><br><span class="line">  <span class="string">`chargeForLove`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'给指定 up 主充电，值为 0 或者充电对象的 uid，默认为 0，即给自己充电'</span>,</span><br><span class="line">  <span class="string">`devicePlatform`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'ios'</span> <span class="keyword">COMMENT</span> <span class="string">'手机端漫画签到时的平台，建议选择你设备的平台 ，默认 ios'</span>,</span><br><span class="line">  <span class="string">`coinAddPriority`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'0：优先给热榜视频投币，1：优先给关注的 up 投币'</span>,</span><br><span class="line">  <span class="string">`userAgent`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36 Edg/86.0.622.69'</span> <span class="keyword">COMMENT</span> <span class="string">'浏览器 UA'</span>,</span><br><span class="line">  <span class="string">`skipDailyTask`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'false'</span> <span class="keyword">COMMENT</span> <span class="string">'是否跳过每日任务'</span>,</span><br><span class="line">  <span class="string">`webhook`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'推送地址'</span>,</span><br><span class="line">  <span class="string">`enddate`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`match_enable`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'false'</span> <span class="keyword">COMMENT</span> <span class="string">'预测是否开启'</span>,</span><br><span class="line">  <span class="string">`match_predictNumberOfCoins`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'10'</span> <span class="keyword">COMMENT</span> <span class="string">'单次预测投注硬币'</span>,</span><br><span class="line">  <span class="string">`match_minimumNumberOfCoins`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'200'</span> <span class="keyword">COMMENT</span> <span class="string">'预测保留硬币'</span>,</span><br><span class="line">  <span class="string">`match_showHandModel`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'false'</span> <span class="keyword">COMMENT</span> <span class="string">'押注形式'</span>,</span><br><span class="line">  <span class="string">`other`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`userid`</span> (<span class="string">`userid`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">7</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 ROW_FORMAT=DYNAMIC</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2022年3月20日公告存网站页面到数据库&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#2022年3月20日公告存网站页面到数据库&quot;&gt;&lt;/a&gt; 2022年3月20日——公告存网站页面到数据库&lt;/h1&gt;
&lt;h2 id=&quot;文件存储&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="爬虫" scheme="https://nymrli.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>深入学习使用Spring</title>
    <link href="https://nymrli.top/2022/02/27/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8Spring/"/>
    <id>https://nymrli.top/2022/02/27/深入学习使用Spring/</id>
    <published>2022-02-27T05:52:08.000Z</published>
    <updated>2022-02-27T05:54:23.566Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>From : <a href="https://www.bilibili.com/video/BV1fr4y1Y7UH?p=6" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1fr4y1Y7UH?p=6</a></p></blockquote><h2 id="创建bean的方式"><a class="markdownIt-Anchor" href="#创建bean的方式"></a> 创建bean的方式：</h2><h3 id="声明式"><a class="markdownIt-Anchor" href="#声明式"></a> 声明式</h3><h4 id="beanbean"><a class="markdownIt-Anchor" href="#beanbean"></a> <code>&lt;bean&gt;&lt;/bean&gt;</code></h4><ul><li><p><code>&lt;bean&gt;&lt;/bean&gt;</code>： 通过xml来配置bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"p1"</span> <span class="attr">class</span>=<span class="string">"top.nymrli.tryboot.po.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testPerson()</span><br><span class="line">    &#123;</span><br><span class="line"> ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");</span><br><span class="line"></span><br><span class="line">        User user = annotationConfigApplicationContext.getBean("p1", User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="bean"><a class="markdownIt-Anchor" href="#bean"></a> <code>@Bean</code></h4><ul><li><p><code>@Bean</code>: 通过注解来标注SpringBean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"name"</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        ctx.register(Config.class);</span><br><span class="line">        <span class="comment">// 或者 AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(Config.class);</span></span><br><span class="line"></span><br><span class="line">        ctx.refresh();</span><br><span class="line"></span><br><span class="line">        User user = ctx.getBean(<span class="string">"user"</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(Config.class);</code>与<code>ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code>一样，都是指定bean的配置路径后解析，获得bean的配置。</p></li></ul><h4 id="component"><a class="markdownIt-Anchor" href="#component"></a> <code>@Component</code></h4><ul><li><p><code>@Component</code>: 通过标注来创建一个组件SpringBean对象，如下的User。 ==&gt; 等价于<code>ctx.registerBean(User.class)</code>，registerBean方法的实现最终也是调用了registerBeanDefinition</p><p>而Config不是一个bean，他的作用跟applicationContext.xml一样，他是存放bean定义路径的一个配置文件，在这里是通过ComponentScan让Spring能够找到top.nymrli.tryboot.po下的所有Bean并解析成SpringBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"top.nymrli.tryboot.po"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Component</span><span class="comment">// ==&gt; beanName为user, 类名小写</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(Config.class);</span><br><span class="line"></span><br><span class="line">    User user = ctx.getBean(User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会自动调用User的无参构造方式来创建JavaBean， 因此得到的User是<code>User(name=null, age=0)</code></p></li></ul><p>▲.上述三种创建方式本质上都是创建了BeanDefinition，只不过Spring进行了封装，因此使用起来比较简单直观</p><h4 id="import"><a class="markdownIt-Anchor" href="#import"></a> @Import</h4><blockquote><p>spring4.2之后<code>@Import</code>注解可以实例化普通类的bean实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Import</span>(Role.class)<span class="comment">// @Import(&#123;Role.class, User.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Role role;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(role);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring在创建MyConfig的时候，会根据@Import将Role也实例化成一个Bean</p><h3 id="编程式"><a class="markdownIt-Anchor" href="#编程式"></a> 编程式</h3><h4 id="beandefinition"><a class="markdownIt-Anchor" href="#beandefinition"></a> BeanDefinition</h4><blockquote><p>通过创建并配置 BeanDefinition 来创建一个Bean</p><p>Q: 什么是BeanDefinition?</p><p>A: BeanDefinition表示Bean的定义信息， Spring会根据BeanDefinition来创建Bean对象。BeanDefinition有很多的属性用来描述Bean， BeanDefinition是Spring中非常核心的概念。</p><ul><li>beanClass: 表示Bean对象的类类型， Spring在创建Bean的过程中根据此属性来判断实例化对象具体的类类型</li><li>scope：作用域，[singleton、prototype]，单例或者原型bean</li><li>isLazy：是否需要懒加载，原型Bean的懒加载不奏效。懒加载的单例bean，会在第一次getBean的时候生成该bean，非懒加载的单例bean，则会在Spring.启动过程中直接生成好。</li><li>dependsOn：表示一个bean在创建之前所依颗的其他bean，在一个bean创建之前，它所依赖的这些bean得先全部创建好。</li><li>primary：表示一个bean是主bean，在Spring中一个类型可以有多个bean对象，在进行依赖注入时，如果根据类型找到了多个b©an，此时会判断这些bean中是否存在一个主bean，如果存在，则直接将这个bean注入给属性。</li><li>initMethodName： 表示一个bean的初始化方法，一个bean的生命周期过程中有一个步骤叫初始化，Spring会在这个步骤中去调用bean的初始化方法。初始化逻辑由程序员自己控制，使得程序员可以自定义逻辑对bean进行加工。</li></ul><p>通过<code>&lt;bean&gt;&lt;/bean&gt;</code>、<code>@Bean</code>、<code>@Component</code>标注的类都会解析为BeanDefinition，供Spring创建（实例化）具体的Bean。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(Config.class);</span><br><span class="line">    AbstractBeanDefinition bd = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">    bd.setBeanClass(User.class);</span><br><span class="line">    <span class="comment">// 将BeanDefinition注册到上下文中</span></span><br><span class="line">    ctx.registerBeanDefinition(<span class="string">"user"</span>, bd);</span><br><span class="line">    <span class="comment">// 获得Bean对象</span></span><br><span class="line">    User user = (User)ctx.getBean(<span class="string">"user"</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="factorybean"><a class="markdownIt-Anchor" href="#factorybean"></a> FactoryBean</h4><blockquote><p>FactoryBean是Spring.所提供的一种较灵活的创建Bean的方式，可以通过实现FactoryBean：接口中的getObject()方法来返回一个对象，这个对象就是最终的Bean对象。</p></blockquote><p>FactoryBean接口中的方法</p><ul><li>Object getObject()：返回的是Bean对象</li><li>boolean isSingleton()：返回的是否是单例Bean对象</li><li>Class getObjectType()：返回的是Bean对象的类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"zhouyu"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhouyuFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"cl"</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，实际上对应了两个Bean对象：<br>1、beanName为&quot;zhouyu’，bean对象为getObject方法所返回的User对象。=&gt;<code>applicationcontext.getBean(name：&quot;zhouyu&quot;，ZhouyuFactory.class);</code><br>2、beanName为&quot;&amp;zhouyu’，bean对象为ZhouyuFactoryBean类的实例对象。=&gt;<code>applicationcontext.getBean(name：&quot;&amp;zhouyu&quot;，ZhouyuFactoryBean.class);</code></p><p>与BeanFactory的区别：</p><ul><li>FactoryBean对象本身也是一个Bean，同时它相当于一个小型工厂，可以生产出<strong>另外</strong>的Bean。==》指定类型的Bean对象<ul><li>FactoryBean机制被广泛的应用在Spring内部和Spring-与第三方框架或组件的整合过程中。</li></ul></li><li>BeanFactory是一个Spring容器，是一个大型工厂，它可以生产出<strong>各种各样</strong>的Beano</li></ul><h4 id="supplier"><a class="markdownIt-Anchor" href="#supplier"></a> Supplier</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(Config.class);</span><br><span class="line">        ctx.registerBean(User.class, <span class="keyword">new</span> Supplier&lt;User&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                User userx = <span class="keyword">new</span> User();</span><br><span class="line">                userx.setAge(<span class="number">222</span>);</span><br><span class="line">                userx.setName(<span class="string">"supplier"</span>);</span><br><span class="line">                <span class="keyword">return</span> userx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        User user = (User)ctx.getBean(<span class="string">"user"</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="beanfactory"><a class="markdownIt-Anchor" href="#beanfactory"></a> BeanFactory</h2><p>BeanFactory是一种“Spring容器”， BeanFactory翻译过来就是Bean工厂，顾名思义，它可以用来创建Bean、获取Bean。</p><p>概念区分：</p><ul><li>BeanFactory将利用BeanDefinition：来生成Bean对象</li><li>BeanDefinition相当于BeanFactory的原材料</li><li>Bean对象就相当于BeanFactory）所生产出来的产品</li></ul><p>BeanFactory的核心子接口和实现类：</p><ul><li>ListableBeanFactory</li><li>ConfigurableBeanFactory</li><li>AutowireCapableBeanFactory</li><li>AbstractBeanFactory</li><li>DefaultListableBeanFactory</li></ul><p>···</p><h2 id="bean生命周期"><a class="markdownIt-Anchor" href="#bean生命周期"></a> Bean生命周期</h2><blockquote><p>Bean生命周期描述的是Spring中一个Bean创建过程和销毁过程中所经历的步骤，其中Bean创建过程是重点。程序员可以利用Bean生命周期机制对Bean进行自定义加工。</p></blockquote><ul><li>Bean定义：通过xml或者编写类的形式来创建BeanDefinition</li><li>构造方法推断：从bean的多个构造方法中选出一个构造方法</li><li>实例化：通过构造方法反射获得对象，在Spring中可以通过BeanPostProcessor机制对实例化进行干预</li><li>属性填充(自动注入、依赖注入)：给属性进行自动填充，比如@Value，@AutoWired</li><li>初始化：在一个对象的属性填充之后，Spring提供了初始化机制，让程序员可以对其他属性进行赋值、校验等自定义加工(利用InitializingBean接口)</li><li>初始化后：Aop、生成代理对象。常说的Aop机制就是在这个步骤中通过BeanPostProcessor机制实现的，这步之后获得的对象才是真正的Bean对象</li></ul><p>创建过程：</p><p><img src="/2022/02/27/深入学习使用Spring/E:%5Chexo%5Csource_posts%5C%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8Spring%5Cbean%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.jpg" alt="bean创建过程"></p><p>生命周期图：</p><p><img src="/2022/02/27/深入学习使用Spring/E:%5Chexo%5Csource_posts%5C%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8Spring%5Cbean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1.jpg" alt="bean生命周期-1"></p><h2 id="属性填充注解autowired-resource-value"><a class="markdownIt-Anchor" href="#属性填充注解autowired-resource-value"></a> 属性填充注解：@Autowired、@Resource、@Value</h2><h3 id="autowired"><a class="markdownIt-Anchor" href="#autowired"></a> @Autowired.</h3><p>表示某个属性是否需要进行依赖注入，可以写在属性和方法上。注解中的required属性默认为ture，表示如果没有对象可以注入给属性则抛异常。</p><ul><li><p>@Autowired：加在某个<strong>属性</strong>上，Spring在进行Bean的生命周期过程中，在<strong>属性填充</strong>这一步会基于实例化出来的对象，对该对象中加了@Autowired的属性自动给属性赋值。具体实现为： Spring会先根据属性的类型去Spring容器中找出该类型所有的Bean对象，如果找出来多个，则再根据属性的名字从多个中再确定一个。如果required属性为true，并且根据属性信息找不到对象，则直接抛异常。</p></li><li><p>当@Autowired注解写在<strong>某个方法</strong>上时，Spring在B ean生命周期的属性填充阶段，会根据方法的参数类型、参数名字从Spring容器找到对象当做方法入参，自动反射调用该方法。</p></li><li><p>@Autowired加在<strong>构造方法</strong>上时，Spring会在<strong>推断构造方法阶段</strong>，<u>选择该构造方法来进行实例化</u>，在反射调用构造方法之前，会先根据构造方法参数类型、参数名从Spring容器中找到Bean对象，当做构造方法入参。</p></li></ul><h3 id="resource"><a class="markdownIt-Anchor" href="#resource"></a> @Resource</h3><p>@Resource注解与@Autowired类似，也是用来进行依赖注入的，@Resource是<strong>Java层面</strong>所提供的注解，@Autowired.是<strong>Spring</strong>所提供的注解，它们依赖注入的底层实现逻辑也不同。</p><p>@Resource：注解中有一个name属性，针对na me属性是否有值，@Resource的依赖注入底层流程是不同的。</p><ul><li>@Reousrce：如果name属性有值，那么Spring会直接根据所指定的name值去Spring容器找Bean对象，如果找到了则成功，如果没有找到，则报错。</li><li>如果@Resource中的name属性没有值，则：<ol><li>先判断该属性名字在Spring容器中是否存在Bean对象。</li><li>如果存在，则成功找到Bean对象进行注入。</li><li>如果不存在，则根据属性类型去Spring容器找Bean对象，找到一个则进行注入。</li></ol></li></ul><h3 id="value"><a class="markdownIt-Anchor" href="#value"></a> @Value</h3><p>@Value注解和@Resource、@Autowired类似，也是用来对属性进行依赖注入的，只不过@Value是用来从<strong>Properties.文件中</strong>来获取<strong>值</strong>的，并且@Value可以解析SpEL（Spring表达式）。</p><ul><li><p><code>@Value(&quot;yuzhou&quot;)</code>: 直接将字符串“zhouyu”赋值给属性，如果属性类型不是String，或无法进行类型转化，则报错。</p></li><li><p><code>@Value(${&quot;yuzhou&quot;})</code>： 将会把<code>${}</code>中的字符串当做key，从Properties文件中找出对应的value赋值给属性，如果没找到，则会把<code>${zhouyu}</code>当做普通字符串注入给属性。</p></li><li><p><code>@Value(#{&quot;yuzhou&quot;})</code>:会将<code>#{}</code>中的字符串当做Spring表达式进行解析，Spring会把&quot;zhouyu&quot;当做beanName，并从Spring容器中找对应bean，如果找到则进行属性注入，没找到则报错。</p></li><li></li></ul><h2 id="applicationcontext"><a class="markdownIt-Anchor" href="#applicationcontext"></a> ApplicationContext</h2><p>ApplicationContext是比BeanFactory更加强大的Spring容器，它既可以创建bean、获取bean，还支持国际化、事件广播、获取资源等BeanFactor y不具备的功能。</p><p>Application Context，所继承的接口</p><ul><li>EnvironmentCapable：拥有获取环境变量的能力：操作系统环境变量和Jvm环境变量</li><li>ListableBeanFactory：拥有了获取所有beanNames、判断某个bean Name是否存在peanDefinition对象、统计Be anDefinition个数、获取某个类型对应的所有beanNames等功能。</li><li>HierarchicalBeanFactory：拥有了获取父BeanFactory、。判断某个name是否存在bean对象的功能。</li><li>MessageSource：拥有了国际化功能，比如可以直接利用Messa geSource对象获取某个国际化资源（比如不同国家语言所对应的字符）</li><li>ApplicationEventPublisher： 拥有了事件发布功能，可以发布事件，这是Application Context相对于BeanFactory比较突出、常用的功能。</li><li>ResourcePatternResolver: 拥有了加载并获取资源的功能，这里的资源可以是文件，图片等某个URL资源都可以。</li></ul><h3 id="获得bean的方式"><a class="markdownIt-Anchor" href="#获得bean的方式"></a> 获得bean的方式：</h3><blockquote><p><em>getBean() API</em></p></blockquote><ul><li><p>按名称获取Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object lion = context.getBean(<span class="string">"lion"</span>);</span><br><span class="line"> </span><br><span class="line">assertEquals(Lion.class, lion.getClass());</span><br></pre></td></tr></table></figure><p>根据bean名称获取bean，如果在spring ico容器中存在和bean，则返回<em>Object</em> 类的实例。否则，抛出如下异常NoSuchBeanDefinitionException。</p><p>▲: 主要的缺点是，在获取bean之后，我们<strong>必须将它指定转换为所需的类型</strong>。如果返回的bean的类型与我们期望的不同，则可能会产生异常。</p></li><li><p>通过名称和类型获取Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lion lion = context.getBean(<span class="string">"lion"</span>, Lion.class);</span><br><span class="line"><span class="comment">// 与按名称获取Bean相比，此方法更安全，因为我们可以编译阶段就发现错误而不是在运行阶段。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">assertThrows(BeanNotOfRequiredTypeException.class, () -&gt; </span><br><span class="line">    context.getBean(<span class="string">"lion"</span>, Tiger.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>按类型获取Bean</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// right</span></span><br><span class="line">Lion lion = context.getBean(Lion.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: 在下面的情况下，需要特别注意可能存在的歧义：</span></span><br><span class="line">assertThrows(NoUniqueBeanDefinitionException.class, () -&gt; </span><br><span class="line">    context.getBean(Animal.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<em>Lion</em>和<em>Tiger都</em>实现了<em>Animal</em>接口，因此仅指定类型不足以明确确定结果。因此，我们会得到一个*<code>NoUniqueBeanDefinitionException</code>*。即在<strong>同一个IOC 容器中，如果<u>有相同类型的多个bean</u>，则不能通过类型获取bean</strong>。</p><ul><li>按名称和构造函数参数对Bean进行筛选</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tiger tiger = (Tiger) context.getBean(<span class="string">"tiger"</span>, <span class="string">"Siberian"</span>);</span><br><span class="line">Tiger secondTiger = (Tiger) context.getBean(<span class="string">"tiger"</span>, <span class="string">"Striped"</span>);</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="string">"Siberian"</span>, tiger.getName());</span><br><span class="line">assertEquals(<span class="string">"Striped"</span>, secondTiger.getName());</span><br></pre></td></tr></table></figure><ul><li><p>按类型和构造函数参数对Bean进行筛选</p><blockquote><p>▲: 这个方法有点不同，因为它<strong>只适用于具有原型作用域</strong>的bean。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tiger tiger = context.getBean(Tiger.class, <span class="string">"Shere Khan"</span>);</span><br><span class="line">assertEquals(<span class="string">"Shere Khan"</span>, tiger.getName());</span><br></pre></td></tr></table></figure></li></ul><h2 id="beanpostprocessor机制"><a class="markdownIt-Anchor" href="#beanpostprocessor机制"></a> BeanPostProcessor机制</h2><p>BeanPostProcessor是Spring所提供的一种扩展机制，可以利用该机制对Bean进行定制化加工，在Spring底层源码实现中，也广泛的用到了该机制，BeanPostProcessor通常也叫做<strong>Bean后置处理器</strong>。</p><p>BeanPostProcessor在Spring中是一个接口，我们定义一个后置处理器，就是提供一个类实现该接口，在Spring中还存在一些接口继承了BeanPostProcessor，这些子接口是在BeanPostProcessor的基础上增加了一些其他的功能。</p><p>BeanPostProcessori中的方法</p><ul><li>postProcessBeforelnitialization()：初始化前方法，表示可以利用这个方法来对Bean在初始化前进行自定义加工。</li><li>postProcessAfterInitialization()：初始化后方法，表示可以利用这个方法来对Bean在初始化后进行自定义加工。</li></ul><h3 id="instantiationawarebeanpostprocessor"><a class="markdownIt-Anchor" href="#instantiationawarebeanpostprocessor"></a> InstantiationAwareBeanPostProcessor</h3><blockquote><p>BeanPostProcessor的一个子接口</p></blockquote><ul><li>postProcessBeforelnstantiation()：实例化前</li><li>postProcessAfterInstantiation()：实例化后</li><li>postProcessProperties()：属性注入后</li></ul><h2 id="aop是什么"><a class="markdownIt-Anchor" href="#aop是什么"></a> AOP是什么？</h2><p>AOP就是面向切面编程，是一种非常适合在<strong>无需修改业务代码的前提</strong>下，对<u>某个或某些业务增加统一的功能</u>（横向增加功能），比如日志记录、权限控制、事务管理等，能很好的使得代码解耦，提高开发效率。</p><ul><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;From : &lt;a href=&quot;https://www.bilibili.com/video/BV1fr4y1Y7UH?p=6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/vid
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://nymrli.top/tags/Spring/"/>
    
      <category term="Web" scheme="https://nymrli.top/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>研究生work——地图匹配</title>
    <link href="https://nymrli.top/2022/02/26/%E7%A0%94%E7%A9%B6%E7%94%9Fwork%E2%80%94%E2%80%94%E5%9C%B0%E5%9B%BE%E5%8C%B9%E9%85%8D/"/>
    <id>https://nymrli.top/2022/02/26/研究生work——地图匹配/</id>
    <published>2022-02-26T07:24:46.000Z</published>
    <updated>2022-03-09T13:33:00.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="地图匹配"><a class="markdownIt-Anchor" href="#地图匹配"></a> 地图匹配</h1><p>概念：</p><blockquote><ul><li>地图匹配（Map-Matching）是将运营车辆的有序的GPS位置关联到电子地图的路网上，将GPS坐标下采样序列转换为数字路网坐标序列的过程；本质上是平面线段序列的模式匹配问题（ Alt等，2003）</li><li>地图匹配是一种将原始GPS位置映射到路网上的路段的过程，以创建对车辆所走路线的估算。</li></ul></blockquote><p>两个主要的地图匹配用例</p><ul><li>乘车结束时，计算驾驶员行进的距离，以计算票价。——路线图匹配(EORMM)</li><li><strong>实时</strong> ，为ETA团队提供准确的位置并做出<strong>调度</strong>决策，并在rider应用程序上<strong>显示</strong>驾驶员的汽车。——实时地图匹配(RTMM)</li></ul><p>不同点在于，<em>实时地图匹配</em>的要求比较高，必须低延时，因此相比之下，<em>路线图匹配</em>对等待时间的要求不那么严格，并且可以使用乘车的全部历史记录</p><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考：</h3><ul><li><p><a href="https://zhuanlan.zhihu.com/p/83039334" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/83039334</a></p></li><li><p><a href="https://blog.csdn.net/weixin_26713521/article/details/108134220" target="_blank" rel="noopener">Lyft的地图匹配算法论文翻译</a></p><ul><li><p>地图匹配算法的性能取决于<strong>道路网络数据</strong>的<strong>质量</strong></p></li><li><p>解决问题的一种好的方法是使用<strong>状态空间模型</strong> 。 状态空间模型是时间序列模型，其中系统具有“隐藏”状态，这些状态无法直接观察到，但会引起可见的观察。 在这里，我们的隐藏状态是我们要估算的汽车在道路网络上的实际位置。 我们仅观察到隐藏状态的修改版本：观察值(原始位置数据)。 我们假设系统的状态以仅取决于当前状态的方式演化(马尔可夫假设)，并进一步定义了从隐藏状态到隐藏状态的转移密度和从隐藏状态到观察的密度。</p><p>常用的地图匹配状态空间模型是离散状态<strong>隐马尔可夫模型</strong> (Newson＆Krumm [2]，DiDi的IJCAI-19教程[3]，Uber的Map Matching [4])。 在该系统中，我们通过查看路段上的最近点来生成候选对象，并使用<a href="https://en.wikipedia.org/wiki/Viterbi_algorithm" target="_blank" rel="noopener">维特比算法</a>查找最可能的隐藏状态序列。</p><ul><li>对于不同的建模选择和输入数据而言，它相对不灵活</li><li>它缩放严重(O(N²)，其中N是每个状态下可能的候选数)</li><li>它不能很好地应对高频观测(请参阅Newson＆Krumm [2])。</li></ul></li></ul></li><li><p><a href="http://qikan.cqvip.com/Qikan/Article/Detail?id=1000359922&amp;from=Qikan_Search_Index" target="_blank" rel="noopener">GPS定位与地图匹配方法研究</a></p><ul><li>地图匹配算法从原理上可以解释为两个独立的过程：（1）找到车辆当前行使的道路——确定候选路段（2）将当前GPS定位点投影到车辆行使的道路上——候选路段匹配规则<ul><li>圆心拓展半径找到最近的路段（唯一）——构建第一条边的算法</li></ul></li></ul></li><li><p>[1]苏洁, 周东方, 岳春生. GPS车辆导航中的实时地图匹配算法[J]. 测绘学报, 2001, 30(3):5.</p><ul><li>另外，为了提高算法的鲁棒性，对于误差引起 的速度异常，我们利用推测航位法和线性插值来 进行 GPS数据补偿，以消除部分GPS接收外部 粗差</li></ul></li><li><p>[1]李清泉, 黄练. 基于GPS轨迹数据的地图匹配算法[J]. 测绘学报, 2010(2):6.</p><ul><li>针对传统导航系统的地图匹配方法的研究较多。其中点到线的匹配由于缺乏对整体轨迹趋势的考虑，在复杂的道路网环境下的匹配易导致误匹配。也有方法使用DR、差分GPS等辅助设备，采用滤波、模糊逻辑、证据理论等方法提高地图匹配的准确率。GPS浮动车轨迹数据提供了整体曲线的变化趋势，可以采用全局整体匹配的思想，保证轨迹的完整性和准确性14？。基于曲线相似度的算法一般 较为复杂，但匹配精度高，利于轨迹的直接恢复，适合进行数据的后处理</li><li>与整个轨迹相对 应的路径必然是连通 的路段集 ，可以基于道路拓扑与连通性设计地图匹配算法</li><li>key：除了道路的几何连通性，实际行车还会受到交通规则的限制，本文基于道路网的行车限制信息提出了一种GPS浮动车轨迹数据的全局地图匹配算法，综合考虑备选路段的几何连通性与交通网络条件约束构建整体备选路径，然后使用<strong>改进的扫描线法</strong>判断全局轨迹曲线与备选路径的相似度，完成地图匹配 。<ul><li>一句话概括算法：通过行车限制将候选线段找出来后，选择曲线相似度最高的</li></ul></li></ul></li><li><p>[1]陈滨, 王平, 施文灶,等. GPS轨迹数据的综合地图匹配算法研究[J]. 电子科技, 2014, 27(12):4.</p><ul><li>从实际的匹配效果来看，此匹配算法在交叉路口等路段较复杂的地方可有较高地匹配准确率，但该方法依赖于前后GPS定位点匹配准确度，若前一定位点匹配错误就会出现连锁反应，从而导致后面一系列点匹配错误；且历史轨迹推算匹配法计算量较大，匹配速度较慢，不利于高速实时定位。因此，需和其他地图匹配方法相结合使用才能取得较好的匹配效果。</li></ul></li><li><p>智能交通系统中GPS地图匹配算法设计与实现_罗杰涛</p><ul><li>模糊逻辑： 效率高，实时性好，对绝大多数的路段状况都适用。不过在车俩拐弯处以及车速较慢的情况下匹配效果不尽如人意，且不同路段建模的系数凭靠经验值，没有相应的缺乏理论依据。——01、06、08论文</li></ul></li><li><p>高级地图匹配算法：研究现状和趋势[2021]</p><ul><li><p>从实现技术或模型角度对近十年提出的算法进行分类，箭头标记算法间的继承关系。从图2可见，HMM模型是主流，其次是基于最大权重的模型.HMM-News-on、ST-Matching2 3IVMM3和HRIS8被引用对比最多，是具有开创性的工作。另外，从2019年开始，有研究采用深度学习技术来解决地图匹配问题。</p><p><img src="/2022/02/26/研究生work——地图匹配/E:%5Chexo%5Csource_posts%5C%E7%A0%94%E7%A9%B6%E7%94%9Fwork%E2%80%94%E2%80%94%E5%9C%B0%E5%9B%BE%E5%8C%B9%E9%85%8D%5C09-20%E5%B9%B4%E5%9C%B0%E5%9B%BE%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B.jpg" alt="09-20年地图匹配算法发展历程"></p></li></ul></li></ul><h3 id="points"><a class="markdownIt-Anchor" href="#points"></a> Points:</h3><ul><li><p>另外，一个重要的实际问题是，即使车辆定位精度可以保证在10米以内，当电子地图缩放到较大的比例尺时，也会<br>出现车辆偏离行使的道路而造成的视觉混乱现象.</p></li><li><p>由于城区内地物特征复杂，受密集的高大建筑物、隧道、立交桥、树木等地物的反射和遮蔽等影响，车栽GPS接收机接收到的卫星信号存在严重的多径效应，在某些区域内甚至会形成GPS定位育区，解决GPS盲区问题，一种方法是采用航位推算法（DR-Dead Reckoning），这种方法需要将DR设备装在车辆前端，一般在GPS接收机卫星信号受阻时一样可以得到正确的用户位置，但这种方法需要附加设备。另一种方法是在记忆正确GPS位置信息的基础上在一段时间内预测车辆位置，这种方法的优点是易于实现，缺点是精度不够（没有，作者使用卡尔曼滤波进行位置预测，预测结果如图所示。在规则行进时，预测效果较好，见图3、图4.但是当车辆转弯时，效果很差，见图5、图6</p></li><li><p>到折线的距离定义为点到折线上所有直线段的最短距离：点到线段的距离定义为如果点到直线段所在直线的投影在直线段上，则为垂线长度，否则为其到两个端点的最短距离。</p></li><li><p>定位误差： GPS误差、电子地图库误差、坐标投影变换投影</p></li><li><p>难点：</p><ul><li><a href="http://qikan.cqvip.com/Qikan/Article/ReadIndex?id=33650279&amp;info=X19Wa%2bQedw8TOqUh1eM7U0SrEn1nIM08tSny4w0YhPo%3d" target="_blank" rel="noopener">Y-junction问题</a>——点到线的匹配方式，没有考虑全局匹配</li><li>平行双线路</li></ul></li><li><p>MapMatching实现的思路</p><ul><li><strong>离散点集匹配</strong>：相对简单，随机离散点没有形状和拓扑关系，用欧氏距离作吸附即可，典型应用如离散热力图。</li><li><strong>曲线拟合</strong>： 实际中更有应用价值的是曲线拟合匹配关系，比如轨迹和路网，GPS序列和导航路的相似性。</li></ul></li><li><p>MapMatching算法的分类：</p><p><strong>以使用到的信息来划分</strong></p><p>现有的算法可被分成四类：几何、拓扑、概率、高级。</p><p>a）基于几何的算法考虑GPS点与道路的几何信息，如距离、角度等；</p><p>b）基于拓扑的算法使用道路拓扑信息来控制；</p><p>c）概率方法通过考虑GPS点的概率；</p><p>d）高级的算法往往综合考虑使用全面信息，有卡尔曼滤波、模糊逻辑模型、隐式马尔可夫模型等等。</p><p><strong>2.2 以考虑采样点的范围来划分</strong></p><p>根据考虑采样点的范围，可分成局部/增量算法、全局算法。</p><p>a）局部/增量算法是贪婪算法，每次确定一个匹配点，下个点从已经确定的匹配点开始。这些方法根据距离和方向相似性来找到局部最优点或边。（在线匹配）</p><p>b）全局算法是要从路网中找到一条与采样轨迹最接近的匹配轨迹。为了测量采样轨迹和匹配轨迹的相似性，大多数算法使用“Frechet距离”或者是“弱Frechet距离”。还有时空匹配算法、投票算法等。（离线匹配）</p><p><strong>以采样点的频率来划分</strong></p><p>根据轨迹数据的采样频率，现有的地图匹配算法可分成：</p><p>a）高频采样算法（所有局部算法、部分全局算法如Frechet距离判别法等）</p><p>b）低频采样算法（ST-matching算法、IVVM算法）</p><p>一般认为30s及其以上为低频采样，1s～10s为高频采样。</p><p><a href="https://www.cnblogs.com/LBSer/p/4612031.html#!comments" target="_blank" rel="noopener">https://www.cnblogs.com/LBSer/p/4612031.html#!comments</a></p></li><li><p>智能交通系统中GPS地图匹配算法设计与实现</p><p><img src="/2022/02/26/研究生work——地图匹配/E:%5Chexo%5Csource_posts%5C%E7%A0%94%E7%A9%B6%E7%94%9Fwork%E2%80%94%E2%80%94%E5%9C%B0%E5%9B%BE%E5%8C%B9%E9%85%8D%5C%E5%9C%B0%E5%9B%BE%E5%8C%B9%E9%85%8D%E7%BB%84%E4%BB%B6.jpg" alt="地图匹配组件"></p></li></ul><h3 id="算法评估的标准"><a class="markdownIt-Anchor" href="#算法评估的标准"></a> 算法评估的标准</h3><ul><li>实时性</li><li>可靠性(鲁棒性)</li><li>匹配的精度</li></ul><h2 id="朴素算法"><a class="markdownIt-Anchor" href="#朴素算法"></a> 朴素算法：</h2><p>快速匹配算法的执行步骤如下：</p><ol><li>步1接收GPS定位数据；</li><li>步2判断定位数据是否无效，若无效，则根据历史定位数据进行推测匹配，然后转（8）；</li><li>步3判断车辆当前是否处于停止或低速滑行状态，若是，对其作相应处理，然后转（8）；</li><li>步4由车辆当前位置点计算其对应的候选网格，进而获取其中的路段；</li><li>步5对步4得到的路段进行<strong>连接性拓扑检查</strong>，将通过拓扑检查的路段作为匹配候选路段；</li><li>步6判断匹配候选路段数目，若唯一，则直接将其作为匹配路段，并由定位点向其作投影，然后转（8）；否则，计算所有候选路段的匹配度度量值f，（i=1,2，…，N），从中选出最大值fm和次大值fm；</li><li>步7判断最大值fm和次大值fm之差是否大于阈值fh，且最大值fm是否大于阈值fh，如果大于，则将路段m作为匹配路段，并由定位点向其作投影；否则，暂不对本次定位结果进行匹配，待后面对其进行延时匹配处理；</li><li>步8结束本次匹配</li></ol><p>from : <a href="https://wenku.baidu.com/view/14551bfcfab069dc50220144.html?fr=xueshu_top" target="_blank" rel="noopener">一种适于车辆导航系统的快速地图匹配算法</a>——2003</p><h2 id="key"><a class="markdownIt-Anchor" href="#key"></a> Key:</h2><ul><li><p>出行数据：采用GPS定位，那么是否是WGS-84数据，但是GIS部门的路网数据坐标是什么坐标系下的</p></li><li><p>双线路：</p></li><li><p>当下，现在很多用于MapMatching的方法，大多来自于推理、预测的数学方法，如隐马尔可夫链、贝叶斯模型、神经网络模型等，但在数据结构上的创新比较少，GIS算法，更多要在计算机的基础上，结合比如时空观念、数据特征、拓扑关系等对于GIS相关的基础理论</p></li></ul><h2 id="软件"><a class="markdownIt-Anchor" href="#软件"></a> 软件</h2><ul><li>mapinfo: 当今世界上流行的桌面地理信息系统</li><li>graphhopper: 路径规划库</li><li>arcgis</li><li>openstreetmap——开源地图，简称为OSM</li></ul><p>线要素的匹配，主要通过几何、拓扑或语义相似度来进行识别，其中通过空间距离来进行要素匹配的常用方式有：</p><ul><li>闵可夫斯基距离(Minkowski Distance)</li><li>欧氏距离(Euclidean Distance)</li><li>曼哈顿距离(Manhattan Distance)</li><li>切比雪夫距离(Chebyshev Distance)</li><li>汉明距离(Hamming distance)</li><li>杰卡德相似系数(Jaccard similarity coefficient)</li><li>豪斯多夫距离(Hausdorff Distance)</li><li>弗雷歇距离(Fréchet距离)</li></ul><p>from：<a href="http://www.biaozhu.net/9224.html" target="_blank" rel="noopener">高德地图：地图数据处理之道路匹配篇</a></p><h1 id="隐马尔科夫hmm"><a class="markdownIt-Anchor" href="#隐马尔科夫hmm"></a> 隐马尔科夫HMM</h1><p><strong>HMM有三个典型(canonical)问题</strong>:</p><ul><li><strong>概率计算问题</strong>：已知模型参数，计算某一特定输出序列的概率.通常使用**<a href="http://en.wikipedia.org/wiki/Forward_algorithm" target="_blank" rel="noopener">Forward</a>算法**解决；</li><li><strong>预测问题或者解码（decoding）问题</strong>：已知模型参数，寻找最可能的能产生某一特定输出序列的<strong>隐含状态</strong>的序列。通常使用**<a href="http://en.wikipedia.org/wiki/Viterbi_algorithm" target="_blank" rel="noopener">Viterbi</a>算法**解决；</li><li><strong>学习问题</strong>：已知输出序列，寻找最可能的状态转移以及输出概率。通常使用**<a href="http://en.wikipedia.org/wiki/Baum-Welch_algorithm" target="_blank" rel="noopener">Baum-Welch</a>算法**。</li></ul><h2 id="hmm的几个重要元素"><a class="markdownIt-Anchor" href="#hmm的几个重要元素"></a> HMM的几个重要元素：</h2><ul><li><p>π(startprob_): 隐藏状态初始向量</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi><mo>=</mo><mrow><mo fence="true">(</mo><msub><mi>π</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><mo>:</mo><msub><mi>π</mi><mi>i</mi></msub><mo>=</mo><mi>P</mi><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo>=</mo><mi>i</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\pi=\left(\pi_{i}\right): \pi_{i}=P\left(q_{1}=i\right), 1 \leq i \leq N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">i</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></span></p></li><li><p>A(transmat_):  状态转移概率矩阵:</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><msub><mrow><mo fence="true">[</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo fence="true">]</mo></mrow><mrow><mi>N</mi><mo>×</mo><mi>N</mi></mrow></msub><mtext>, 其中 </mtext><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mi>P</mi><mrow><mo fence="true">(</mo><msub><mi>q</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>j</mi><mo>∣</mo><msub><mi>q</mi><mi>t</mi></msub><mo>=</mo><mi>i</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>≤</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">A=\left[a_{i j}\right]_{N \times N} \text {, 其中 } a_{i j}=P\left(q_{t+1}=j \mid q_{t}=i\right), 1 \leq i, j \leq N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.144139em;vertical-align:-0.394139em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.14252299999999996em;"><span style="top:-2.364192em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">×</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394139em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">, </span><span class="mord cjk_fallback">其中</span><span class="mord"> </span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">i</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></span></p></li><li><p>B(emissionprob_): 观测状态概率矩阵</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>=</mo><msub><mrow><mo fence="true">[</mo><msub><mi>b</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo fence="true">]</mo></mrow><mrow><mi>N</mi><mo>×</mo><mi>M</mi></mrow></msub><mi mathvariant="normal">，</mi><mtext> 其中 </mtext><msub><mi>b</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mrow><mo fence="true">(</mo><msub><mi>o</mi><mi>t</mi></msub><mo>=</mo><msub><mi>o</mi><mi>k</mi></msub><mo>∣</mo><msub><mi>q</mi><mi>t</mi></msub><mo>=</mo><mi>j</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>N</mi><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">B=\left[b_{j}(k)\right]_{N \times M} ， \text { 其中 } b_{j}(k)=P\left(o_{t}=o_{k} \mid q_{t}=j\right), 1 \leq j \leq N, 1 \leq k \leq M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.144139em;vertical-align:-0.394139em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.14252299999999996em;"><span style="top:-2.364192em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">×</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394139em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">，</span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">其中</span><span class="mord"> </span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></span></p></li><li><p>HMM的状态变量数目：N</p></li><li><p>HMM的观察变量数目：M</p></li></ul><p>如果观测序列是一维的，则观测状态的概率密度函数是一维的普通高斯分布。如果观测序列是N维的，则隐藏状态对应的观测状态的概率密度函数是N维高斯分布。高斯分布的概率密度函数参数可以用μμ表示高斯分布的期望向量，Σ表示高斯分布的协方差矩阵。在GaussianHMM类中，“means”用来表示各个隐藏状态对应的高斯分布期望向量μ形成的矩阵，而“covars”用来表示各个隐藏状态对应的高斯分布协方差矩阵Σ形成的三维张量。</p><p>from :<a href="https://www.cnblogs.com/pinard/p/7001397.html" target="_blank" rel="noopener">用hmmlearn学习隐马尔科夫模型HMM</a></p><h2 id="mapmatching与hmm"><a class="markdownIt-Anchor" href="#mapmatching与hmm"></a> MapMatching与Hmm</h2><ul><li>观察变量：从GPS设备中得到的位置信息（经度，纬度）</li><li>隐藏状态：拥有GPS设备的物体（车，人等）实际所在的位置路段。</li><li>观测概率：例如，现测的GPS点离旁边路段上的位置越近，那么这个真实点在这个路段上的概率越大状态。</li><li>状态转移概率：例如，前后两个真实的位置点的距离越近，那么状态转移的概率越大</li></ul><p>在下面相关论文工作中会说明在这几篇论文中其实只用到了预测问题的<a href="http://en.wikipedia.org/wiki/Viterbi_algorithm" target="_blank" rel="noopener">Viterbi</a>算法,下面也会另开一小节具体描述下<a href="http://en.wikipedia.org/wiki/Viterbi_algorithm" target="_blank" rel="noopener">Viterbi</a>算法。</p><p><strong>Map-Matching的两个变量</strong>：</p><ul><li>从GPS设备中得到的位置信息（经度，纬度）：HMM中观察变量；</li><li>拥有GPS设备的物体（车，人等）实际所在的位置：HMM中的隐藏状态变量，实际地图是不知道GPS设备的准确位置的。</li></ul><p>这样就把Map-Matching问题与HMM结合起来了。三个问题在Map-Matching中有用的是两个问题：（1）预测问题；（2）学习问题。</p><p>在论文中，定义的规则要满足人的直观上的感觉，即人的先验知识，主要有以下两种：</p><ul><li>观测概率：观测的GPS点离旁边路段上的位置越近，那么这个真实点在这个路段上的概率越大。</li><li>状态转移概率：这里有两种解决思路：（1）前后两个真实的位置点的距离越近，那么状态转移的概率越大；或者（2）真实路段上的前后两个点的距离与GPS观测的前后两个点的距离越接近，状态转移概率越大。</li></ul><p>from: <a href="https://www.cnblogs.com/mindpuzzle/p/3653043.html" target="_blank" rel="noopener">基于隐马尔科夫模型(HMM)的地图匹配(Map-Matching)算法</a></p><h3 id="barefoot"><a class="markdownIt-Anchor" href="#barefoot"></a> <a href="https://github.com/bmwcarit/barefoot/wiki#stand-alone-servers" target="_blank" rel="noopener">barefoot</a></h3><ul><li>观测概率: 测量位置与其真实位置之间的距离，用于对测量误差进行建模，测量误差用具有一些标准偏差<em>σ</em>的高斯分布来描述（默认为<em>σ = 5 米</em>）。</li><li>转移概率: 用各个位置测量之间的路由距离和视线距离的差异来量化的。转移概率呈负指数分布，速率参数<em>λ</em>（默认为<em>λ = 0.1</em>）是均值的倒数</li></ul><p>==&gt;</p><ul><li><p><em><strong>序列概率</strong></em>： 定义<em>p(s 0 … s t |z 0 … z t )<em>为最可能的序列到达匹配候选</em>s t</em>的概率，称为 s t 的序列概率， 可以通过递归确定</p></li><li><p><em><strong>过滤概率</strong></em>：我们的 HMM 滤波器确定对象当前位置的估计值<em>s̅ t</em>，它是最可能匹配的候选对象<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>t</mi></msub><mo>∈</mo><msub><mi>S</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">s_t ∈ S_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 给定测量值<code>z0 ... zt</code>，其定义为：<code>s̅t = argmax(st ∈ St) p(st|z0 ... zt)</code>, <code>p(st|z0 ... zt)</code>称为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">s_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的过滤概率***，可以递归确定：</p><p><code>p(st|z0...zt) = p(st|zt) · Σ(st-1 ∈ St-1) p(st|st-1) · p(st-1|z0 ... zt-1)</code>。</p></li></ul><p>from: <a href="https://github.com/bmwcarit/barefoot/wiki#stand-alone-servers" target="_blank" rel="noopener">https://github.com/bmwcarit/barefoot/wiki#stand-alone-servers</a></p><h2 id="coding"><a class="markdownIt-Anchor" href="#coding"></a> Coding</h2><blockquote><p>在之前的<a href="http://www.cnblogs.com/pinard/p/6945257.html" target="_blank" rel="noopener">HMM系列</a>中，我们对隐马尔科夫模型HMM的原理以及三个问题的求解方法做了总结。本文我们就从实践的角度用Python的<a href="https://hmmlearn.readthedocs.io/en/latest/api.html#hmmlearn-hmm" target="_blank" rel="noopener">hmmlearn</a>库来学习HMM的使用。sklearn库中将HMM弃用了，新开了一个<code>hmmlearn</code>的新库，安装命令为：<code>pip install hmmlearn</code>，关于hmmlearn的更多资料在<a href="http://hmmlearn.readthedocs.io/" target="_blank" rel="noopener">官方文档</a>有介绍。</p></blockquote><p>hmmlearn实现了三种HMM模型类，按照观测状态是连续状态还是离散状态，可以分为两类。</p><ol><li>GaussianHMM 观测状态连续型且符合高斯分布</li><li>GMMHMM 观测状态连续型且符合混合高斯分布</li><li>MultinomialHMM 观测状态离散型</li></ol><p><strong>HMM主要解决的三个问题</strong><br>假设隐藏状态序列和观测状态序列分别使用Z和X表示，则解决的3个问题可表示为:<br>1.解码问题：已知模型参数和X，估计最可能的Z；维特比算法<br>2.概率问题：已知模型参数和X，估计X出现的概率；向前-向后算法<br>3.学习问题：仅给出X和隐藏层个数，估计模型参数。 B-W算法，通常是经过一定数量的训练以后，得到模型，然后解决问题1和2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Created on 2017-12-4</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">解码问题：本例为天气和行为的关系</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># hmmlearn可以在安装numpy以后，再使用pip install hmmlearn安装</span></span><br><span class="line"><span class="keyword">from</span> hmmlearn <span class="keyword">import</span> hmm</span><br><span class="line"></span><br><span class="line">states = [<span class="string">"Rainy"</span>, <span class="string">"Sunny"</span>]<span class="comment">##隐藏状态</span></span><br><span class="line">n_states = len(states)<span class="comment">##隐藏状态长度</span></span><br><span class="line"></span><br><span class="line">observations = [<span class="string">"walk"</span>, <span class="string">"shop"</span>, <span class="string">"clean"</span>]<span class="comment">##可观察的状态</span></span><br><span class="line">n_observations = len(observations)<span class="comment">##可观察序列的长度</span></span><br><span class="line"></span><br><span class="line">start_probability = np.array([<span class="number">0.6</span>, <span class="number">0.4</span>])<span class="comment">##开始转移概率，即开始是Rainy和Sunny的概率</span></span><br><span class="line"><span class="comment">##隐藏间天气转移混淆矩阵，即Rainy和Sunny之间的转换关系，例如[0,0]表示今天Rainy，明天Rainy的概率</span></span><br><span class="line">transition_probability = np.array([</span><br><span class="line">  [<span class="number">0.7</span>, <span class="number">0.3</span>],</span><br><span class="line">  [<span class="number">0.4</span>, <span class="number">0.6</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">##隐藏状态天气和可视行为混淆矩阵，例如[0,0]表示今天Rainy，walk行为的概率为0.1</span></span><br><span class="line">emission_probability = np.array([</span><br><span class="line">  [<span class="number">0.1</span>, <span class="number">0.4</span>, <span class="number">0.5</span>],</span><br><span class="line">  [<span class="number">0.6</span>, <span class="number">0.3</span>, <span class="number">0.1</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">#构建了一个MultinomialHMM模型，这模型包括开始的转移概率，隐藏间天气转换混淆矩阵（transmat），隐藏状态天气和可视行为混淆矩阵emissionprob，对模型参数初始化</span></span><br><span class="line">model = hmm.MultinomialHMM(n_components=n_states)</span><br><span class="line">model.startprob_= start_probability</span><br><span class="line">model.transmat_ = transition_probability</span><br><span class="line">model.emissionprob_ = emission_probability</span><br><span class="line"></span><br><span class="line"><span class="comment">#给出一个可见序列</span></span><br><span class="line">bob_Actions = np.array([[<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>]]).T</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决问题1,解码问题,已知模型参数和X，估计最可能的Z； 维特比算法 </span></span><br><span class="line">logprob, weathers = model.decode(bob_Actions, algorithm=<span class="string">"viterbi"</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Bob Actions:"</span>, <span class="string">", "</span>.join(map(<span class="keyword">lambda</span> x: observations[x], bob_Actions))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"weathers:"</span>, <span class="string">", "</span>.join(map(<span class="keyword">lambda</span> x: states[x], weathers))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">解码问题： 盒子</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> hmmlearn <span class="keyword">import</span> hmm</span><br><span class="line"></span><br><span class="line">states = [<span class="string">"box 1"</span>, <span class="string">"box 2"</span>, <span class="string">"box3"</span>]</span><br><span class="line">n_states = len(states)</span><br><span class="line"></span><br><span class="line">observations = [<span class="string">"red"</span>, <span class="string">"white"</span>]</span><br><span class="line">n_observations = len(observations)</span><br><span class="line"></span><br><span class="line">start_probability = np.array([<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.4</span>])</span><br><span class="line"></span><br><span class="line">transition_probability = np.array([</span><br><span class="line">  [<span class="number">0.5</span>, <span class="number">0.2</span>, <span class="number">0.3</span>],</span><br><span class="line">  [<span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.2</span>],</span><br><span class="line">  [<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.5</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">emission_probability = np.array([</span><br><span class="line">  [<span class="number">0.5</span>, <span class="number">0.5</span>],</span><br><span class="line">  [<span class="number">0.4</span>, <span class="number">0.6</span>],</span><br><span class="line">  [<span class="number">0.7</span>, <span class="number">0.3</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model = hmm.MultinomialHMM(n_components=n_states)</span><br><span class="line">model.startprob_=start_probability</span><br><span class="line">model.transmat_=transition_probability</span><br><span class="line">model.emissionprob_=emission_probability</span><br><span class="line"></span><br><span class="line">seen = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]).T</span><br><span class="line">logprob, box = model.decode(seen, algorithm=<span class="string">"viterbi"</span>)</span><br><span class="line">print(<span class="string">"The ball picked:"</span>, <span class="string">", "</span>.join(map(<span class="keyword">lambda</span> x: observations[x], seen)))</span><br><span class="line">print(<span class="string">"The hidden box"</span>, <span class="string">", "</span>.join(map(<span class="keyword">lambda</span> x: states[x], box)))</span><br><span class="line">(<span class="string">'The ball picked:'</span>, <span class="string">'red, white, red'</span>)</span><br><span class="line">(<span class="string">'The hidden box'</span>, <span class="string">'box3, box3, box3'</span>)</span><br></pre></td></tr></table></figure><h2 id="限制"><a class="markdownIt-Anchor" href="#限制"></a> 限制</h2><ul><li>对于不同的建模选择和输入数据而言，它相对不灵活</li><li>它缩放严重(O(N²)，其中N是每个状态下可能的候选数)</li><li>它不能很好地应对高频观测(请参阅Newson＆Krumm [2])。</li></ul><p>基于(无味)卡尔曼滤波器的新模型——<a href="https://blog.csdn.net/weixin_26713521/article/details/108134220" target="_blank" rel="noopener">https://blog.csdn.net/weixin_26713521/article/details/108134220</a></p><h1 id="help-code"><a class="markdownIt-Anchor" href="#help-code"></a> help Code:</h1><ul><li><a href="https://github.com/bmwcarit/barefoot" target="_blank" rel="noopener">https://github.com/bmwcarit/barefoot</a></li><li><a href="https://github.com/oldrev/mapmatchingkit" target="_blank" rel="noopener">https://github.com/oldrev/mapmatchingkit</a></li></ul><h1 id="网络文章"><a class="markdownIt-Anchor" href="#网络文章"></a> 网络文章</h1><ul><li><a href="https://blog.csdn.net/weixin_42599077/article/details/114801735" target="_blank" rel="noopener">地图匹配实例-几何匹配</a>——效果图</li><li><a href="https://blog.csdn.net/weixin_26713521/article/details/108134220" target="_blank" rel="noopener">定位匹配 模板匹配 地图_什么是地图匹配？</a></li><li><a href="https://blog.csdn.net/Feng512275/article/details/96199675?spm=1001.2014.3001.5502" target="_blank" rel="noopener">出租车轨迹点地图匹配研究</a></li><li><a href="https://blog.csdn.net/yixianfeng41/article/details/73010792" target="_blank" rel="noopener">地图匹配小结</a></li><li><a href="https://www.cnblogs.com/mindpuzzle/p/3653043.html" target="_blank" rel="noopener">基于隐马尔科夫模型(HMM)的地图匹配(Map-Matching)算法</a></li></ul><h1 id="工作安排"><a class="markdownIt-Anchor" href="#工作安排"></a> 工作安排</h1><p>你的工作主要完成什么（概括说明就行），分为那几步，每一步完成什么（概括说明就行），每一步的工作量（预计完成这步工作需要多少个小时），每一步工作预计在什么时候完成（比如 3.5）</p><ul><li>工作包含：地图匹配，将车辆的有序GPS位置数据关联到电子地图的路网上，将GPS坐标下采样序列转换为数字路网路径序列的过程。工作内容：解析过滤点并进行坐标转换-&gt;点过滤(点稀疏)-&gt;地图匹配算法-&gt;点映射</li></ul><table><thead><tr><th>内容</th><th>预估时间</th></tr></thead><tbody><tr><td>查阅地图匹配算法相关的论文-&gt;找到解决方案(16小时)</td><td>2022年2月28日</td></tr><tr><td>学习隐马尔科夫模型相关理论知识 (6小时)</td><td>2022年3月2日</td></tr><tr><td>找寻隐马尔科夫模型资料、代码(8小时)——barefoot、graphhopper</td><td>2022年3月4日</td></tr><tr><td>熟悉项目中有关地图对象的代码（4小时）</td><td>2022年3月5日</td></tr><tr><td>移植隐马尔科夫模型到项目中，目前参考：开源<a href="https://github.com/bmwcarit/barefoot/wiki#stand-alone-servers" target="_blank" rel="noopener">barefoot</a>实现：熟悉代码(16小时)、坐标转换（3小时）、输入输出数据格式改造(10小时)、适配类(56小时)、效果检验（10小时）</td><td>2022年3月20日</td></tr><tr><td>点过滤（24小时）: 栅格化（16小时） + 双队列（8小时）</td><td>2022年3月24日</td></tr><tr><td>点映射（6小时）</td><td>2022年3月25日</td></tr></tbody></table><h1 id="库"><a class="markdownIt-Anchor" href="#库"></a> 库：</h1><ul><li><a href="https://developers.arcgis.com/javascript/latest/api-reference/esri-geometry-geometryEngine.html" target="_blank" rel="noopener">geometryEngine</a></li><li>net.sf.geographiclib</li><li>com.esri.core.geometry——QuadTree</li><li>graphhopper——org.locationtech.jts.geom  ==&gt; Envelope --&gt; findCandidateSnapsInBBox</li></ul><hr><h1 id="简单版实现思路"><a class="markdownIt-Anchor" href="#简单版实现思路"></a> 简单版实现思路</h1><ol><li>找到起始点O和终点D，以两点为半径画圆，把所有范围内的NormalEdge全部加入List（只要起始点or终止点有一个在范围内）</li><li>确定第一条===&gt; 找离第一个GPS点最近的边</li><li>likelyRoute.forEach从上一条的lowerNormalEdge中(保证拓扑可达连接)，从中选择得分最高（距离和方向）的边作为后续边 。  如果没有lowerNormalEdge（如果所有剩余的点都能映射到最后的这条边上，则认为是终点，此时不在意死路）， 平常如果是死路，则放弃这条序列路径。TODO：没有后续路径时是否要考虑增加可能边集？</li><li>到达终点边结束</li><li>从likelyRoute中选择得分最高的路径</li></ol><p>用到的结构：</p><ul><li><code>likelyRoute: list[list]</code>, 存放多条可能</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;地图匹配&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#地图匹配&quot;&gt;&lt;/a&gt; 地图匹配&lt;/h1&gt;
&lt;p&gt;概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;地图匹配（Map-Matching）是将运营车辆的有序的GPS位置关联到
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>私有Gitlab配置SSH连接</title>
    <link href="https://nymrli.top/2022/02/25/%E7%A7%81%E6%9C%89Gitlab%E9%85%8D%E7%BD%AESSH%E8%BF%9E%E6%8E%A5/"/>
    <id>https://nymrli.top/2022/02/25/私有Gitlab配置SSH连接/</id>
    <published>2022-02-25T05:38:19.000Z</published>
    <updated>2022-02-25T06:04:05.992Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SSH连接并不是像<a href="https://so.csdn.net/so/search?q=http&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">http</a>连接一样，输入用户名和密码就可以了。SSH连接需要一些额外的配置</p></blockquote><h1 id="生成ssh秘钥和公钥"><a class="markdownIt-Anchor" href="#生成ssh秘钥和公钥"></a> 生成SSH秘钥和公钥</h1><h2 id="查询有效邮箱"><a class="markdownIt-Anchor" href="#查询有效邮箱"></a> 查询有效邮箱</h2><p>首先要确定使用的邮箱，是不是自己认为的邮箱，比如我以为是<code>chenli@sucsoft.com</code>结果，却发现是<code>399-chenli@sucsoft.com</code>，那么按照自认为的邮箱申请的keys那自然不会work。——一般情况不会有歧义邮箱出现，但我这边确实跟想的不太一样</p><h3 id="查询方法一新建项目"><a class="markdownIt-Anchor" href="#查询方法一新建项目"></a> 查询方法(一)——新建项目</h3><p>创建空的仓库，提示中提及的邮箱就是有效邮箱</p><p><img src="/2022/02/25/私有Gitlab配置SSH连接/gitlab-ssh.jpg" alt="gitlab-ssh"></p><h3 id="查询方法二个人preference"><a class="markdownIt-Anchor" href="#查询方法二个人preference"></a> 查询方法(二)——个人Preference</h3><ol><li>打开<code>User Settings-&gt;Profile</code>，其中有<code>Email</code>、<code>public email</code>和<code>commit email</code>三个邮箱，其中跟我们开发命令比较有关的就是这个Commit Email，之前我的默认是<code>399-chenli@sucsoft.com</code>，这边要设置自己想要的，比如<code>chenli@sucsoft.com</code></li></ol><p><img src="/2022/02/25/私有Gitlab配置SSH连接/email_settings.jpg" alt="email_settings"></p><p>▲选择完成后，滑到最下面选择Update profile settings</p><ol start="2"><li>打开<code>User Settings-&gt;Emails</code>可以看到，<code>chenli@sucsoft@sucsoft.com</code>的标签中有commit email，即设置成功</li></ol><p><img src="/2022/02/25/私有Gitlab配置SSH连接/preference_email.jpg" alt="preference_email"></p><h2 id="gitlab设置公钥"><a class="markdownIt-Anchor" href="#gitlab设置公钥"></a> Gitlab设置公钥</h2><p>确保邮箱是有效的后就可以生成秘钥了。</p><ol><li>设置git信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 设置git信息</span></span><br><span class="line">git config --global user.name <span class="string">"chenli"</span></span><br><span class="line">git config --global user.email <span class="string">"chenli@sucsoft.com"</span></span><br><span class="line"><span class="comment"># 2. 生成秘钥和公钥</span></span><br><span class="line">$ ssh-keygen -t rsa -C chenli@sucsoft.com</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/mrli/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /c/Users/mrli/.ssh/id_rsa</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /c/Users/mrli/.ssh/id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:zKPeKkm0bNzDqZcHUEDcvvDqPG2znRqDrD30yoBb8MM chenli@sucsoft.com</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 3072]----+</span></span><br><span class="line"><span class="string">|   ooo           |</span></span><br><span class="line"><span class="string">|    . o          |</span></span><br><span class="line"><span class="string">|     o           |</span></span><br><span class="line"><span class="string">|    + .o         |</span></span><br><span class="line"><span class="string">|.  + B oS        |</span></span><br><span class="line"><span class="string">| = .B.O. .       |</span></span><br><span class="line"><span class="string">|. E+o*++         |</span></span><br><span class="line"><span class="string">| o BB.B=..       |</span></span><br><span class="line"><span class="string">|. ..*B=*+        |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure><p>根据命令输出结果可以看到，生成的结果在<code>C:\Users\mrli\.ssh</code>路径下，有<code>id_rsa</code>、<code>id_rsa.pub</code>，其中<code>id_rsa.pub</code>为公钥。</p><ol start="2"><li><p>将SSH公钥添加到GitHub账户</p><ol><li>复制文件路径内.pub后缀里的内容</li><li>进入SSH Keys的设置页面（登录GitHub，在右上角头像点击设置）</li></ol><p><img src="/2022/02/25/私有Gitlab配置SSH连接/add_ssh.jpg" alt="add_ssh"></p><ol start="3"><li>粘贴后，Title会自动提取生成，点击<code>Add key</code>则完成添加</li></ol></li></ol><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@gitlab.sucsoft.com</span><br><span class="line">Welcome to GitLab, @chenli!</span><br></pre></td></tr></table></figure><h1 id="more"><a class="markdownIt-Anchor" href="#more"></a> More</h1><h2 id="配置多个git信息"><a class="markdownIt-Anchor" href="#配置多个git信息"></a> 配置多个Git信息</h2><ol><li>将默认的<code>id_rsa</code>和<code>id_rsa.pub</code>改成指定的如<code>id_rsa_sucsoft.pub</code></li><li><code>.ssh/</code>路径下添加<code>config</code>配置文件，对应填写</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Host github.com                 </span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile C:\\Users\\mrli\\.ssh\\id_rsa_github</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    User Freedomisgood</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Host gitlab.sucsoft.com</span><br><span class="line">    HostName gitlab.sucsoft.com</span><br><span class="line">    IdentityFile C:\\Users\\mrli\\.ssh\\id_rsa_sucsoft</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    User chenli</span><br></pre></td></tr></table></figure><p>注意：Host后写的就是<code>ssh -T git@gitlab.sucsoft.com</code>中@后面的内容，如果写的是<code>sucsoft</code>，则写成<code>ssh -T git@sucsoft</code>，但是这样其实跟Gitlab页面中直接提供的不一样: <code>git@gitlab.sucsoft.com:suc-frame/xxxx.git</code>，所以最好还是规范的写<code>gitlab.sucsoft.com</code></p><p>★配置完成后最终文件夹中的内容：</p><p><img src="/2022/02/25/私有Gitlab配置SSH连接/more-1.jpg" alt="more-1"></p><p>注： known_host是自动生成的，如果第一次SSH连接网站，则会将host添加到这个文件中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;SSH连接并不是像&lt;a href=&quot;https://so.csdn.net/so/search?q=http&amp;amp;spm=1001.2101.3001.7020&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http&lt;/a&gt;连
      
    
    </summary>
    
    
      <category term="git" scheme="https://nymrli.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Golang protoc的使用</title>
    <link href="https://nymrli.top/2022/02/22/protoc%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://nymrli.top/2022/02/22/protoc的使用/</id>
    <published>2022-02-22T04:04:33.000Z</published>
    <updated>2022-02-22T06:11:07.536Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用Grpc需要有protoc的支持, 但默认安装的<code>/Go/bin</code>目录下只有<code>go.exe</code>、<code>gofmt.exe</code>两个可执行文件，因此要使用<code>protoc</code>的话，需要自己去下载</p></blockquote><ol><li><p>在<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Freleases" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/releases</a>中下载Windows64的压缩包，为<code>$protoc -go_out=. *.proto</code>使用到的命令可执行文件</p></li><li><p>编写<code>.proto</code>文件， 如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line"># 注意, 这边使用的是go_package, 类似的还有java_package, 后面的参数是output_path和包名</span><br><span class="line">option go_package = &quot;.;geecachepb&quot;;</span><br><span class="line"></span><br><span class="line">message Request&#123;</span><br><span class="line">  string group = 1;</span><br><span class="line">  string key = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Response&#123;</span><br><span class="line">  bytes value = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service GroupCache&#123;</span><br><span class="line">  rpc Get(Request) returns (Response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>protoc -go_out=. *.proto</code>命令，将<code>.proto</code>转换成要使用的go文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code generated by protoc-gen-go. DO NOT EDIT.</span></span><br><span class="line"><span class="comment">// versions:</span></span><br><span class="line"><span class="comment">// protoc-gen-go v1.27.1</span></span><br><span class="line"><span class="comment">// protoc        v3.19.4</span></span><br><span class="line"><span class="comment">// source: geecachepb.proto</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> geecachepb</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">protoreflect <span class="string">"google.golang.org/protobuf/reflect/protoreflect"</span></span><br><span class="line">protoimpl <span class="string">"google.golang.org/protobuf/runtime/protoimpl"</span></span><br><span class="line">reflect <span class="string">"reflect"</span></span><br><span class="line">sync <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// Verify that this generated code is sufficiently up-to-date.</span></span><br><span class="line">_ = protoimpl.EnforceVersion(<span class="number">20</span> - protoimpl.MinVersion)</span><br><span class="line"><span class="comment">// Verify that runtime/protoimpl is sufficiently up-to-date.</span></span><br><span class="line">_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - <span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">state         protoimpl.MessageState</span><br><span class="line">sizeCache     protoimpl.SizeCache</span><br><span class="line">unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">Group <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group,proto3" json:"group,omitempty"`</span></span><br><span class="line">Key   <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 省略更多</span></span><br></pre></td></tr></table></figure></li><li><p><code>go get -u github.com/golang/protobuf/protoc-gen-go</code>安装使用<code>xxxx.pb.go</code>文件的库</p></li><li><p>在业务代码中使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PeerGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">Get(in *pb.Request, out *pb.Response) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HttpPool)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    body, err := proto.Marshal(&amp;pb.Response&#123;Value: view.ByteSlice()&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *httpGetter)</span> <span class="title">Get</span><span class="params">(in *pb.Request, out *pb.Response)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">u := fmt.Sprintf(</span><br><span class="line"><span class="string">"%v%v/%v"</span>,</span><br><span class="line">h.baseURL,</span><br><span class="line">url.QueryEscape(in.GetGroup()),</span><br><span class="line">url.QueryEscape(in.GetKey()),</span><br><span class="line">)</span><br><span class="line">res, err := http.Get(u)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"server return %v"</span>, res.Status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bytes, err := ioutil.ReadAll(res.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err = proto.Unmarshal(bytes, out); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"decoding response body: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推荐风格"><a class="markdownIt-Anchor" href="#推荐风格"></a> 推荐风格</h2><ul><li>文件(Files)<ul><li>文件名使用小写下划线的命名风格，例如 lower_snake_case.proto</li><li>每行不超过 80 字符</li><li>使用 2 个空格缩进</li></ul></li><li>包(Packages)<ul><li>包名应该和目录结构对应，例如文件在<code>my/package/</code>目录下，包名应为 <code>my.package</code></li></ul></li><li>消息和字段(Messages &amp; Fields)<ul><li>消息名使用首字母大写驼峰风格(CamelCase)，例如<code>message StudentRequest { ... }</code></li><li>字段名使用小写下划线的风格，例如 <code>string status_code = 1</code></li><li>枚举类型，枚举名使用首字母大写驼峰风格，例如 <code>enum FooBar</code>，枚举值使用全大写下划线隔开的风格(CAPITALS_WITH_UNDERSCORES )，例如 FOO_DEFAULT=1</li></ul></li><li>服务(Services)<ul><li>RPC 服务名和方法名，均使用首字母大写驼峰风格，例如<code>service FooService{ rpc GetSomething() }</code></li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;使用Grpc需要有protoc的支持, 但默认安装的&lt;code&gt;/Go/bin&lt;/code&gt;目录下只有&lt;code&gt;go.exe&lt;/code&gt;、&lt;code&gt;gofmt.exe&lt;/code&gt;两个可执行文件，因此要使用&lt;code&gt;protoc&lt;/code
      
    
    </summary>
    
    
      <category term="Go" scheme="https://nymrli.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>语义化的版本控制</title>
    <link href="https://nymrli.top/2022/01/26/%E8%AF%AD%E4%B9%89%E5%8C%96%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    <id>https://nymrli.top/2022/01/26/语义化的版本控制/</id>
    <published>2022-01-26T14:30:00.000Z</published>
    <updated>2022-01-26T14:40:45.998Z</updated>
    
    <content type="html"><![CDATA[<p>语义化的版本控制： 用一组简单的规则及条件来约束版本号的配置和增长</p><blockquote><p>作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级包，而无需推出新的依赖包，节省你的时间及烦恼。</p><p>如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。</p><p>如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函数库正在使用它并遵循这些规则就可以了。请在你的 README 文件中保留<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">此页链接</a>，让别人也知道这些规则并从中受益。</p></blockquote><h2 id="target"><a class="markdownIt-Anchor" href="#target"></a> Target:</h2><p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p><ol><li>主版本号：当你做了不兼容的 API 修改，</li><li>次版本号：当你做了向下兼容的功能性新增，</li><li>修订号：当你做了向下兼容的问题修正。</li></ol><p>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p><h2 id="语义化版本控制规范semver"><a class="markdownIt-Anchor" href="#语义化版本控制规范semver"></a> 语义化版本控制规范（SemVer）</h2><p>以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。</p><ol><li>使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文件内。无论何种形式都应该力求精确且完整。</li><li>标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。</li><li>标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。</li><li>主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。</li><li>1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。</li><li><strong>修订号</strong> Z（x.y.Z <code>|</code> x &gt; 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。</li><li><strong>次版本号</strong> Y（x.Y.z <code>|</code> x &gt; 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。</li><li><strong>主版本号</strong> X（X.y.z <code>|</code> X &gt; 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。</li><li><strong>先行版本号</strong>：可以（MAY）被标注在修订版之后，先加上<strong>一个连接号</strong>再加上<strong>一连串以句点分隔</strong>的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。</li><li><strong>版本编译信息</strong>可以（MAY）被标注在修订版或先行版本号之后，先加上<strong>一个加号</strong>再加上一连串以<strong>句点分隔</strong>的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译信息可（SHOULD）被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。</li><li>版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha &lt; 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：只有数字的标识符以数值高低比较，有字母或连接号时则逐字以 ASCII 的排序来比较。数字的标识符比非数字的标识符优先层级低。若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。范例：1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0-rc.1 &lt; 1.0.0。</li></ol><h2 id="faq"><a class="markdownIt-Anchor" href="#faq"></a> FAQ</h2><p><strong>在 0.y.z 初始开发阶段，我该如何进行版本控制？</strong></p><p>最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。</p><p><strong>如何判断发布 1.0.0 版本的时机？</strong></p><p>当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。</p><p><strong>这不会阻碍快速开发和迭代吗？</strong></p><p>主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。</p><p><strong>对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？</strong></p><p>这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。</p><p><strong>为整个公共 API 写文件太费事了！</strong></p><p>为供他人使用的软件编写适当的文件，是你作为一名专业开发者应尽的职责。保持专案高效一个非常重要的部份是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。</p><p><strong>万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？</strong></p><p>一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文件中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。</p><p><strong>如果我更新了自己的依赖但没有改变公共 API 该怎么办？</strong></p><p>由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的包有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。</p><p><strong>如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）</strong></p><p>自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。</p><p><strong>我该如何处理即将弃用的功能？</strong></p><p>弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部份公共 API 时，你应该做两件事：（1）更新你的文件让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。</p><p><strong>语义化版本对于版本的字串长度是否有限制呢？</strong></p><p>没有，请自行做适当的判断。举例来说，长到 255 个字元的版本已过度夸张。再者，特定的系统对于字串长度可能会有他们自己的限制。</p><h2 id="版本alpha-beta-rc"><a class="markdownIt-Anchor" href="#版本alpha-beta-rc"></a> 版本：Alpha、beta、RC</h2><blockquote><p>这些叫做先行版本号。被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰，如1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92</p></blockquote><p>常见的 RC 版本，全称是 Release Candidate。其中 Release 是发行、发布的意思。Candidate 是候选人的意思，用在软件或者操作系统上就是候选版本。因此 Release Candidate 就是发行候选版本。</p><table><thead><tr><th>版本名称</th><th>介绍</th><th>说明</th></tr></thead><tbody><tr><td>Alpha</td><td>内测版本</td><td>内部测试版本。</td></tr><tr><td>Beta</td><td>公测版本</td><td>Beta 阶段会一直加入新的功能。</td></tr><tr><td>RC</td><td>候选版本</td><td>几乎就不会加入新的功能了，而主要着重于除错。</td></tr><tr><td>Release</td><td>正式版本</td><td>稳定版本。</td></tr></tbody></table><p>RC 版本和 Beta 版最大的差别在于 Beta 阶段会<strong>一直加入新的功能</strong>，但是到了 RC 阶段，几乎就不会加入新的功能了，而主要着重于<strong>除错</strong>。</p><p>RC 版本，它不是最终的版本，而是最终版（RTM，Release To Manufacture）之前的最后一个版本。广义上对测试有三个传统的称呼：Alpha（α）、Beta（β）、Gamma（γ），用来标识测试的阶段和范围。Alpha 是指内测，即现在说的 CB，指开发团队内部测试的版本或者有限用户体验测试版本。Beta 是指公测，即针对所有用户公开的测试版本。然后做过一些修改，成为正式发布的候选版本时叫做 Gamma，现在叫做 RC。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;语义化的版本控制： 用一组简单的规则及条件来约束版本号的配置和增长&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Springboot-Kotlin-Mockito</title>
    <link href="https://nymrli.top/2022/01/03/Springboot-Kotlin-Mockito/"/>
    <id>https://nymrli.top/2022/01/03/Springboot-Kotlin-Mockito/</id>
    <published>2022-01-03T09:19:10.000Z</published>
    <updated>2022-01-03T10:50:45.305Z</updated>
    
    <content type="html"><![CDATA[<p>初识 Mockito 这个测试框架后，我们要使用 Mock 的属性创建一个被测试类实例时，大概会下面这么纯手工来打造。</p><p>手工过程见: <a href="https://www.jianshu.com/p/bb705a56f620" target="_blank" rel="noopener">https://www.jianshu.com/p/bb705a56f620</a></p><p>如果所有的 Mock 对象全部通过手工来创建，那就不容易体现出 Mockito 的优越性出来。因此对于被测试对象的创建，Mock 属性的注入应该让 @Mock 和 @InjectMocks这两个注解大显身手了。</p><h2 id="mockito能力"><a class="markdownIt-Anchor" href="#mockito能力"></a> Mockito能力</h2><ul><li>@Mock：对函数的调用均执行mock（即虚假函数），不执行真正部分。</li><li>@Spy：对函数的调用均执行真正部分。</li><li>@InjectMocks：创建一个实例，其余用@Mock（或@Spy）注解创建的mock将被注入到用该实例中。</li></ul><p>@Autowird 方式是基于Springboot框架启动的自动注入。在单元测试中，如果没有启动 spring 框架，此时就需要通过 @ InjectMocks完成依赖注入： @InjectMocks会将带有@Spy 和@Mock 注解的对象尝试注入到被 测试的目标类中。记住下面这两句话即可：</p><ul><li>Usually when you are unit testing, you shouldn’t initialize Spring context. So remove Autowiring.</li><li>Usually when you do integration testing, you should use real dependencies. So remove mocking.</li></ul><p>这边也解释了，<code>@RunWith(MockitoJUnitRunner::class)</code>的含义，其实是给下面Mockito注入的成员提供一个运行环境，为什么不直接使用<code>@SpringBootTest</code>的原因主要还是启动太多，运行太重的考虑。那什么时候得用<code>@SpringBootTest</code>呢？——最简单的情况，即要注入controller又要注入service，同时需要<code>@mock</code>存储层的repository，由于controller和service都需要标注<code>@InjectMocks</code>, 但<strong>InjectMocks字段是无法注入其他InjectMocks字段的</strong>。所以我们可以考虑使用Spring来做容器管理。</p><h2 id="mock和mockbean区别"><a class="markdownIt-Anchor" href="#mock和mockbean区别"></a> <code>@Mock</code>和<code>@MockBean</code>区别</h2><p><strong>MockBean</strong>的介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在做单元测试时，如果想要 mock UserRepository 的逻辑，只需要声明一个变量并在上面加上 @MockBean 的注释即可，</span><br><span class="line">之后使用 when().thenReturn() 来设定 mock UserRepository 的行为。</span><br><span class="line">在运行时 SpringBoot 会扫描到你注释的 mock ，并自动装配到被测试的 controller 里面。</span><br><span class="line">这也是和 @Mock 注释不同的地方，后者只能生成一个 Mock 类，但是并不能自动装配到其它类里面。</span><br></pre></td></tr></table></figure><p>因此，<code>@Mock</code>方便来做单元测试，<code>@MockBean</code>大多用来做有依赖关系的集成测试</p><h2 id="vertify"><a class="markdownIt-Anchor" href="#vertify"></a> vertify</h2><blockquote><p>验证行为是否发生</p></blockquote><p><strong>verify方法用于验证 mock bean 的方法调用，要求必须是mock对象</strong></p><ul><li><code>Mockito . *verify* (mockBean ).someMethod();</code>表示：someMethod方法调用了一次，相当于times(1)</li><li><code>Mockito . *verify* (mock Bean, Mockito.times(n) ).someMethod();</code>表示：someMethod方法调用了n次</li><li><code>Mockito . *verify* (mock Bean, Mockito.never() ).someMethod();</code>表示：someMethod方法未执行</li><li><code>Mockito . *verify* (mock Bean, Mockito. atLeastOnce() ).someMethod();</code>表示：someMethod方法至少执行过一次,相当于atLeast(1)</li></ul><p><strong>需要注意的：</strong><code>Mockito.*verify* (mock Bean, Mockito.only() ).someMethod();</code>表示： <strong>仅有someMethod方法执行，且只有一次，不能有其他方法执行</strong></p><p>more: <a href="https://www.jianshu.com/p/0e6a868b9da0" target="_blank" rel="noopener">https://www.jianshu.com/p/0e6a868b9da0</a></p><h2 id="常用的-mockito-方法"><a class="markdownIt-Anchor" href="#常用的-mockito-方法"></a> 常用的 Mockito 方法：</h2><p>Mockito的使用，一般有以下几种组合：参考链接</p><p>do/when：包括doThrow(…).when(…)/doReturn(…).when(…)/doAnswer(…).when(…)<br>given/will：包括given(…).willReturn(…)/given(…).willAnswer(…)<br>when/then: 包括when(…).thenReturn(…)/when(…).thenAnswer(…)</p><table><thead><tr><th><strong>方法名</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Mockito.mock(classToMock)</td><td>模拟对象</td></tr><tr><td>Mockito.verify(mock)</td><td>验证行为是否发生</td></tr><tr><td>Mockito.when(methodCall).thenReturn(value1).thenReturn(value2)</td><td>触发时第一次返回value1，第n次都返回value2</td></tr><tr><td>Mockito.doThrow(toBeThrown).when(mock).[method]</td><td>模拟抛出异常。</td></tr><tr><td>Mockito.mock(classToMock,defaultAnswer)</td><td>使用默认Answer模拟对象</td></tr><tr><td>Mockito.when(methodCall).thenReturn(value)</td><td>参数匹配</td></tr><tr><td>Mockito.doReturn(toBeReturned).when(mock).[method]</td><td>参数匹配（直接执行不判断）</td></tr><tr><td>Mockito.when(methodCall).thenAnswer(answer))</td><td>预期回调接口生成期望值</td></tr><tr><td>Mockito.doAnswer(answer).when(methodCall).[method]</td><td>预期回调接口生成期望值（直接执行不判断）</td></tr><tr><td>Mockito.spy(Object)</td><td>用spy监控真实对象,设置真实对象行为</td></tr><tr><td>Mockito.doNothing().when(mock).[method]</td><td>不做任何返回</td></tr><tr><td>Mockito.doCallRealMethod().when(mock).[method] <a href="//xn--Mockito-lr4ko4ay553a.when">//等价于Mockito.when</a>(mock.[method]).thenCallRealMethod();</td><td>调用真实的方法</td></tr><tr><td>reset(mock)</td><td>重置mock</td></tr></tbody></table><h2 id="matchers"><a class="markdownIt-Anchor" href="#matchers"></a> Matchers</h2><ul><li><p>匹配任意参数</p></li><li><p><code>Mockito.anyInt()</code> 任何 int 值 ；</p></li><li><p><code>Mockito.anyLong()</code> 任何 long 值 ；</p></li><li><p><code>Mockito.anyString()</code> 任何 String 值 ；</p></li><li><p><code>Mockito.any(XXX.class)</code> 任何 XXX 类型的值 等等。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">with_unspecified_arguments</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List list = Mockito.mock(List.class);</span><br><span class="line">    <span class="comment">//匹配任意参数</span></span><br><span class="line">    Mockito.when(list.get(Mockito.anyInt())).thenReturn(<span class="number">1</span>);</span><br><span class="line">    Mockito.when(list.contains(Mockito.argThat(<span class="keyword">new</span> IsValid()))).thenReturn(<span class="keyword">true</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>,list.get(<span class="number">1</span>));</span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>,list.get(<span class="number">999</span>));</span><br><span class="line">    Assert.assertTrue(list.contains(<span class="number">1</span>));</span><br><span class="line">    Assert.assertTrue(!list.contains(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsValid</span> <span class="keyword">extends</span> <span class="title">ArgumentMatcher</span>&lt;<span class="title">List</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.equals(<span class="number">1</span>) || obj.equals(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>More：</p><table><thead><tr><th style="text-align:left">函数名</th><th style="text-align:left">匹配类型</th></tr></thead><tbody><tr><td style="text-align:left">any()</td><td style="text-align:left">所有对象类型</td></tr><tr><td style="text-align:left">anyInt()</td><td style="text-align:left">基本类型 int、非 null 的 Integer 类型</td></tr><tr><td style="text-align:left">anyChar()</td><td style="text-align:left">基本类型 char、非 null 的 Character 类型</td></tr><tr><td style="text-align:left">anyShort()</td><td style="text-align:left">基本类型 short、非 null 的 Short 类型</td></tr><tr><td style="text-align:left">anyBoolean()</td><td style="text-align:left">基本类型 boolean、非 null 的 Boolean 类型</td></tr><tr><td style="text-align:left">anyDouble()</td><td style="text-align:left">基本类型 double、非 null 的 Double 类型</td></tr><tr><td style="text-align:left">anyFloat()</td><td style="text-align:left">基本类型 float、非 null 的 Float 类型</td></tr><tr><td style="text-align:left">anyLong()</td><td style="text-align:left">基本类型 long、非 null 的 Long 类型</td></tr><tr><td style="text-align:left">anyByte()</td><td style="text-align:left">基本类型 byte、非 null 的 Byte 类型</td></tr><tr><td style="text-align:left">anyString()</td><td style="text-align:left">String 类型(不能是 null)</td></tr><tr><td style="text-align:left">anyList()</td><td style="text-align:left">List<t> 类型(不能是 null)</t></td></tr><tr><td style="text-align:left">anyMap()</td><td style="text-align:left">Map&lt;K, V&gt;类型(不能是 null)</td></tr></tbody></table><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><h2 id="junit中的基本注解"><a class="markdownIt-Anchor" href="#junit中的基本注解"></a> Junit中的基本注解：</h2><p>@Test：使用该注解标注的public void方法会表示为一个测试方法；<br>@BeforeClass：表示在类中的任意public static void方法执行之前执行；<br>@AfterClass：表示在类中的任意public static void方法之后执行；<br>@Before：表示在任意使用@Test注解标注的public void方法执行之前执行；<br>@After：表示在任意使用@Test注解标注的public void方法执行之后执行；</p><p>demo：</p><ul><li><a href="https://github.com/enesacikoglu/SpringBootKotlinApi/blob/master/src/test/kotlin/com/cengenes/kotlin/api/service/HotelServiceManagerTest.kt" target="_blank" rel="noopener">https://github.com/enesacikoglu/SpringBootKotlinApi/blob/master/src/test/kotlin/com/cengenes/kotlin/api/service/HotelServiceManagerTest.kt</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;初识 Mockito 这个测试框架后，我们要使用 Mock 的属性创建一个被测试类实例时，大概会下面这么纯手工来打造。&lt;/p&gt;
&lt;p&gt;手工过程见: &lt;a href=&quot;https://www.jianshu.com/p/bb705a56f620&quot; target=&quot;_blank
      
    
    </summary>
    
    
      <category term="开发笔记" scheme="https://nymrli.top/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>理解SpringBoot注解s</title>
    <link href="https://nymrli.top/2021/12/30/%E7%90%86%E8%A7%A3SpringBoot%E6%B3%A8%E8%A7%A3s/"/>
    <id>https://nymrli.top/2021/12/30/理解SpringBoot注解s/</id>
    <published>2021-12-30T12:30:45.000Z</published>
    <updated>2021-12-30T14:25:40.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="reuqestbody和requestparam"><a class="markdownIt-Anchor" href="#reuqestbody和requestparam"></a> @ReuqestBody和@RequestParam</h2><p>这两个注解都是在Controller某个Mapping函数的形参前加上的，但两个具体有什么区别呢？在使用的时候我们该如何选择呢? 这跟我们希望用户以什么形式来请求接口有关。</p><p>众所周知，请求头的Content-type有多个，如</p><p>常见的媒体格式类型如下：</p><ul><li>text/html ： HTML格式</li><li>text/plain ：纯文本格式</li><li>text/xml ： XML格式</li><li>image/gif ：gif图片格式</li><li>image/jpeg ：jpg图片格式</li><li>image/png：png图片格式</li></ul><p>以application开头的媒体格式类型：</p><ul><li>application/xhtml+xml ：XHTML格式</li><li>application/xml： XML数据格式</li><li>application/atom+xml ：Atom XML聚合格式</li><li>⭐️application/json： JSON数据格式</li><li>application/pdf：pdf格式</li><li>application/msword ： Word文档格式</li><li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li><li>⭐️application/x-www-form-urlencoded ：<code>&lt;form encType=&quot;&quot;&gt;</code>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</li></ul><p>另外一种常见的媒体格式是上传文件之时使用的：</p><ul><li>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li></ul><p>其中，POST请求最常用的是<code>application/x-www-form-urlencoded</code>,浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。请求类似于下面这样</p><p><img src="/2021/12/30/理解SpringBoot注解s/E:%5Chexo%5Csource_posts%5C%E7%90%86%E8%A7%A3SpringBoot%E6%B3%A8%E8%A7%A3s%5Cpost-www.png" alt="post-www"></p><p>此外，<code>application/json</code>也是POST比较常用的一种形式，也是目前比较推荐的，用来告诉服务端消息主体是序列化后的 JSON 字符串。在这种编码方式下，请求内容如下：</p><p><img src="/2021/12/30/理解SpringBoot注解s/E:%5Chexo%5Csource_posts%5C%E7%90%86%E8%A7%A3SpringBoot%E6%B3%A8%E8%A7%A3s%5Cpost-json.png" alt="post-json"></p><p>可以看出，无论是哪种编码，POST基本上都是从请求体中取数据解析的。而<code>@RequestBody</code>正是对应的请求体；<code>@RequestParam</code>呢，接收的参数是<strong>来自requestHeader</strong>中，即<strong>请求头</strong>。<strong>通常用于GET请求</strong>，功能是<em>从URL中提取请求参数</em>。比如常见的url：<code>http://localhost:8081/spring-boot-study/novel/findByAuthorAndType?author=唐家三少&amp;type=已完结</code>。对应的接口为<code>public List&lt;NovelEntity&gt; findByAuthorAndType(@RequestParam(value=&quot;author&quot;, required=false,defaultValue=&quot;天蚕土豆&quot;) String author, @RequestParam(value=&quot;type&quot;) String type)</code></p><p>@RequestParam有三个配置参数：</p><ul><li><code>required</code> 表示是否必须，默认为 <code>true</code>，必须。</li><li><code>defaultValue</code> 可设置请求参数的默认值。</li><li><code>value</code> 为接收url参数的参数名（相当于key值）。</li></ul><p><strong>@RequestParam用来处理 <code>Content-Type</code> 为 <code>application/x-www-form-urlencoded</code> 编码的内容，<code>Content-Type</code>默认为该属性。</strong></p><p><strong>@RequestParam也可用于其它类型的请求，例如：GET、POST、DELETE等请求</strong>。比如向表中插入单条数据，<code>Controller</code> 层的写法如下图所示：</p><p>但是，这样不支持批量插入数据，相对之下，json来表达的优势就很明显，但是@RequestParam没办法处理<code>application/json</code>，点击发送的话，会报错后台接收不到值，为 <code>null</code>。</p><p>此时就需要使用对应的<code>@RequestBody</code>，它一般用于处理非 <code>Content-Type: application/x-www-form-urlencoded</code>编码格式的数据，比如：<code>application/json</code>、<code>application/xml</code>等类型的数据。就<code>application/json</code>类型的数据而言，使用注解@RequestBody可以将body里面所有的json数据传到后端，后端再进行解析。如<code>public Map&lt;String, Boolean&gt; saveBatchNovel(@RequestBody List&lt;NovelEntity&gt; novelEntityList)</code></p><p>此外，针对希望用户传入的为指定参数的话，有相应的Entity，使用@RequestBody会根据请求主体中的参数名与对象的属性名进行匹配并绑定值，自动将参数封装成该对象，并且还可以通过@Valid注解对请求主体中的参数进行校验。</p><p>总结：</p><ul><li><code>@RequestParam</code>的核心功能是<em>从URL中提取请求参数</em>，即接收的参数是来自HTTP请求头的QueryString中。</li><li><code>@RequestBody</code>功能是从请求体重提取参数，并封装成对象</li></ul><p>额外经验总结：</p><blockquote><p>标准协议下，通常认为GET请求是没有请求体的，只有POST请求有请求体</p></blockquote><ul><li><p>get请求只能传query参数，query参数都是拼在请求地址上的</p></li><li><p>post可以同时传body和query两种形式的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/post/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">postHello</span><span class="params">(@PathVariable Long id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         @RequestParam(value = <span class="string">"name"</span>, required = <span class="keyword">false</span>, defaultValue = <span class="string">"CL"</span>)</span> String name,</span></span><br><span class="line"><span class="function">                                         @RequestBody User user</span></span><br><span class="line"><span class="function">    ) </span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">"name"</span>, name);</span><br><span class="line">            put(<span class="string">"id"</span>, String.valueOf(id));</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>talent-API</p><p><img src="/2021/12/30/理解SpringBoot注解s/E:%5Chexo%5Csource_posts%5C%E7%90%86%E8%A7%A3SpringBoot%E6%B3%A8%E8%A7%A3s%5Cpost-query+body.png" alt="post-query+body"></p><p>postman-web</p><p><img src="/2021/12/30/理解SpringBoot注解s/E:%5Chexo%5Csource_posts%5C%E7%90%86%E8%A7%A3SpringBoot%E6%B3%A8%E8%A7%A3s%5Cpost+body+query2.png" alt="post+body+query2"></p><p>针对接口的测试，最好还是手动设置Content-type比较好</p></li></ul><p><strong>@PathVariable</strong></p><blockquote><p>承接上文，同样作为参数传入的还有@PathVariable，它可以从URL中提取变量</p></blockquote><p><code>@PathVariable</code>注解是将方法中的参数绑定到请求URI中的模板变量上。可以通过<code>@RequestMapping</code>注解来指定URI的模板变量，然后使用<code>@PathVariable</code>注解将方法中的参数绑定到模板变量上。特别地，<code>@PathVariable</code>注解允许我们使用value或name属性来给参数取一个别名。下面是使用此注解的一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/users/&#123;id&#125;/roles/&#123;roleId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Role <span class="title">getUserRole</span><span class="params">(@PathVariable <span class="keyword">long</span> id, @PathVariable <span class="keyword">long</span> roleId)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板变量名需要使用<code>{ }</code>进行包裹，如果方法的参数名与URI模板变量名一致，则在<code>@PathVariable</code>中就可以省略别名的定义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;reuqestbody和requestparam&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#reuqestbody和requestparam&quot;&gt;&lt;/a&gt; @ReuqestBody和@RequestParam&lt;/h2&gt;
&lt;p&gt;这两个注
      
    
    </summary>
    
    
      <category term="开发笔记" scheme="https://nymrli.top/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Spring中的Bean</title>
    <link href="https://nymrli.top/2021/12/30/Spring%E4%B8%AD%E7%9A%84Bean/"/>
    <id>https://nymrli.top/2021/12/30/Spring中的Bean/</id>
    <published>2021-12-30T02:46:34.000Z</published>
    <updated>2021-12-30T02:46:35.302Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringCloud笔记</title>
    <link href="https://nymrli.top/2021/12/29/SpringCloud%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2021/12/29/SpringCloud笔记/</id>
    <published>2021-12-29T15:14:51.000Z</published>
    <updated>2021-12-30T14:29:21.107Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔记内容大多来自：<a href="https://www.bilibili.com/video/BV18E411x7eT?p=8" target="_blank" rel="noopener">尚硅谷SpringCloud框架开发教程</a></p><p>跟做笔记：<a href="https://blog.csdn.net/MOKEXFDGH/article/details/107209899" target="_blank" rel="noopener">https://blog.csdn.net/MOKEXFDGH/article/details/107209899</a></p><p>跟做工程代码： <a href="https://github.com/liusCoding/springcloud-2020%E3%80%81https://gitee.com/exclusiver/springcloud2020" target="_blank" rel="noopener">https://github.com/liusCoding/springcloud-2020、https://gitee.com/exclusiver/springcloud2020</a></p></blockquote><h2 id="mvn配置"><a class="markdownIt-Anchor" href="#mvn配置"></a> <strong>MVN配置</strong></h2><ul><li><p>每个module的pom配置文件中最重要的三个：GAV即 <code>groupId</code>、<code>artifactId</code>、<code>version</code></p></li><li><p>dependencyManagement声明依赖的版本，可以起到作用：</p><ul><li><ol><li>约定依赖的统一版本</li><li>子module不用写groupId和version</li></ol><p>注：dependencyManagement只是声明了依赖的约定，但是在子模块中确定要使用这个依赖时，还是需要dependency指出，即dependencyManagement只是<strong>声明</strong>，并没有实际引入。此外，如果子模块想要摆脱约定版本的话，可以通过特别列出version从而指定版本</p></li></ul></li></ul><h2 id="业务开发流程"><a class="markdownIt-Anchor" href="#业务开发流程"></a> <strong>业务开发流程</strong></h2><ol><li>建表SQL</li><li>Entities</li><li>Dao</li><li>Service</li><li>Controller</li></ol><p>创建mysql数据库：</p><ol><li>通过图形界面——字符集选 utf8,  排序规则选  utf8_general_ci</li><li>通过SQL</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span>  <span class="string">`wordpress`</span> <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span>  <span class="string">`wordpress`</span> <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><h2 id="请求模拟"><a class="markdownIt-Anchor" href="#请求模拟"></a> <strong>请求模拟</strong></h2><ul><li>浏览器对POST支持不太友好，需要使用如PostMan等工具：浏览器输入<code>http://localhost:8001/create?serial=23</code>，一旦戴上了这个<code>?xxx=yyy</code>的请求参数，则会被认为是Get请求</li></ul><h2 id="注解使用"><a class="markdownIt-Anchor" href="#注解使用"></a> <strong>注解使用</strong></h2><ul><li><code>@mapper</code>对应<code>@Resource</code>(javax.annotation)</li><li><code>@Repository</code>对应<code>@Autowired</code></li></ul><p>在Dao层定义时，推荐使用<code>@Mapper</code>(apache.ibatis)，而不是<code>@Repository</code>(org.springframework.stereotype)，因为后者在插入的时候可能会有问题</p><h2 id="添加热部署"><a class="markdownIt-Anchor" href="#添加热部署"></a> 添加热部署</h2><ol><li><p>添加devtools依赖到工程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在pom中指定添加插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>enabling automatic build</p><p><img src="/2021/12/29/SpringCloud笔记/E:%5Chexo%5Csource_posts%5CSpringCloud%E7%AC%94%E8%AE%B0%5C%E7%83%AD%E9%83%A8%E7%BD%B2%E8%AE%BE%E7%BD%AE.png" alt="热部署设置"></p></li><li><p>修改&quot;Updating Registrer&quot; （通过在pom文件中<code>ctrl+shift+alt+/</code>按出maintenance）==&gt;IDEA2021中不需要设置了</p></li><li><p>重启IDEA</p></li></ol><p>注：上述只是重启，Jrebel才是真正意义上的热部署</p><h2 id="resttemplate"><a class="markdownIt-Anchor" href="#resttemplate"></a> RestTemplate</h2><blockquote><p>Java中调用第三方的接口API时，是通过HttpClient库来创建请求的；而对于通过基于Http的Restful微服务接口，Springboot提供了一套方法: RestTemplate</p></blockquote><p>RestTemplatej提供了多种便捷访问远程Http服务的方法，是—种简单便捷的访问 restful服务模板类，是 Spring提供的用于访问<strong>Rest服务的客户端</strong>模板工具集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PAYMENT_URL = <span class="string">"http://localhost:8001"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/consumer/payment/create"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">create</span><span class="params">(Payment payment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL + <span class="string">"/payment/create"</span>, payment, CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于postForObject会以 application/json的形式发送数据, 所以在Payment系统的接口中如果不加上 @RequestBody 的话，则无法封装成相应的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/create"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">create</span><span class="params">(@RequestBody  Payment payment)</span> </span>&#123;<span class="comment">// 加上@RequestBody注解</span></span><br><span class="line">        <span class="keyword">int</span> result = paymentService.create(payment);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="注册中心"><a class="markdownIt-Anchor" href="#注册中心"></a> 注册中心</h2><ul><li>服务注册:将服务信息注册进注册中心</li><li>服务发现:从注册中心上获取服务信息实质:存key服务命取value调用地址</li></ul><h2 id="eureka环境搭建"><a class="markdownIt-Anchor" href="#eureka环境搭建"></a> eureka环境搭建</h2><h3 id="服务端server"><a class="markdownIt-Anchor" href="#服务端server"></a> 服务端server</h3><ol><li>创建相应的工程或者module</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--eureka-server--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--eureka-server--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写yml</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 表示不向注册中心注册自己</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 自己就是注册中心，职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><ol start="3"><li>给application加上EnableEurekaServer自动注入的注解，并表明是eureka服务端</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MrLi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-12-30 16:46</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaMain7001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaMain7001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端client"><a class="markdownIt-Anchor" href="#客户端client"></a> 客户端client</h3><blockquote><p>虽然叫客户端，但其实是相对于eureka服务而言的，对于暴露的rpc服务来看，他是接口服务的服务端</p></blockquote><ol><li><p>加pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>增加yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 表示不向注册中心注册自己, 默认为true</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否从EurekaServer抓取已有的注册信息，默认为true；单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line">      <span class="comment"># 设置于eurekaServer交互的地址查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure></li><li><p>applicaiton上加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain8001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务运行在 http://localhost:8001/"</span>);</span><br><span class="line">        SpringApplication.run(PaymentMain8001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>为了防止单点故障的问题，这边可以增加一个EurekaServer的实例，从而组成EurekaServer集群，相互注册相互守望。</p><h3 id="集群搭建"><a class="markdownIt-Anchor" href="#集群搭建"></a> 集群搭建</h3><ol><li>先启动eureka注册中心</li><li>启动服务提供者: payment支付服务</li><li>支付服务启动后会把自身信息(比服务地址以<strong>别名</strong>方式注册进eureka)</li><li>消费者order服务在需要调用接口时,使用<strong>服务别名</strong>去注册中心获取实际的RPC远程调用<strong>地址</strong></li><li>消费者获得调用地址后,底层实际是利用<strong>HttpClient</strong>术实现远程调用</li><li>消费者获得服务地址后会缓存在本地jvm内存中,默认<em>每间隔30秒</em>更新一次服务调用地址</li></ol><blockquote><p>问题:微服务RPC远程服务调用最核心的是什么？</p><p>A: 高可用,试想你的注册中心只有一个ohly one,它出故障了那就呵呵了,这会导致整个为服务环境不可用。 所以解决办法:搭建Eureka注册中心集群,实现负载均衡+故障容错</p></blockquote><ol><li><p>创建多个eureka实例工程or模块</p></li><li><p>修改hosts映射文件: C:\Windows\System32\drivers\etc\HOSTS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1 eureka7001.com</span><br><span class="line">127.0.0.1 eureka7002.com</span><br></pre></td></tr></table></figure><p>虽然eureka7001.com和eureka7002.com都指向的是localhost，真正区分服务的是通过后面的port。但仍然这么做的目的是模拟真实情况，不然都是localhost的话对用户而言不好区分。</p></li><li><p>修改yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">7002</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">eureka7002.com</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 表示不向注册中心注册自己</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 自己就是注册中心，职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line">      <span class="comment"># 7001指向7002（即在7002中注册了7001的地址）</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://eureka7001.com:7001/eureka/</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">eureka7001.com</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 表示不向注册中心注册自己</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 自己就是注册中心，职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure><p>两个server相互存了对方的地址，相互守望从而实现高可用</p></li></ol><p>同时运行两个application，然后输入localhost:7001，可以看到页面中DS Replicas显示有7002，打开localhost:7002同样能看到7001的DS Replicas即镜像</p><h4 id="服务接入集群"><a class="markdownIt-Anchor" href="#服务接入集群"></a> 服务接入集群</h4><p>修改配置文件，主要是把集群中的地址全部填上</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 表示不向注册中心注册自己, 默认为true</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否从EurekaServer抓取已有的注册信息，默认为true；单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://eureka7001.com:7001/eureka,</span> <span class="attr">http://eureka7002.com:7002/eureka</span></span><br></pre></td></tr></table></figure><h3 id="服务负载均衡"><a class="markdownIt-Anchor" href="#服务负载均衡"></a> 服务负载均衡</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;笔记内容大多来自：&lt;a href=&quot;https://www.bilibili.com/video/BV18E411x7eT?p=8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;尚硅谷SpringCloud框架开发教程&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
      <category term="开发笔记" scheme="https://nymrli.top/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用七牛云作图床+PicGo</title>
    <link href="https://nymrli.top/2021/12/29/%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E4%BD%9C%E5%9B%BE%E5%BA%8A-PicGo/"/>
    <id>https://nymrli.top/2021/12/29/使用七牛云作图床-PicGo/</id>
    <published>2021-12-29T13:48:37.000Z</published>
    <updated>2021-12-29T14:12:11.451Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自己在写博客的时候，通过图片来表达自己的思路无疑是种非常有效的方法，平常我的笔记都是通过hexo生成的，因此保存在本地路径即可。但是如果想把文章发表在第三方的平台上，那么这些相对路径的图片在上传过程中就无法被检索，因此如果能在一个大家都能访问到的地方存放这些图片，再给出这些地方的链接时那就解决了这个问题。要达到这个需求，则就需要使用OSS对象存储服务。</p><p>这边我推荐的是七牛云。七牛云在注册认证后有10G永久免费空间，每月10G国内和10G国外流量，速度相当快，七牛云是国内专业CDN服务商，插件支持比较多，有免费SSL证书，但https流量收费。同时七牛云还会提供30天的测试域名，不过要注意的一点是，七牛云30天后会回收测试域名，并且通过测试域名存储的文件会在30天后一起被杀出，因此最好还是要绑定自己的已备案的域名。</p></blockquote><h1 id="七牛云"><a class="markdownIt-Anchor" href="#七牛云"></a> <a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云</a>创建与配置</h1><h2 id="创建空间"><a class="markdownIt-Anchor" href="#创建空间"></a> 创建空间</h2><p>可以根据自己的需求来新建自己的存储空间，点击【新建空间】，对空间进行配置，这里要注意，以下几点：</p><ul><li>存储空间名称不能重复，我这里也新建一个名称为：onestar-blog-img</li><li>存储区域选择一个离你近点的，我选的是华东，每个地点有个编号的，后面要用来配置PicGo，这里先说一下区域对应编号: 华东：z0；华北：z1；华南：z2：北美：na0：东南亚：as0</li><li>访问控制选择公开，因为要作为外链进行访问</li></ul><p><img src="/2021/12/29/使用七牛云作图床-PicGo/%E5%88%9B%E5%BB%BA%E7%A9%BA%E9%97%B4.png" alt="创建空间"></p><p><img src="/2021/12/29/使用七牛云作图床-PicGo/%E5%88%9B%E5%BB%BA%E6%88%90%E5%8A%9F.png" alt="创建成功"></p><h2 id="配置域名并绑定"><a class="markdownIt-Anchor" href="#配置域名并绑定"></a> 配置域名并绑定</h2><ol><li>点击&quot;+绑定域名&quot;按钮</li></ol><p><img src="/2021/12/29/使用七牛云作图床-PicGo/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D.png" alt="绑定域名"></p><p>2.就会进入如下的添加域名页面，需要做的就是填入一个三级域名，如我申请的二级域名为nymrli.top，那么这边我可以写<code>xxx.nymrli.top</code>，这个xxx就是nymrli.top下的子域名，但是这个毕竟是我们临时想出来的，因此要让他生效的话，我们还需要在DNS服务商那边进行配置。</p><p><img src="/2021/12/29/使用七牛云作图床-PicGo/%E6%B7%BB%E5%8A%A0%E5%9F%9F%E5%90%8D.png" alt="添加域名"></p><p><img src="/2021/12/29/使用七牛云作图床-PicGo/%E7%82%B9%E5%87%BB%E9%85%8D%E7%BD%AECname.png" alt="点击配置Cname"></p><ol start="3"><li>接下来开始配置CNAME解析，由于我的域名解析是在阿里云做的，因此需要到阿里云的域名管理控制台添加这个CNAME的解析</li></ol><p><img src="/2021/12/29/使用七牛云作图床-PicGo/DNS%E8%AE%B0%E5%BD%95.png" alt="DNS记录"></p><p>添加好CNAME记录后等待一会让其生效后，就能到七牛云的“域名管理”页面查看状态啦，如下所示，这边的“状态”显示成功了</p><p><img src="/2021/12/29/使用七牛云作图床-PicGo/%E6%9F%A5%E7%9C%8B%E5%9F%9F%E5%90%8D%E6%98%AF%E5%90%A6%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F%E6%88%90%E5%8A%9F.png" alt="查看域名是否配置成功成功"></p><h1 id="picgo图床软件"><a class="markdownIt-Anchor" href="#picgo图床软件"></a> <a href="https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.0" target="_blank" rel="noopener">Picgo图床软件</a>配置</h1><p>自带免费的SM.MS图床配置，可以直接使用。但是用别人的配置，占别人的资源毕竟不太好，容易超额，而且安全性也不高。因此配置自己的存储API，这边使用上述配置好的七牛云。</p><p><img src="/2021/12/29/使用七牛云作图床-PicGo/picgo%E9%85%8D%E7%BD%AE.png" alt="picgo配置"></p><ul><li>accessKey和SecretKey可以点击头像到“个人中心”去查看并复制进去</li><li>存储空间名就是一开始创建空间的名字</li><li>网址的话就是自己绑定的三级域名</li><li>这边比较容易填错的是存储区域，对应的其实是华南、华东……但需要填编号，这边编号关系如下：<ul><li>z0；华北：z1；华南：z2：北美：na0：东南亚：as0</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;自己在写博客的时候，通过图片来表达自己的思路无疑是种非常有效的方法，平常我的笔记都是通过hexo生成的，因此保存在本地路径即可。但是如果想把文章发表在第三方的平台上，那么这些相对路径的图片在上传过程中就无法被检索，因此如果能在一个大家都能访问到的地
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go的进阶学习</title>
    <link href="https://nymrli.top/2021/12/29/Go%E7%9A%84%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/"/>
    <id>https://nymrli.top/2021/12/29/Go的进阶学习/</id>
    <published>2021-12-29T08:15:07.000Z</published>
    <updated>2021-12-29T15:53:41.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="go中通过组合方式实现的伪继承"><a class="markdownIt-Anchor" href="#go中通过组合方式实现的伪继承"></a> GO中通过组合方式实现的伪继承</h2><blockquote><p>说到继承我们都知道，也可以了解到在Go中是没有<code>extends</code>关键字的，也就意味着Go并没有原生级别的继承支持。这也是为什么用了<strong>伪继承</strong>这个词。本质上，Go使用interface实现的功能叫组合，Go是通过组合(+匿名字段的技术)来实现的继承，说的更精确一点，是使用组合来代替继承</p></blockquote><p>我们用很容易理解的<strong>动物</strong>-<strong>猫</strong>来举例子，废话不多说，直接看代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span> <span class="title">Eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%v is eating"</span>, a.Name)</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    *Animal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cat := &amp;Cat&#123;</span><br><span class="line">    Animal: &amp;Animal&#123;</span><br><span class="line">        Name: <span class="string">"cat"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">cat.Eat() <span class="comment">// cat is eating</span></span><br></pre></td></tr></table></figure><p><strong>代码分析</strong></p><p>首先，我们实现了一个Animal的结构体，代表动物类。并声明了Name字段，用于描述动物的名字。然后，实现了一个以Animal为receiver的Eat方法，来描述动物进食的行为。最后，声明了一个Cat结构体，组合了Cat字段。再实例化一个猫，调用Eat方法，可以看到会正常的输出。</p><p>可以看到，Cat结构体本身没有Name字段，也没有去实现Eat方法。唯一有的就是组合了Animal父类，至此，我们就证明了已经通过组合实现了继承。</p><p><strong>将接口优雅简明化</strong></p><blockquote><p>接口用于描述某个类的行为。对于一个接口的使用者而言，我需要在拿到这个接口的同时能一目了然的知道这个类干了什么，有哪些方法可以调用，因此上面的写法我们并不能从中看出Animal具体有哪些功能，因此，我们可以创建一个说明它功能方法的父接口。</p><p>例如，我们即将要抽象的动物接口就会描述作为一个动物，具有哪些行为。常识告诉我们，动物可以进食（Eat），可以发出声音（bark），可以移动（move）等等。这里有一个很有意思的类比。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟动物行为的接口</span></span><br><span class="line"><span class="keyword">type</span> IAnimal <span class="keyword">interface</span> &#123;</span><br><span class="line">    Eat() <span class="comment">// 描述吃的行为</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动物 所有动物的父类</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动物去实现IAnimal中描述的吃的接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span> <span class="title">Eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%v is eating\n"</span>, a.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动物的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newAnimal</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Animal</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Animal&#123;</span><br><span class="line">        Name: name,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫的结构体 组合了animal</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    *Animal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现猫的构造函数 初始化animal结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCat</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Cat</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Cat&#123;</span><br><span class="line">        Animal: newAnimal(name),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cat := newCat(<span class="string">"cat"</span>)</span><br><span class="line">cat.Eat() <span class="comment">// cat is eating</span></span><br></pre></td></tr></table></figure><h2 id="函数形参问题"><a class="markdownIt-Anchor" href="#函数形参问题"></a> 函数形参问题</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">c := newContext(w, req)</span><br><span class="line">c.handlers = middlewares</span><br><span class="line">c.engine = engine</span><br><span class="line">engine.router.handle(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和 http ServerHTTP 函数原始的两个参数对应 req 和 writer。req 是结构体，用指针可以节省内存，Writer 是一个接口类型，不能用指针。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;go中通过组合方式实现的伪继承&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#go中通过组合方式实现的伪继承&quot;&gt;&lt;/a&gt; GO中通过组合方式实现的伪继承&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;说到继承我们都知道，也可以了解到在Go中
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>开发方向-技术栈</title>
    <link href="https://nymrli.top/2021/12/28/%E5%BC%80%E5%8F%91%E6%96%B9%E5%90%91-%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <id>https://nymrli.top/2021/12/28/开发方向-技术栈/</id>
    <published>2021-12-28T13:02:43.000Z</published>
    <updated>2021-12-28T16:10:43.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cloud-微服务全家桶"><a class="markdownIt-Anchor" href="#cloud-微服务全家桶"></a> Cloud 微服务全家桶</h1><blockquote><p>微服务开发的主流技术栈</p></blockquote><ul><li>服务注册中心<ul><li>:error:eureka 停止更新</li><li>❌consul</li><li>zookeeper</li><li>⭐️nacos</li></ul></li><li>服务负载与调用<ul><li>❌ netflix oss ribbon ==&gt; spring cloud loadbalance</li><li>netflix feign ==&gt; Spring cloud OpenFeign</li></ul></li><li>容量限流(熔断)<ul><li>❌hystrix: 最先的老大哥</li><li>resilience4j：国外使用较多</li><li>⭐️spring cloud alibaba sentinel</li></ul></li><li>配置中心<ul><li>❌spring cloud config</li><li>携程: apollo</li><li>spring cloud alibaba nacos</li></ul></li><li>服务开发<ul><li>spring boot</li></ul></li><li>流量监控</li><li>服务总线:<ul><li>❌spring cloud bus</li><li>spring cloud alibaba nacos</li></ul></li><li>服务治理</li><li>链路追踪<ul><li>spring cloud sleuth</li></ul></li><li>服务网关<ul><li>❌(netflix) zuul</li><li>zuul2: 胎死腹中</li><li>⭐️spring cloud gateway</li></ul></li><li>matrics（指标）监控：<ul><li>kairosDB</li></ul></li><li>日志监控：<ul><li>ELK</li></ul></li><li>健康检查和告警：<ul><li>zalando</li><li>zmon</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cloud-微服务全家桶&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cloud-微服务全家桶&quot;&gt;&lt;/a&gt; Cloud 微服务全家桶&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;微服务开发的主流技术栈&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
    
      <category term="开发" scheme="https://nymrli.top/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin集合、流式操作</title>
    <link href="https://nymrli.top/2021/12/27/Kotlin%E9%9B%86%E5%90%88%E3%80%81%E6%B5%81%E5%BC%8F%E6%93%8D%E4%BD%9C/"/>
    <id>https://nymrli.top/2021/12/27/Kotlin集合、流式操作/</id>
    <published>2021-12-27T03:14:40.000Z</published>
    <updated>2022-01-03T13:36:36.222Z</updated>
    
    <content type="html"><![CDATA[<p>除了最通用的Array以外，kotlin中还有一类容器统称为Colletion(集合)，他们有</p><ul><li>List<ul><li><strong>List</strong>：继承Collection。一个范性有序的只读集合。因为有序，所以，我们可以使用get(position)等查询的方法</li><li><strong>MutableList</strong>：继承List，MutableCollection。一个有序集合。并额外提供了add/remove元素的方法</li></ul></li><li>Set<ul><li><strong>Set</strong>：继承Collection。一个无序并不支持重复元素的集合</li><li><strong>MutableSet</strong>：继承Set，MutableCollection，一个无序的集合并且不支持重复元素。但是，支持add/remove元素</li></ul></li><li>Map<ul><li><strong>Map</strong>：一个key-value的只读集合。并且key唯一。</li><li><strong>MutableMap</strong>：继承Map。支持put/remove元素</li></ul></li></ul><h1 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h1><ul><li><p><strong>any</strong>：如果至少有一个元素与判断条件相符，则 返回true</p></li><li><p><strong>all</strong>：如果全部元素与判断条件相符，则 返回true</p></li><li><p><strong>component1,…,component5</strong>：返回集合的第n个元素，越界返回ArrayIndexOutOfBoundsException</p></li><li><p><strong>contain</strong>：如果指定元素可以在集合找到，则 返回true</p></li><li><p><strong>containsAll</strong>：如果指定集合所有元素都可以在目标集合找到，则 返回true</p></li><li><p><strong>count</strong>：返回与判断条件相符的元素个数</p></li><li><p><strong>distinct</strong>：返回一个只包含不同元素的数组，即对列表内元素去重</p></li><li><p><strong>distinctBy</strong>：返回集合元素<strong>执行指定条件后</strong>，不同元素的数组（原始数组元素）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">1</span>,<span class="number">4</span>),list.distinctBy &#123; it%<span class="number">2</span> == <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>drop</strong>：返回所有元素的列表，但不包含前n个元素</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">3</span>,<span class="number">4</span>),list.drop(<span class="number">2</span>))</span><br></pre></td></tr></table></figure></li><li><p><strong>dropLast</strong>：返回所有元素的列表，但不包含最后n个元素</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">1</span>,<span class="number">2</span>),list.dropLast(<span class="number">2</span>))</span><br></pre></td></tr></table></figure></li><li><p><strong>dropWhile</strong>：返回所有元素的列表，但不包含满足判断条件的元素</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),list.dropWhile&#123;it &lt;<span class="number">3</span>&#125;)</span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">3</span>,<span class="number">4</span>),list.dropWhile&#123;it &lt;<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>elementAt</strong>：返回指定索引的元素，如果索引越界，则抛出ArrayIndexOutOfBoundsException</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="number">4</span>,list.elementAt(<span class="number">3</span>))</span><br><span class="line"><span class="comment">// elementAtOrElse：返回指定索引的元素，如果索引越界，则返回指定的默认值</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="number">18</span>,list.elementAtOrElse(<span class="number">6</span>,&#123;it *<span class="number">3</span>&#125;))</span><br><span class="line"><span class="comment">// elementAtOrNull: 返回指定索引的元素，如果索引越界，则返回null</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="literal">null</span>,list.elementAtOrNull(<span class="number">6</span>))</span><br></pre></td></tr></table></figure></li><li><p><strong>filter</strong>:筛选出所有符合条件的元素</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">2</span>,<span class="number">3</span>),list.filter&#123; it <span class="keyword">in</span> <span class="number">2.</span><span class="number">.3</span> &#125;)</span><br><span class="line">filterIndexed</span><br><span class="line"><span class="comment">// filterIndexed筛选出所有符合条件的元素（条件多了一个索引参数）</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">4</span>),list.filterIndexed &#123; index, it -&gt; index&gt;<span class="number">0</span> &amp;&amp; it &gt;<span class="number">2</span>&#125; )</span><br><span class="line"><span class="comment">// filterNot: 筛选出所有不符合条件的元素</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">1</span>,<span class="number">4</span>),list.filterNot&#123; it <span class="keyword">in</span> <span class="number">2.</span><span class="number">.3</span> &#125;)</span><br><span class="line">filterNotNull</span><br><span class="line"><span class="comment">// filterNotNull: 筛选出所有不为null的元素</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),list.filterNotNull())</span><br></pre></td></tr></table></figure></li><li><p><strong>first</strong></p><p>返回第一个满足条件的元素,没有则抛出NoSuchElementException</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="number">2</span>,list.first &#123; it &gt; <span class="number">1</span> &#125;)</span><br><span class="line"><span class="comment">// firstOrNull: 返回第一个满足条件的元素，没有，则 返回Null</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="literal">null</span>, list.firstOrNull &#123; it &gt; <span class="number">5</span> &#125;)</span><br><span class="line"><span class="comment">// find :同firstOrNull。返回第一个满足条件的元素，没有，则 返回Null</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="number">2</span>,list.find &#123; it &gt; <span class="number">1</span> &#125;)</span><br><span class="line"><span class="comment">// findLast: 返回最后一个满足条件的元素，没有，则 返回Null</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="number">4</span>,list.findLast &#123; it &gt; <span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// last: 返回符合给定函数条件的最后一个元素，不存在则抛出NoSuchElementException</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="number">4</span>, list.last &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// lastIndexOf: 返回指定元素的第一个索引位置，不存在返回-1</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="number">2</span>, list.lastIndexOf(<span class="number">2</span>) )</span><br><span class="line"><span class="comment">// lastOrNull: 返回符合给定函数条件的最后一个元素，不存在返回null</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">assertNull( list.lastOrNull&#123; it &gt;<span class="number">5</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>single</strong>: 返回符合指定函数条件的单个元素，如果没有符合或者超过一个，则抛出异常。\</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="number">4</span>, list.single &#123; it == <span class="number">4</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// singleOrNull: 返回符合指定函数条件的单个元素，如果没有符合或者超过一个，则返回null</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="literal">null</span>, list.singleOrNull &#123; it == <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>flatMap</strong>: 遍历所有的元素，为每一个元素创建一个集合，最后把所有的集合放在<em>一个集合</em>中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>),list.flatMap &#123; it -&gt; listOf(it,it*<span class="number">2</span>) &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>flatten</strong>: 遍历一个单独的集合，包含给定嵌套集合里面的所有元素。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(listOf(<span class="number">1</span>,<span class="number">2</span>), listOf(<span class="number">4</span>,<span class="number">2</span>), listOf(<span class="number">3</span>), listOf(<span class="number">4</span>))</span><br><span class="line">assertEquals(listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), list.flatten())</span><br></pre></td></tr></table></figure></li><li><p><strong>fold</strong>： 将对集合从第一个到最后一个元素进行操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里是进行乘法操作</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="number">48</span>, list.fold(<span class="number">2</span>) &#123; total, next -&gt; total * next &#125;)</span><br><span class="line"><span class="comment">// foldRight: 跟fold操作一样，不过是从最后一个到到一个元素进行操作</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="number">48</span>, list.foldRight(<span class="number">2</span>) &#123; total, next -&gt; total * next &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>reduce</strong>： 与fold功能一样。但是，没有初始值。把集合从第一个到最后一个，按指定条件进行操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="number">-7</span>, list.reduce &#123; total, next -&gt; total -next &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>get</strong>:获取索引所在的元素，没有则返回ArrayIndexOutOfBoundsException</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getOrElse: 获取索引所在的元素，没有就返回默认值</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="number">10</span>, list.getOrElse(<span class="number">8</span>, &#123; _ -&gt; <span class="number">10</span> &#125;))</span><br><span class="line">assertEquals(<span class="number">2</span>, list.getOrElse(<span class="number">1</span>, &#123; _ -&gt; <span class="number">10</span> &#125;))</span><br><span class="line"><span class="comment">// getOrNull: 获取索引所在的元素，没有就返回nul</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="literal">null</span>, list.getOrNull(<span class="number">8</span>))</span><br><span class="line">assertEquals(<span class="number">4</span>, list.getOrNull(<span class="number">2</span>))</span><br></pre></td></tr></table></figure></li><li><p><strong>map</strong>： 返回一个每个元素都根据给定函数条件转换的数组</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">8</span>), list.map&#123; it*<span class="number">2</span>&#125; )</span><br><span class="line"><span class="comment">// mapIndexed: 功能同map，比map多了一个索引</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>), list.mapIndexed &#123; index, it -&gt; <span class="keyword">if</span> (index % <span class="number">2</span> == <span class="number">0</span>) index * it <span class="keyword">else</span> it &#125;)</span><br><span class="line"><span class="comment">// mapNotNull: 同map。但是，元素转换不包含Null</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>,<span class="literal">null</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">8</span>), list.mapNotNull &#123; it?.times(<span class="number">2</span>) &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>max</strong>: 返回集合最大元素。不存在返回null</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="number">4</span>, list.max())</span><br><span class="line"><span class="keyword">val</span> list = emptyList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">assertEquals(<span class="literal">null</span>, list.max())</span><br><span class="line"></span><br><span class="line"><span class="comment">// maxBy:返回根据指定函数转换后，产生的最大值的原始元素（返回的还是原始元素）。如果没有元素，则返回null。</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="number">1</span>, list.maxBy &#123; -it &#125;)</span><br><span class="line"><span class="comment">// min:返回集合最小元素，不存在返回null</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="number">1</span>, list.min())</span><br><span class="line"><span class="comment">// minBy: 返回根据指定函数转换后，产生的最小值的原始元素（返回的还是原始元素）。如果没有元素，则返回null。</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">assertEquals(<span class="number">4</span>, list.minBy &#123; -it &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>none</strong>： 如果没有任何元素与指定的函数条件匹配，则返回true。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">assertTrue(list.none &#123; it &gt; <span class="number">4</span> &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>orEmpty</strong>： 如果没有任何元素与指定的函数条件匹配，则返回true。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">assertTrue(list.none &#123; it &gt; <span class="number">4</span> &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>sorted</strong>：返回所有元素分类排序列表。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>), list.sorted())</span><br><span class="line"></span><br><span class="line"><span class="comment">// sortBy:返回所有元素分类排序列表。顺序按照指定函数条件排列</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>), list.sortedBy &#123; -it &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// sortDescending:返回所有元素分类排序列表。顺序按降序排列</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>), list.sortedDescending())</span><br><span class="line"></span><br><span class="line"><span class="comment">// sortedByDescending:返回所有元素分类排序列表。顺序按指定函数条件的降序排列</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>), list.sortedByDescending&#123; -it &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>slice</strong>: 返回一个list中指定index的元素。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>), list.slice(<span class="number">1.</span><span class="number">.3</span>))</span><br><span class="line">assertEquals(listOf(<span class="number">1</span>,<span class="number">4</span>), list.slice(listOf(<span class="number">0</span>,<span class="number">1</span>)))</span><br></pre></td></tr></table></figure></li><li><p><strong>take</strong>: 返回从第一个元素开始的n个元素。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">assertEquals(listOf(<span class="number">1</span>,<span class="number">4</span>), list.take(<span class="number">2</span>))</span><br></pre></td></tr></table></figure></li><li><p><strong>zip</strong>: 返回一个列表，该列表由两个集合中相同索引元素建立的元素对。这个列表长度为最短集合的长度。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val list = listOf(1, 4, 2, 2)</span><br><span class="line">assertEquals(listOf(Pair(1,10),Pair(4,20),Pair(2,30)), list.zip(listOf(10,20,30)))</span><br></pre></td></tr></table></figure><ul><li><p><strong>groupBy</strong></p><p>返回一个根据给定函数分组后的map， value为list</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">assertEquals(mapOf(<span class="string">"error"</span> to listOf(<span class="number">1</span>), <span class="string">"right"</span> to listOf(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)), list.groupBy &#123; <span class="keyword">if</span> (it % <span class="number">2</span> == <span class="number">0</span>) <span class="string">"right"</span> <span class="keyword">else</span> <span class="string">"error"</span> &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>associateBy</strong></p><p>通过指定的条件，把list转换成map，value为单元素</p><p>2种，第一只转换map的key;第二map的key-value都转换</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">assertEquals(hashMapOf(<span class="string">"key1"</span> to <span class="number">1</span>, <span class="string">"key4"</span> to <span class="number">4</span>, <span class="string">"key2"</span> to <span class="number">2</span>), list.associateBy &#123; it -&gt; <span class="string">"key"</span> + it &#125;)</span><br><span class="line">assertEquals(hashMapOf(<span class="string">"key1"</span> to <span class="string">"value1"</span>, <span class="string">"key4"</span> to <span class="string">"value4"</span>, <span class="string">"key2"</span> to <span class="string">"value2"</span>), list.associateBy(&#123; it -&gt; <span class="string">"key"</span> + it &#125;, &#123; it -&gt; <span class="string">"value"</span> + it &#125;))</span><br></pre></td></tr></table></figure></li></ul><h2 id="associateby和groupby区别"><a class="markdownIt-Anchor" href="#associateby和groupby区别"></a> associateBy和groupBy区别</h2><blockquote><p>函数associateBy和groupBy构建来自由指定键索引的集合的元素的映射。key在keySelector参数中定义。</p><p>还可以指定可选的valueSelector来再选择定义将存储在map元素值中的内容。</p></blockquote><p><strong>区别</strong></p><p>associateBy和groupBy之间的区别在于它们如何使用相同的键处理对象：</p><ul><li>associateBy使用<strong>最后一个合适的<em>元素</em></strong>作为<strong>值</strong>。</li><li>groupBy构建<strong>所有合适元素的<em>列表</em></strong>并将其放入<strong>值</strong>中。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamPractise</span></span>(</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> l = listOf(StreamPractise(<span class="number">1</span>, <span class="string">"hello"</span>, <span class="number">19</span>), StreamPractise(<span class="number">1</span>, <span class="string">"cl"</span>, <span class="number">31</span>))</span><br><span class="line">    <span class="keyword">var</span> res = l.associateBy &#123;  it.id &#125;</span><br><span class="line">    println(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;1=StreamPractise(id=1, name=cl, age=31)&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> l = listOf(StreamPractise(<span class="number">1</span>, <span class="string">"hello"</span>, <span class="number">19</span>), StreamPractise(<span class="number">1</span>, <span class="string">"cl"</span>, <span class="number">31</span>))</span><br><span class="line">    <span class="keyword">var</span> res = l.groupBy &#123;  it.id &#125;</span><br><span class="line">    println(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;1=[StreamPractise(id=1, name=hello, age=19), StreamPractise(id=1, name=cl, age=31)]&#125;</span></span><br></pre></td></tr></table></figure><h1 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h1><ul><li><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fkotlinlang.org%2Fapi%2Flatest%2Fjvm%2Fstdlib%2Fkotlin.collections%2Fget-or-else.html" target="_blank" rel="noopener"><code>getOrElse()</code></a> 与 list 的工作方式相同：对于不存在的键，其值由给定的 lambda 表达式返回。</p></li><li><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fkotlinlang.org%2Fapi%2Flatest%2Fjvm%2Fstdlib%2Fkotlin.collections%2Fget-or-default.html" target="_blank" rel="noopener"><code>getOrDefault()</code></a> 如果找不到键，则返回指定的默认值。</p></li><li><p><code>filter</code>: 可以使用 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fkotlinlang.org%2Fapi%2Flatest%2Fjvm%2Fstdlib%2Fkotlin.collections%2Ffilter.html" target="_blank" rel="noopener"><code>filter()</code></a> 函数来<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.kotlincn.net%2Fdocs%2Freference%2Fcollection-filtering.html" target="_blank" rel="noopener">过滤</a> map 或其他集合。 对 map 使用 <code>filter()</code> 函数时， <code>Pair</code> 将作为参数的谓词传递给它。 它将使用谓词同时过滤其中的键和值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbersMap = mapOf(<span class="string">"key1"</span> to <span class="number">1</span>, <span class="string">"key2"</span> to <span class="number">2</span>, <span class="string">"key3"</span> to <span class="number">3</span>, <span class="string">"key11"</span> to <span class="number">11</span>)</span><br><span class="line">val filteredMap = numbersMap.filter &#123; (key, <span class="keyword">value</span>) -&gt; key.endsWith(<span class="string">"1"</span>) &amp;&amp; <span class="keyword">value</span> &gt; <span class="number">10</span>&#125;</span><br><span class="line">println(filteredMap)</span><br></pre></td></tr></table></figure></li><li><p><code>put()</code>添加新的kv</p></li><li><p><code>putAll()</code>要一次添加多个条目，请使用 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fkotlinlang.org%2Fapi%2Flatest%2Fjvm%2Fstdlib%2Fkotlin.collections%2Fput-all.html" target="_blank" rel="noopener"><code>putAll()</code></a> 。它的参数可以是 <code>Map</code> 或一组 <code>Pair</code> ： <code>Iterable</code> 、 <code>Sequence</code>或 <code>Array</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbersMap = mutableMapOf(<span class="string">"one"</span> to <span class="number">1</span>, <span class="string">"two"</span> to <span class="number">2</span>, <span class="string">"three"</span> to <span class="number">3</span>)</span><br><span class="line">numbersMap.putAll(setOf(<span class="string">"four"</span> to <span class="number">4</span>, <span class="string">"five"</span> to <span class="number">5</span>))</span><br><span class="line"><span class="built_in">println</span>(numbersMap)</span><br></pre></td></tr></table></figure><ul><li><code>remove</code>: 要从可变 Map 中删除条目，请使用 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fkotlinlang.org%2Fapi%2Flatest%2Fjvm%2Fstdlib%2Fkotlin.collections%2F-mutable-map%2Fremove.html" target="_blank" rel="noopener"><code>remove()</code></a> 函数。 调用 <code>remove()</code> 时，可以传递键或整个键值对。 如果同时指定键和值，则仅当键值都匹配时，才会删除此的元素。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val numbersMap = mutableMapOf(<span class="string">"one"</span> to <span class="number">1</span>, <span class="string">"two"</span> to <span class="number">2</span>, <span class="string">"three"</span> to <span class="number">3</span>)</span><br><span class="line">numbersMap.<span class="keyword">remove</span>(<span class="string">"one"</span>)</span><br><span class="line">println(numbersMap)</span><br><span class="line">numbersMap.<span class="keyword">remove</span>(<span class="string">"three"</span>, <span class="number">4</span>)            <span class="comment">//不会删除任何条目</span></span><br><span class="line">println(numbersMap)</span><br></pre></td></tr></table></figure></li><li><p><code>plus</code> 与 <code>minus</code> 操作</p><p>由于需要访问元素的键，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fkotlinlang.org%2Fapi%2Flatest%2Fjvm%2Fstdlib%2Fkotlin.collections%2Fplus.html" target="_blank" rel="noopener"><code>plus</code></a>（<code>+</code>）与 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fkotlinlang.org%2Fapi%2Flatest%2Fjvm%2Fstdlib%2Fkotlin.collections%2Fminus.html" target="_blank" rel="noopener"><code>minus</code></a>（<code>-</code>）运算符对 map 的作用与其他集合不同。 <code>plus</code> 返回包含两个操作数元素的 <code>Map</code> ：左侧的 Map 与右侧的 Pair 或另一个 Map 。 当右侧操作数中有左侧 <code>Map</code> 中已存在的键时，该条目将使用右侧的值（覆盖）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val numbersMap = mapOf(<span class="string">"one"</span> to <span class="number">1</span>, <span class="string">"two"</span> to <span class="number">2</span>, <span class="string">"three"</span> to <span class="number">3</span>)</span><br><span class="line"><span class="built_in">println</span>(numbersMap + Pair(<span class="string">"four"</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">println</span>(numbersMap + Pair(<span class="string">"one"</span>, <span class="number">10</span>))</span><br><span class="line"><span class="built_in">println</span>(numbersMap + mapOf(<span class="string">"five"</span> to <span class="number">5</span>, <span class="string">"one"</span> to <span class="number">11</span>))</span><br></pre></td></tr></table></figure><p>minus 将根据左侧 Map 条目创建一个新 Map ，右侧操作数带有键的条目将被剔除。 因此，右侧操作数可以是单个键或键的集合： list 、 set 等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val numbersMap = mapOf(<span class="string">"one"</span> to <span class="number">1</span>, <span class="string">"two"</span> to <span class="number">2</span>, <span class="string">"three"</span> to <span class="number">3</span>)</span><br><span class="line"><span class="built_in">println</span>(numbersMap - <span class="string">"one"</span>)</span><br><span class="line"><span class="built_in">println</span>(numbersMap - listOf(<span class="string">"two"</span>, <span class="string">"four"</span>))</span><br></pre></td></tr></table></figure></li><li><p><code>containsKey, containsValue</code></p></li><li><p><code>isNotEmpty</code></p></li><li><p><code>sort map</code>:根据键或者值排序</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mmp = mapOf(<span class="number">1</span> to <span class="string">"aone"</span>, <span class="number">3</span> to <span class="string">"three"</span>, <span class="number">2</span> to <span class="string">"two"</span>, <span class="number">4</span> to <span class="string">"four"</span>)</span><br><span class="line"><span class="keyword">val</span> sortedMap: SortedMap&lt;<span class="built_in">Int</span>, String&gt; = mmp.toSortedMap(Comparator &#123; o1, o2 -&gt;</span><br><span class="line">    println(<span class="string">"o1=<span class="variable">$o1</span>,o2=<span class="variable">$o2</span>"</span>)</span><br><span class="line">    <span class="keyword">if</span> (o1 &gt; o2) <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">if</span> (o1 &lt; o2) <span class="number">-1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line">println(sortedMap) <span class="comment">//    &#123;1=aone, 2=two, 3=three, 4=four&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>⭐️<strong>Convert Map to List</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> keyList = ArrayList(mmp.keys)</span><br><span class="line"><span class="keyword">val</span> valueList = ArrayList(mmp.values)</span><br><span class="line"></span><br><span class="line">println(<span class="string">"Key List: <span class="variable">$keyList</span>"</span>) <span class="comment">//    Key List: [1, 3, 2, 4]</span></span><br><span class="line">println(<span class="string">"Value List: <span class="variable">$valueList</span>"</span>) <span class="comment">//    Value List: [aone, three, two, four]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list = mmp.toList().map &#123; <span class="string">"<span class="subst">$&#123;it.first&#125;</span>_<span class="subst">$&#123;it.second&#125;</span>"</span> &#125;</span><br><span class="line">println(<span class="string">"list=<span class="variable">$list</span>"</span>) <span class="comment">// list=[1_aone, 3_three, 2_two, 4_four]</span></span><br></pre></td></tr></table></figure></li><li><p>⭐️<strong>Converting a List to Map in Kotlin</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">val</span> user1 = User(<span class="string">"John"</span>, <span class="number">18</span>, listOf(<span class="string">"Hiking"</span>, <span class="string">"Running"</span>, <span class="string">"Reading"</span>))</span><br><span class="line"> <span class="keyword">val</span> user2 = User(<span class="string">"Sara"</span>, <span class="number">25</span>, listOf(<span class="string">"Chess"</span>, <span class="string">"Music"</span>))</span><br><span class="line"> <span class="keyword">val</span> user3 = User(<span class="string">"Dave"</span>, <span class="number">34</span>, listOf(<span class="string">"Games"</span>, <span class="string">"Programming"</span>))</span><br><span class="line"> <span class="keyword">val</span> myList = listOf(user1, user2, user3)</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">val</span> myMap = myList.map &#123; it.name to it &#125;.toMap()</span><br><span class="line"> println(myMap) <span class="comment">// &#123;John=User(name=John, age=18, hobbit=[Hiking, Running, Reading]), Sara=User(name=Sara, age=25, hobbit=[Chess, Music]), Dave=User(name=Dave, age=34, hobbit=[Games, Programming])&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">val</span> amap = myList.associateBy &#123; it.age &#125;</span><br><span class="line"> println(amap) <span class="comment">// &#123;18=User(name=John, age=18, hobbit=[Hiking, Running, Reading]), 25=User(name=Sara, age=25, hobbit=[Chess, Music]), 34=User(name=Dave, age=34, hobbit=[Games, Programming])&#125;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;除了最通用的Array以外，kotlin中还有一类容器统称为Colletion(集合)，他们有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;List
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;List&lt;/strong&gt;：继承Collection。一个范性有序的只读集合。因为有序，所以，我们可以使用g
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>开发过程中Mysql API记录</title>
    <link href="https://nymrli.top/2021/12/26/%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%ADMysql-API%E8%AE%B0%E5%BD%95/"/>
    <id>https://nymrli.top/2021/12/26/开发过程中Mysql-API记录/</id>
    <published>2021-12-26T12:52:57.000Z</published>
    <updated>2021-12-26T13:27:57.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间操作"><a class="markdownIt-Anchor" href="#时间操作"></a> 时间操作</h1><h2 id="time_to_sec"><a class="markdownIt-Anchor" href="#time_to_sec"></a> TIME_TO_SEC</h2><blockquote><p><a href="http://c.biancheng.net/mysql/" target="_blank" rel="noopener">MySQL</a> TIME_TO_SEC(time) 函数返回将<strong>参数 time 转换为秒数的时间值</strong>，转换公式为“小时 ×3600+ 分钟 ×60+ 秒”。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT TIME_TO_SEC(&apos;15:15:15&apos;);</span><br><span class="line">+-------------------------+</span><br><span class="line">| TIME_TO_SEC(&apos;15:15:15&apos;) |</span><br><span class="line">+-------------------------+</span><br><span class="line">|                   54915 |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; select TIME_TO_SEC(&quot;2021-02-02 04:04:04&quot;);-- 只会考虑时分秒，不会考虑年月日</span><br><span class="line">+-------------------------+</span><br><span class="line">| TIME_TO_SEC(&quot;2021-02-02 04:04:04&quot;) |</span><br><span class="line">+-------------------------+</span><br><span class="line">|                   14644 |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure><p>具体实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT SEC_TO_TIME(TIME_TO_SEC(时间字段)- TIME_TO_SEC(时间字段)%(15*60)) as intervals from tablename</span><br><span class="line">group by intervals</span><br></pre></td></tr></table></figure><h2 id="sec_to_time"><a class="markdownIt-Anchor" href="#sec_to_time"></a> SEC_TO_TIME</h2><blockquote><p>返回将参数 seconds 转换为小时、分钟和秒数的时间值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SEC_TO_TIME(&apos;54925&apos;);</span><br><span class="line">+----------------------+</span><br><span class="line">| SEC_TO_TIME(&apos;54925&apos;) |</span><br><span class="line">+----------------------+</span><br><span class="line">| 15:15:25             |</span><br><span class="line">+----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="date_format"><a class="markdownIt-Anchor" href="#date_format"></a> <a href="https://www.w3school.com.cn/sql/func_date_format.asp" target="_blank" rel="noopener">DATE_FORMAT</a></h2><blockquote><p>用于以不同的格式显示日期/时间数据: <code>DATE_FORMAT(date, format)</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DATE_FORMAT(NOW(),&apos;%b %d %Y %h:%i %p&apos;)</span><br><span class="line">DATE_FORMAT(NOW(),&apos;%m-%d-%Y&apos;)</span><br><span class="line">DATE_FORMAT(NOW(),&apos;%d %b %y&apos;)</span><br><span class="line">DATE_FORMAT(NOW(),&apos;%d %b %Y %T:%f&apos;)</span><br><span class="line"></span><br><span class="line">Dec 29 2008 11:45 PM</span><br><span class="line">12-29-2008</span><br><span class="line">29 Dec 08</span><br><span class="line">29 Dec 2008 16:25:46.635</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;时间操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#时间操作&quot;&gt;&lt;/a&gt; 时间操作&lt;/h1&gt;
&lt;h2 id=&quot;time_to_sec&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#time_to_sec&quot;
      
    
    </summary>
    
    
      <category term="Mysql" scheme="https://nymrli.top/tags/Mysql/"/>
    
      <category term="开发记录" scheme="https://nymrli.top/tags/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Python科学计算常用API记录</title>
    <link href="https://nymrli.top/2021/12/26/Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%B8%B8%E7%94%A8API%E8%AE%B0%E5%BD%95/"/>
    <id>https://nymrli.top/2021/12/26/Python科学计算常用API记录/</id>
    <published>2021-12-26T09:44:24.000Z</published>
    <updated>2021-12-28T11:57:10.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pandas"><a class="markdownIt-Anchor" href="#pandas"></a> pandas</h2><h3 id="to_numeric类别离散化"><a class="markdownIt-Anchor" href="#to_numeric类别离散化"></a> <strong>to_numeric</strong>：类别离散化</h3><p>参数描述<br>argscalar, list, tuple, 1-d array, or Series<br>errors{‘ignore’, ‘raise’, ‘coerce’}, default ‘raise’<br>downcast{‘integer’, ‘signed’, ‘unsigned’, ‘float’} , default None,指定转换的类型,默认返回float64或int64</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = pd.Series([<span class="string">'1.0'</span>, <span class="string">'2'</span>, <span class="number">-3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.to_numeric(s)</span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">2</span>   <span class="number">-3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.to_numeric(s, downcast=<span class="string">'float'</span>)</span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">2</span>   <span class="number">-3.0</span></span><br><span class="line">dtype: float32</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.to_numeric(s, downcast=<span class="string">'signed'</span>)</span><br><span class="line"><span class="number">0</span>    <span class="number">1</span></span><br><span class="line"><span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">2</span>   <span class="number">-3</span></span><br><span class="line">dtype: int8</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = pd.Series([<span class="string">'apple'</span>, <span class="string">'1.0'</span>, <span class="string">'2'</span>, <span class="number">-3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.to_numeric(s, errors=<span class="string">'ignore'</span>)</span><br><span class="line"><span class="number">0</span>    apple</span><br><span class="line"><span class="number">1</span>      <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>        <span class="number">2</span></span><br><span class="line"><span class="number">3</span>       <span class="number">-3</span></span><br><span class="line">dtype: object</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.to_numeric(s, errors=<span class="string">'coerce'</span>)</span><br><span class="line"><span class="number">0</span>    NaN</span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>   <span class="number">-3.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>总结： errors一般采用&quot;ignore&quot;或者&quot;coerce&quot;；downcast按照需求来填写</p><h3 id="缺失值空值处理"><a class="markdownIt-Anchor" href="#缺失值空值处理"></a> 缺失值(空值)处理</h3><p><strong>相关函数</strong></p><ul><li>df.dropna()</li><li>df.fillna()</li><li>df.isnull()</li><li>df.isna()</li></ul><p><strong>相关概念</strong></p><ul><li>空值：在pandas中的空值是&quot;&quot;</li><li>缺失值：在dataframe中为nan或者naT（缺失时间），在series中为none或者nan即可</li></ul><h4 id="dropna删除缺失数据"><a class="markdownIt-Anchor" href="#dropna删除缺失数据"></a> <strong>dropna</strong>删除缺失数据</h4><p><code>DataFrame.dropna(axis=0, how='any', thresh=None, subset=None, inplace=False)</code>, 函数作用：删除含有空值的行或列</p><ul><li>how:&quot;all&quot;表示这一行或列中的元素全部缺失（为nan）才删除这一行或列，&quot;any&quot;表示这一行或列中只要有元素缺失，就删除这一行或列</li><li>thresh:一行或一列中至少出现了thresh个才删除。</li><li>subset：在某些列的子集中选择出现了缺失值的列删除，不在子集中的含有缺失值得列或行不会删除（有axis决定是行还是列）</li><li>inplace：刷选过缺失值得新数据是存为副本还是直接在原数据上进行修改。</li></ul><p>默认参数：删除行，只要有空值就会删除，不替换。</p><h4 id="fillna填充缺失数据"><a class="markdownIt-Anchor" href="#fillna填充缺失数据"></a> Fillna填充缺失数据</h4><p><strong>处理Series对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> nan <span class="keyword">as</span> NaN</span><br><span class="line"></span><br><span class="line">s = [<span class="number">1</span>, NaN, <span class="number">2</span>, <span class="number">3</span>, NaN]</span><br><span class="line">df = pd.Series(s)</span><br><span class="line">df = df.fillna(<span class="number">5</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p><strong>处理DataFrame对象</strong></p><ol><li><p>为所有的NaN的位置填充一个确定值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> nan <span class="keyword">as</span> NaN</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame([[<span class="number">1</span>, NaN, <span class="number">2</span>, <span class="number">3</span>, NaN], [<span class="number">1</span>, <span class="number">2</span>, NaN, <span class="number">3</span>, NaN]])</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">"-"</span>*<span class="number">10</span>)</span><br><span class="line">df = df.fillna(<span class="number">5</span>)</span><br><span class="line">print(df)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   0    1    2  3   4</span></span><br><span class="line"><span class="string">0  1  NaN  2.0  3 NaN</span></span><br><span class="line"><span class="string">1  1  2.0  NaN  3 NaN</span></span><br><span class="line"><span class="string">----------</span></span><br><span class="line"><span class="string">   0    1    2  3    4</span></span><br><span class="line"><span class="string">0  1  5.0  2.0  3  5.0</span></span><br><span class="line"><span class="string">1  1  2.0  5.0  3  5.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></li><li><p>通过字典为不同的列填充不同的常数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame([[<span class="number">1</span>, NaN, <span class="number">2</span>, <span class="number">3</span>, NaN], [<span class="number">1</span>, <span class="number">2</span>, NaN, <span class="number">3</span>, NaN]], columns=[<span class="string">"1st"</span>, <span class="string">"2nd"</span>, <span class="string">"3rd"</span>, <span class="string">"4th"</span>, <span class="string">"5th"</span>])</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">"-"</span>*<span class="number">10</span>)</span><br><span class="line">df = df.fillna(&#123;<span class="string">"5th"</span>: <span class="number">100</span>&#125;)</span><br><span class="line">print(df)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   1st  2nd  3rd  4th  5th</span></span><br><span class="line"><span class="string">0    1  NaN  2.0    3  NaN</span></span><br><span class="line"><span class="string">1    1  2.0  NaN    3  NaN</span></span><br><span class="line"><span class="string">----------</span></span><br><span class="line"><span class="string">   1st  2nd  3rd  4th    5th</span></span><br><span class="line"><span class="string">0    1  NaN  2.0    3  100.0</span></span><br><span class="line"><span class="string">1    1  2.0  NaN    3  100.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></li></ol><p>method参数：改变替代值的方式，当为’ffill’，表示用前面的值填充，当’bfill’表示用后面的值填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame([[<span class="number">1</span>, NaN, <span class="number">2</span>, <span class="number">3</span>, NaN], [<span class="number">1</span>, <span class="number">2</span>, NaN, <span class="number">3</span>, NaN]], columns=[<span class="string">"1st"</span>, <span class="string">"2nd"</span>, <span class="string">"3rd"</span>, <span class="string">"4th"</span>, <span class="string">"5th"</span>])</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">"-"</span>*<span class="number">10</span>)</span><br><span class="line">df = df.fillna(method=<span class="string">"ffill"</span>)  <span class="comment"># bfill</span></span><br><span class="line">print(df)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   1st  2nd  3rd  4th  5th</span></span><br><span class="line"><span class="string">0    1  NaN  2.0    3  NaN</span></span><br><span class="line"><span class="string">1    1  2.0  NaN    3  NaN</span></span><br><span class="line"><span class="string">----------</span></span><br><span class="line"><span class="string">   1st  2nd  3rd  4th  5th</span></span><br><span class="line"><span class="string">0    1  NaN  2.0    3  NaN</span></span><br><span class="line"><span class="string">1    1  2.0  2.0    3  NaN</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">df = pd.DataFrame([[<span class="number">1</span>, NaN, <span class="number">2</span>, <span class="number">3</span>, NaN], [<span class="number">1</span>, <span class="number">2</span>, NaN, <span class="number">3</span>, NaN]], columns=[<span class="string">"1st"</span>, <span class="string">"2nd"</span>, <span class="string">"3rd"</span>, <span class="string">"4th"</span>, <span class="string">"5th"</span>])</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">"-"</span>*<span class="number">10</span>)</span><br><span class="line">df = df.fillna(method=<span class="string">"bfill"</span>)  <span class="comment"># bfill</span></span><br><span class="line">print(df)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   1st  2nd  3rd  4th  5th</span></span><br><span class="line"><span class="string">0    1  NaN  2.0    3  NaN</span></span><br><span class="line"><span class="string">1    1  2.0  NaN    3  NaN</span></span><br><span class="line"><span class="string">----------</span></span><br><span class="line"><span class="string">   1st  2nd  3rd  4th  5th</span></span><br><span class="line"><span class="string">0    1  2.0  2.0    3  NaN</span></span><br><span class="line"><span class="string">1    1  2.0  NaN    3  NaN</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>method：FillnaOptions，ffill/forwardfill:用缺失值前面的一个值代替缺失值；bfill/backfill，缺失值后面的一个值代替前面的缺失值。注意这个参数不能与value同时出现（value:需要用什么值去填充缺失值）</li><li>axis：参数默认为0，即沿着行填充，为1则沿着列填充</li><li>limit：传入<code>limit</code>限制填充个数</li><li>inplace：传入inplace参数:是否在原来的数据上操作，默认为False，表示重新拷贝了一份数据，然后在拷贝的数据上操作。</li></ul><h3 id="dateframe操作"><a class="markdownIt-Anchor" href="#dateframe操作"></a> DateFrame操作</h3><h4 id="添加行"><a class="markdownIt-Anchor" href="#添加行"></a> 添加行</h4><p>**添加一行：**采用<code>loc[]</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造一个空的dataframe</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(columns=[<span class="string">'name'</span>,<span class="string">'number'</span>])</span><br><span class="line"><span class="comment"># 采用.loc的方法进行</span></span><br><span class="line">df.loc[<span class="number">0</span>]=[<span class="string">'cat'</span>, <span class="number">3</span>]  <span class="comment"># 其中loc[]中需要加入的是插入地方dataframe的索引，默认是整数型</span></span><br><span class="line"><span class="comment"># 也可采用诸如df.loc['a'] = ['123',30]的形式</span></span><br></pre></td></tr></table></figure><p><strong>添加多行</strong>==&gt;(合并另一个dateframe)：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 采用append方法合并两个dataframe</span></span><br><span class="line"><span class="comment"># 构造两个dataframe</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], columns=<span class="keyword">list</span>(<span class="string">'AB'</span>))</span><br><span class="line">df2 = pd.DataFrame([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], columns=<span class="keyword">list</span>(<span class="string">'AB'</span>))</span><br><span class="line"><span class="comment"># 合并  ignore_index设置为 True可以重新排列索引</span></span><br><span class="line">df.append(df2, ignore_index=<span class="keyword">True</span>)</span><br><span class="line">   A  B</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line"><span class="number">2</span>  <span class="number">5</span>  <span class="number">6</span></span><br><span class="line"><span class="number">3</span>  <span class="number">7</span>  <span class="number">8</span></span><br></pre></td></tr></table></figure><h4 id="添加列"><a class="markdownIt-Anchor" href="#添加列"></a> 添加列</h4><p>采用<code>df[]</code>方法直接在列上操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个dataframe</span></span><br><span class="line">df = pd.DataFrame(columns=[<span class="string">'name'</span>,<span class="string">'number'</span>], data=[[<span class="string">'cat'</span>,<span class="number">3</span>]])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">df</span></span><br><span class="line"><span class="string">  name  number</span></span><br><span class="line"><span class="string">0  cat       3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 添加一列，计算有多少条腿</span></span><br><span class="line">df[<span class="string">'leg'</span>] = df[<span class="string">'number'</span>] * <span class="number">4</span></span><br><span class="line"><span class="comment"># 添加一列，直接赋值有几个头</span></span><br><span class="line">df[<span class="string">'head'</span>] = <span class="number">1</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">df </span></span><br><span class="line"><span class="string">  name  number  leg  head</span></span><br><span class="line"><span class="string">0  cat       3   12     1</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>采用<code>insert()</code>方法(过时deprecated)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用方法是DataFrame.insert(loc, column, value, allow_duplicates=False)</span></span><br><span class="line"><span class="comment"># 即df.insert(添加列位置索引序号，添加列名，数值，是否允许列名重复)</span></span><br><span class="line">df.insert(<span class="number">1</span>, <span class="string">'tail'</span>, <span class="number">1</span>, allow_duplicates=<span class="keyword">False</span>)</span><br><span class="line">df</span><br><span class="line">  name  tail  number  leg  head</span><br><span class="line"><span class="number">0</span>  cat     <span class="number">1</span>       <span class="number">3</span>   <span class="number">12</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="合并多个dataframe"><a class="markdownIt-Anchor" href="#合并多个dataframe"></a> 合并多个DataFrame</h3><p><a href="https://blog.csdn.net/milton2017/article/details/54406482/" target="_blank" rel="noopener">https://blog.csdn.net/milton2017/article/details/54406482/</a></p><h4 id="获得满足条件的行或者列"><a class="markdownIt-Anchor" href="#获得满足条件的行或者列"></a> 获得满足条件的行或者列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取DataFrame中numTest列的值大于2的行内容</span></span><br><span class="line">arr1 = arr[arr[<span class="string">'numTest'</span>]&gt;<span class="number">2</span>]</span><br><span class="line">print(arr1)</span><br><span class="line"><span class="comment"># 获取哪几行符合条件，也就是获取符合条件的行的索引值</span></span><br><span class="line">result = arr[arr[<span class="string">'numTest'</span>]&gt;<span class="number">2</span>].index.tolist()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><ul><li><p>直接筛选</p><p>直接使用列需要满足的条件，如果需要多个列同时满足条件，使用’&amp;‘符号连接即可；如果只需要某一列满足条件，则使用’|'连接多个列的条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">some = all_data[(all_data[<span class="string">'User_id'</span>] == <span class="number">1439408</span>) &amp; (all_data[<span class="string">'Date'</span>].isna())]</span><br><span class="line">print(some)</span><br><span class="line"><span class="comment"># 得到了User_id=1439408和Date为空的数据项</span></span><br><span class="line">   User_id  Merchant_id  Coupon_id Discount_rate  Distance  Date_received  Date</span><br><span class="line"><span class="number">1</span>  <span class="number">1439408</span>         <span class="number">4663</span>    <span class="number">11002.0</span>        <span class="number">150</span>:<span class="number">20</span>       <span class="number">1.0</span>     <span class="number">20160528.0</span>   NaN</span><br><span class="line"><span class="number">2</span>  <span class="number">1439408</span>         <span class="number">2632</span>     <span class="number">8591.0</span>          <span class="number">20</span>:<span class="number">1</span>       <span class="number">0.0</span>     <span class="number">20160217.0</span>   NaN</span><br><span class="line"><span class="number">3</span>  <span class="number">1439408</span>         <span class="number">2632</span>     <span class="number">1078.0</span>          <span class="number">20</span>:<span class="number">1</span>       <span class="number">0.0</span>     <span class="number">20160319.0</span>   NaN</span><br><span class="line"><span class="number">4</span>  <span class="number">1439408</span>         <span class="number">2632</span>     <span class="number">8591.0</span>          <span class="number">20</span>:<span class="number">1</span>       <span class="number">0.0</span>     <span class="number">20160613.0</span>   NaN</span><br></pre></td></tr></table></figure></li><li><p>基于map筛选</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">user_requried = all_data[<span class="string">'User_id'</span>].map(<span class="keyword">lambda</span> x : x==<span class="number">1439408</span>)</span><br><span class="line">date_requried = all_data[<span class="string">'Date'</span>].map(<span class="keyword">lambda</span> x : np.isnan(x))</span><br><span class="line">some = all_data[user_requried &amp; date_requried]</span><br><span class="line">print(some) </span><br><span class="line"><span class="comment"># 结果：其中map返回的值必须是bool类型，即某一个条件。然后使用直接筛选的方式，把条件合并，最终得出筛选的结果。我认为使用此种类型的方法更加的优美。</span></span><br><span class="line"></span><br><span class="line">   User_id  Merchant_id  Coupon_id Discount_rate  Distance  Date_received  Date</span><br><span class="line"><span class="number">1</span>  <span class="number">1439408</span>         <span class="number">4663</span>    <span class="number">11002.0</span>        <span class="number">150</span>:<span class="number">20</span>       <span class="number">1.0</span>     <span class="number">20160528.0</span>   NaN</span><br><span class="line"><span class="number">2</span>  <span class="number">1439408</span>         <span class="number">2632</span>     <span class="number">8591.0</span>          <span class="number">20</span>:<span class="number">1</span>       <span class="number">0.0</span>     <span class="number">20160217.0</span>   NaN</span><br><span class="line"><span class="number">3</span>  <span class="number">1439408</span>         <span class="number">2632</span>     <span class="number">1078.0</span>          <span class="number">20</span>:<span class="number">1</span>       <span class="number">0.0</span>     <span class="number">20160319.0</span>   NaN</span><br><span class="line"><span class="number">4</span>  <span class="number">1439408</span>         <span class="number">2632</span>     <span class="number">8591.0</span>          <span class="number">20</span>:<span class="number">1</span>       <span class="number">0.0</span>     <span class="number">20160613.0</span>   NaN</span><br></pre></td></tr></table></figure></li><li><p>基于query方法筛选</p><p>直接写表达式，得出想要筛选的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">some = all_data.query(<span class="string">'(User_id == 1439408)'</span>)</span><br><span class="line">print(some)</span><br><span class="line"><span class="comment">#结果：直接写表达式容易触发一些不必要的问题（值的类型容易出错，一些特殊值的表达困难等），所以并不建议使用这样的方法。</span></span><br></pre></td></tr></table></figure></li></ul><p>总结：</p><ul><li>确定一个条件–&gt; df[‘money’]&gt;10000)</li><li>确定满足条件的行–&gt; df[(df[‘money’]&gt;10000)]</li><li>确定这些行的index–&gt; df[(df[‘money’]&gt;10000)].index.tolist()， 返回的是一个list</li></ul><h4 id="选取指定列展示"><a class="markdownIt-Anchor" href="#选取指定列展示"></a> 选取指定列展示</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选取指定的列, 中间写的是条件， 类比 df = df[ df["sale"] &gt; 50 ]</span></span><br><span class="line">df = df[ [<span class="string">"sku"</span>,<span class="string">"ebayno"</span>,<span class="string">"sale"</span>] ]</span><br></pre></td></tr></table></figure><h2 id="jieba"><a class="markdownIt-Anchor" href="#jieba"></a> Jieba</h2><blockquote><p>文本类的数据分析，一般都是分词+词云展示</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(data_path)</span><br><span class="line">all_content = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(data[<span class="string">'评论标题'</span>])):</span><br><span class="line">all_content = all_content + data[<span class="string">'评论标题'</span>][i]</span><br><span class="line">cut_text = <span class="string">" "</span>.join(jieba.cut(all_content))</span><br></pre></td></tr></table></figure><h2 id="wordcloud"><a class="markdownIt-Anchor" href="#wordcloud"></a> WordCloud</h2><blockquote><p>将数据保存后就要进行可视化展示，一般文本类的都会采用词云</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"></span><br><span class="line">wordcloud = WordCloud(font_path=ciyunfont_path, mask=background_image, background_color=<span class="string">'white'</span>).generate(cut_text)</span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(result_path):</span><br><span class="line">    os.makedirs(result_path)</span><br><span class="line"><span class="comment"># 保存生成图片</span></span><br><span class="line">plt.savefig(<span class="string">f'<span class="subst">&#123;result_path&#125;</span>/ciyun.png'</span>)</span><br><span class="line"><span class="comment"># 指定词云图为待显示的图片</span></span><br><span class="line">plt.imshow(wordcloud, interpolation=<span class="string">"bilinear"</span>)</span><br><span class="line">plt.axis(<span class="string">"off"</span>)</span><br><span class="line"><span class="comment"># 显示图片</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;pandas&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pandas&quot;&gt;&lt;/a&gt; pandas&lt;/h2&gt;
&lt;h3 id=&quot;to_numeric类别离散化&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#to
      
    
    </summary>
    
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python中关于图片的操作</title>
    <link href="https://nymrli.top/2021/12/26/Python%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%9B%BE%E7%89%87%E7%9A%84%E8%AF%BB%E5%8F%96/"/>
    <id>https://nymrli.top/2021/12/26/Python中关于图片的读取/</id>
    <published>2021-12-26T08:16:29.000Z</published>
    <updated>2021-12-26T08:32:11.523Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写代码的时候一直记错库下对应的图片操作函数名以及他们的返回值类型，干脆写个笔记记录下。</p></blockquote><p>图片读取相关的包：</p><ul><li>matplotlib</li><li>PIL/</li><li>cv2</li><li>numpy</li></ul><h1 id="读取"><a class="markdownIt-Anchor" href="#读取"></a> 读取</h1><h2 id="matplotlibpyplot-pylab"><a class="markdownIt-Anchor" href="#matplotlibpyplot-pylab"></a> matplotlib.pyplot / pylab</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># from matplotlib import pyplot as plt</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = plt.imread(<span class="string">'examples.png'</span>)</span><br><span class="line">print(type(img), img.dtype, np.min(img), np.max(img))</span><br><span class="line"></span><br><span class="line">[out]</span><br><span class="line">(&lt;type <span class="string">'numpy.ndarray'</span>&gt;, dtype(<span class="string">'float32'</span>), <span class="number">0.0</span>, <span class="number">1.0</span>)    <span class="comment"># matplotlib读取进来的图片是float，0-1</span></span><br></pre></td></tr></table></figure><p>注：pylab和pyplot区别：前者将numpy、以及各个功能函数导入了其命名空间中。这样会使pylab表现的和matlab更加相似。现在来说我们经常使用pyplot，因为pyplot相比pylab更加纯粹。</p><h2 id="pilimageopen"><a class="markdownIt-Anchor" href="#pilimageopen"></a> PIL.image.open</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = Image.open(<span class="string">'examples.png'</span>)</span><br><span class="line">print(type(img), np.min(img), np.max(img))</span><br><span class="line">img = np.array(img)     <span class="comment"># 将PIL格式图片转为numpy格式</span></span><br><span class="line">print(type(img), img.dtype, np.min(img), np.max(img))</span><br><span class="line"></span><br><span class="line">[out]</span><br><span class="line">(&lt;class 'PIL.PngImagePlugin.PngImageFile'&gt;, 0, 255)    # 注意，PIL是有自己的数据结构的，但是可以转换成numpy数组</span><br><span class="line">(&lt;type <span class="string">'numpy.ndarray'</span>&gt;, dtype(<span class="string">'uint8'</span>), <span class="number">0</span>, <span class="number">255</span>)    <span class="comment"># 和用matplotlib读取不同，PIL和matlab相同，读进来图片和其存储在硬盘的样子是一样的，uint8，0-255</span></span><br></pre></td></tr></table></figure><p>PIL读取的结果是Image格式的，需要再额外转换成np.array的形式</p><h2 id="cv2imread"><a class="markdownIt-Anchor" href="#cv2imread"></a> cv2.imread</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(<span class="string">'examples.png'</span>)    <span class="comment"># 默认是读入为彩色图，即使原图是灰度图也会复制成三个相同的通道变成彩色图</span></span><br><span class="line">img_gray = cv2.imread(<span class="string">'examples.png'</span>, <span class="number">0</span>)    <span class="comment"># 第二个参数为0的时候读入为灰度图，即使原图是彩色图也会转成灰度图</span></span><br><span class="line">print(type(img), img.dtype, np.min(img), np.max(img))</span><br><span class="line">print(img.shape)</span><br><span class="line">print(img_gray.shape)</span><br><span class="line"></span><br><span class="line">[out]</span><br><span class="line">(&lt;type <span class="string">'numpy.ndarray'</span>&gt;, dtype(<span class="string">'uint8'</span>), <span class="number">0</span>, <span class="number">255</span>)    <span class="comment"># opencv读进来的是numpy数组，类型是uint8，0-255</span></span><br><span class="line">(<span class="number">824</span>, <span class="number">987</span>, <span class="number">3</span>)    <span class="comment"># 彩色图3通道</span></span><br><span class="line">(<span class="number">824</span>, <span class="number">987</span>)    <span class="comment"># 灰度图单通道</span></span><br></pre></td></tr></table></figure><p><em>注意，pylab.imread和PIL.Image.open读入的都是RBG顺序，而cv2.imread读入的是BGR顺序，混合使用的时候要特备注意</em></p><h1 id="保存"><a class="markdownIt-Anchor" href="#保存"></a> 保存</h1><h2 id="pltsavefig"><a class="markdownIt-Anchor" href="#pltsavefig"></a> plt.savefig()</h2><blockquote><p>savefig()方法用于保存绘制数据后创建的图形。使用此方法可以将创建的图形保存到我们的本地计算机中。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wordcloud = WordCloud(font_path=ciyunfont_path, mask=background_image, background_color=<span class="string">'white'</span>).generate(cut_text)</span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(result_path):</span><br><span class="line">    os.makedirs(result_path)</span><br><span class="line">    <span class="comment"># 保存生成图片</span></span><br><span class="line">    plt.savefig(<span class="string">f'<span class="subst">&#123;result_path&#125;</span>/ciyun.png'</span>)</span><br><span class="line">    <span class="comment"># 指定词云图为待显示的图片</span></span><br><span class="line">    plt.imshow(wordcloud, interpolation=<span class="string">"bilinear"</span>)</span><br></pre></td></tr></table></figure><p>注意， 使用savefig的话得注意与plt.show()的位置，如果先<code>plt.show()</code>了则保存的是空白图片。</p><h2 id="pilimage-保存pil格式的图片"><a class="markdownIt-Anchor" href="#pilimage-保存pil格式的图片"></a> PIL.image - 保存PIL格式的图片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img = Image.open(<span class="string">'examples.png'</span>)</span><br><span class="line">img.save(<span class="string">'examples2.png'</span>)</span><br><span class="line">img_gray = img.convert(<span class="string">'L'</span>)</span><br><span class="line">img_gray.save(<span class="string">'examples_gray.png'</span>)    <span class="comment"># 不管是灰度还是彩色，直接用save函数保存就可以，但注意，只有PIL格式的图片能够用save函数</span></span><br></pre></td></tr></table></figure><h2 id="cv2imwrite"><a class="markdownIt-Anchor" href="#cv2imwrite"></a> cv2.imwrite</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(<span class="string">'examples.png'</span>)    <span class="comment"># 这是BGR图片</span></span><br><span class="line">cv2.imwrite(<span class="string">'examples2.png'</span>, img)    <span class="comment"># 这里也应该用BGR图片保存，这里要非常注意，因为用pylab或PIL读入的图片都是RGB的，如果要用opencv存图片就必须做一个转换</span></span><br><span class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">cv2.imwrite(<span class="string">'examples_gray.png'</span>, img_gray)</span><br></pre></td></tr></table></figure><h1 id="灰度图-rgb图相互转换"><a class="markdownIt-Anchor" href="#灰度图-rgb图相互转换"></a> 灰度图-RGB图相互转换</h1><h2 id="1-pilimage"><a class="markdownIt-Anchor" href="#1-pilimage"></a> 1  PIL.Image</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img = Image.open(<span class="string">'examples.png'</span>)</span><br><span class="line">img_gray = img.convert(<span class="string">'L'</span>)    <span class="comment"># RGB转换成灰度图像</span></span><br><span class="line">img_rgb = img_gray.convert(<span class="string">'RGB'</span>) <span class="comment"># 灰度转RGB</span></span><br><span class="line">print(img)</span><br><span class="line">print(img_gray)</span><br><span class="line">print(img_rgb)</span><br><span class="line"></span><br><span class="line">[out]</span><br><span class="line">&lt;PIL.PngImagePlugin.PngImageFile image mode=RGB size=<span class="number">987</span>x824 at <span class="number">0x7FC2CCAE04D0</span>&gt;</span><br><span class="line">&lt;PIL.Image.Image image mode=L size=<span class="number">987</span>x824 at <span class="number">0x7FC2CCAE0990</span>&gt;</span><br><span class="line">&lt;PIL.Image.Image image mode=RGB size=<span class="number">987</span>x824 at <span class="number">0x7FC2CCAE0250</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="2-cv2注意opencv在读入图片的时候就可以通过参数实现颜色通道的转换下面是用别的方式实现"><a class="markdownIt-Anchor" href="#2-cv2注意opencv在读入图片的时候就可以通过参数实现颜色通道的转换下面是用别的方式实现"></a> 2  cv2（注意，opencv在读入图片的时候就可以通过参数实现颜色通道的转换，下面是用别的方式实现）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> plt</span><br><span class="line">img = cv2.imread(<span class="string">'examples.png'</span>)</span><br><span class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)    <span class="comment"># BGR转灰度</span></span><br><span class="line">img_bgr = cv2.cvtColor(img_gray, cv2.COLOR_GRAY2BGR)    <span class="comment"># 灰度转BRG</span></span><br><span class="line">img_rgb = cv2.cvtColor(img_gray, cv2.COLOR_GRAY2RGB)    <span class="comment"># 也可以灰度转RGB</span></span><br></pre></td></tr></table></figure><p>from: <a href="https://www.jianshu.com/p/3977d674da85" target="_blank" rel="noopener">numpy、cv2等操作图片基本操作</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;写代码的时候一直记错库下对应的图片操作函数名以及他们的返回值类型，干脆写个笔记记录下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;图片读取相关的包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;matplotlib&lt;/li&gt;
&lt;li&gt;PIL/&lt;/li&gt;
&lt;li&gt;cv
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://nymrli.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="https://nymrli.top/tags/Python/"/>
    
  </entry>
  
</feed>
