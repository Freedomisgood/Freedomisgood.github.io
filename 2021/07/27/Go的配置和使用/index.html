<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Mrli"><meta name="renderer" content="webkit"><meta name="copyright" content="Mrli"><meta name="keywords" content="Mrli's Blog"><meta name="description" content="想和你讲，说了会心动 ，缄默会心安。"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Go的配置和使用 · Mr.li's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="https://avatars1.githubusercontent.com/u/31088082?s=400&amp;u=7a99ff83916afb3f4c5312bd78a1be17fe0e34ed&amp;v=4"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Mrli</div><div class="profile-signature">别装作很努力,<br>因为结局不会陪你演戏。</div><div class="contacts"><div>Contacts:</div><span><a href="http://sighttp.qq.com/msgrd?v=1&amp;uin=1063052964" target="_black">QQ</a></span><span><a href="https://www.cnblogs.com/nymrli/" target="_black">博客园</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 60vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.li's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">Go的配置和使用</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-edit"></i><span>2021/11/10</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="环境配置"> 环境配置</a><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="Go"> Go</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">8,500</span> | Reading time: <span class="post-count">38</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="go语法学习"><a class="markdownIt-Anchor" href="#go语法学习"></a> Go语法学习</h1>
<blockquote>
<p>Go 语言被设计成一门应用于搭载 <strong>Web 服务器</strong>，<strong>存储集群</strong>或类似用途的巨型中央服务器的系统编程语言。</p>
<p>对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量<strong>并行</strong>的支持，这对于游戏服务端的开发而言是再好不过了。</p>
</blockquote>
<h2 id="变量声明"><a class="markdownIt-Anchor" href="#变量声明"></a> 变量声明</h2>
<blockquote>
<p>变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。</p>
</blockquote>
<p>声明变量的一般形式是使用 var 关键字：</p>
<ul>
<li>第一种，指定变量类型，如果没有初始化，则变量默认为零值: <code>var identifier1, identifier2 type</code>==&gt;bool零值为false，int为0</li>
<li>第二种，根据值自行判定变量类型: <code>var v_name = value</code>, <code>var flag = true</code></li>
<li>使用<code>:=</code>,  := 是一个声明语句 --&gt; <strong>intVal := 1</strong> 相等于：<code>var intVal int</code>和<code>intVal =1</code></li>
</ul>
<p>注：<strong>如果变量已经使用 var 声明过了，再使用 *<em>:=*</em> 声明变量，就产生编译错误</strong></p>
<h2 id="函数定义"><a class="markdownIt-Anchor" href="#函数定义"></a> 函数定义</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span> [<span class="title">return_types</span>]</span> &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>func：函数由 func 开始声明</li>
<li>function_name：函数名称，参数列表和返回值类型构成了函数签名。</li>
<li>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li>
<li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li>
<li>函数体：函数定义的代码集合。</li>
</ul>
<p>注：Go的函数跟python一样能够返回多个返回值</p>
<h2 id="go-语言接口"><a class="markdownIt-Anchor" href="#go-语言接口"></a> Go 语言接口</h2>
<blockquote>
<p>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，<strong>任何其他类型只要实现了这些方法就是实现了这个接口</strong>(并不需要指定实现的是哪个接口的方法)。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义接口 */</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> &#123;</span><br><span class="line">   method_name1 [return_type]</span><br><span class="line">   method_name2 [return_type]</span><br><span class="line">   method_name3 [return_type]</span><br><span class="line">   ...</span><br><span class="line">   method_namen [return_type]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> struct_name <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">/* variables */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现接口方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_name1</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现 */</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_namen</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li>
<p>Go语言中不允许有没有使用的变量（函数可以）</p>
</li>
<li>
<p>if和for后面必须有大括号，即使只有一句也得有大括号</p>
</li>
<li>
<p>slice即切片，也是一种<strong>数据结构</strong>，它是数组的抽象， 通过<code>var identifier []type</code>声明或者<code>slice1 := make([]type, len)</code>创建，如**<code>s :=[] int {1,2,3 }</code>**</p>
<ul>
<li>区分于数组：<code>var balance [10] float32</code>、<code>var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}</code>、<code>balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}</code>、<strong><code>balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}</code></strong></li>
</ul>
</li>
<li>
<p>map使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">var</span> countryCapitalMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">/*创建集合 */</span></span><br><span class="line">countryCapitalMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line">map_variable := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>go build</code>和<code>go install</code>区别</p>
<ul>
<li>go build 不能生成包文件, go install 可以生成包文件</li>
<li>go build 生成可执行文件在当前目录下； go install 生成可执行文件在bin目录下（<code>$GOPATH/bin</code>），如果环境变量指定了GOPATH，则可直接在cmd里输入文件，如<code>go install mycode.go</code>， 则编译好后可以直接在cmd里输入<code>mycode -fpath=..</code>, (fpath为flag要读取的参数)
<ul>
<li>区别大致与<code>mvn package</code>和<code>mvn install</code>相同，都会把工程打包成jar文件，但package的位置在root/target下面,install会安装到mvn库下</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="切片与数组"><a class="markdownIt-Anchor" href="#切片与数组"></a> 切片与数组</h2>
<p>定义</p>
<ul>
<li>数组是类型相同的元素的集合。例如，整数 5, 8, 9, 79, 76 的集合就构成了一个数组。Go不允许在数组中混合使用不同类型的元素（比如整数和字符串）。</li>
<li>切片（slice）是<u>建立在数组之上</u>的更方便，更灵活，更强大的数据结构。切片并不存储任何元素而只是<strong>对现有数组的引用</strong>。</li>
</ul>
<p>声明：</p>
<ul>
<li>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type		<span class="comment">// 声明了一个长度为 3 的整型数组。数组中的所有元素都被自动赋值为元素类型的 0 值</span></span><br><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">12</span>, <span class="number">78</span>, <span class="number">50</span>&#125; <span class="comment">// shorthand declaration(速记声明) to create array</span></span><br><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">12</span>&#125; 	<span class="comment">//	声明了一个长度为 3 的数组，但是只提供了一个初值 12。剩下的两个元素被自动赋值为 0</span></span><br><span class="line"> a := [...]<span class="keyword">int</span>&#123;<span class="number">12</span>, <span class="number">78</span>, <span class="number">50</span>&#125; <span class="comment">// ... makes the compiler determine the length自动推导</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b []<span class="keyword">int</span> = a[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">//  创建了一个从 a[1] 到 a[3] 的切片</span></span><br><span class="line"></span><br><span class="line">c := []<span class="keyword">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125; <span class="comment">// 创建了一个长度为 3 的 int 数组，并返回一个切片给 c。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置函数 func make([]T, len, cap) []T 可以用来创建切片，该函数接受长度和容量作参数，返回切片。容量是可选的，默认与长度相同。使用 make 函数将会创建一个数组并返回它的切片。</span></span><br><span class="line">i := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>)		<span class="comment">// 用 make 创建的长度和容量为5的数组并返回其切片，元素值默认为 0 值</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>元素类型为 <code>T</code> 的切片表示为： <code>[]T</code>。</p>
</li>
</ul>
<p>注：</p>
<ul>
<li><strong>数组是值类型</strong>：
<ul>
<li>在 Go 中数组是值类型而不是引用类型。这意味着当数组变量被赋值时，将会获得原数组（<em>译者注：也就是等号右面的数组</em>）的拷贝。新数组中元素的改变不会影响原数组中元素的值。</li>
<li>如果将数组作为参数传递给函数，仍然是值传递，在函数中对（作为参数传入的）数组的修改不会造成原数组的改变</li>
</ul>
</li>
<li>切片本身不包含任何数据。它仅仅是底层数组的一个上层表示。对切片进行的任何修改都将反映在底层数组中。</li>
<li>想修改数组内容的时候，函数中传递数组的切片：当将一个切片作为参数传递给一个函数时，虽然是值传递，但是指针始终指向同一个数组。因此将切片作为参数传给函数时，函数对该切片的修改在函数外部也可以看到。</li>
</ul>
<h2 id="make"><a class="markdownIt-Anchor" href="#make"></a> make</h2>
<blockquote>
<p>golang 分配内存主要有内置函数new和make，make只能为slice, map, channel分配内存，并返回一个初始化的值。</p>
</blockquote>
<p>首先来看下make有以下几种不同的用法：</p>
<ol>
<li>
<p>make(map[string]string)</p>
<p>缺少长度的参数，只传类型，这种用法只能用在类型为map或chan的场景，例如make([]int)是会报错的。这样返回的空间长度都是默认为0的。</p>
</li>
<li>
<p>make([]int, 2)</p>
<p>指定了长度，例如make([]int, 2)返回的是一个长度为2的slice</p>
</li>
<li>
<p>make([]int, 2, 4)</p>
</li>
</ol>
<p>第二参数指定的是切片的长度，第三个参数是用来指定预留的空间长度，例如a := make([]int, 2, 4), 这里值得注意的是返回的切片a的总长度是4，预留的意思并不是另外多出来4的长度，其实是包含了前面2个已经切片的个数的。所以举个例子当你这样用的时候 a := make([]int, 4, 2)，就会报语法错误。(当我们为slice分配内存的时候，应当尽量预估到slice可能的最大长度，通过给make传第三个参数的方式来给slice预留好内存空间，这样可以避免二次分配内存带来的开销，大大提高程序的性能。)</p>
<ol start="4">
<li>
<p>通道</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)                 <span class="comment">// 创建一个整型类型的通道</span></span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)         <span class="comment">// 创建一个空接口类型的通道, 可以存放任意格式</span></span><br><span class="line"><span class="keyword">type</span> Equip <span class="keyword">struct</span>&#123; <span class="comment">/* 一些字段 */</span> &#125;</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> *Equip)             <span class="comment">// 创建Equip指针类型的通道, 可以存放*Equip</span></span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> &lt;- <span class="keyword">int</span>, <span class="number">2</span>)			<span class="comment">// 创建一个只接收的通道，且缓冲大小为2</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="if"><a class="markdownIt-Anchor" href="#if"></a> if</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1 &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition2 &#123;</span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// catch-all or default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键字 if 和 else 之后的左大括号<code>{</code>必须和关键字在同一行，如果你使用了 else if 结构，则前段代码块的右大括号<code>}</code>必须和 else if 关键字在同一行，这两条规则都是被编译器强制规定的。</p>
<p>在简单情况下，条件语句两侧的<strong>括号是可以被省略</strong>的，当条件比较复杂时，则可以使用括号让代码更易读，在使用 &amp;&amp;、|| 或 ! 时可以使用括号来提升某个表达式的运算优先级，并提高代码的可读性。</p>
<p>==&gt; if后的语句必然有大括号</p>
<h2 id="for"><a class="markdownIt-Anchor" href="#for"></a> for</h2>
<p>三种形式：</p>
<ul>
<li><code>for init; condition; post { }</code></li>
<li><code>for condition { }</code></li>
<li><code>for { }</code></li>
</ul>
<p>跟if一样，for的执行块必须要用<code>{}</code>括起来，并且需要注意的是for<strong>有特定的结构，不能加小括号<code>()</code>!</strong></p>
<h2 id="map使用"><a class="markdownIt-Anchor" href="#map使用"></a> map使用</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mp := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">if</span> _, ok := mp[i]; ok == <span class="literal">false</span>&#123;</span><br><span class="line">	mp[candyType[i]] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取key长度</span></span><br><span class="line"><span class="built_in">len</span>(mp)</span><br><span class="line"><span class="comment">// 取k和v</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> mp&#123;</span><br><span class="line">    fmt.Print(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="空结构体-struct"><a class="markdownIt-Anchor" href="#空结构体-struct"></a> 空结构体 struct{}</h2>
<blockquote>
<p>▲.<strong>空结构体不占用空间</strong> : <code>fmt.Println(unsafe.Sizeof(struct{}{})) ==&gt; 0</code></p>
</blockquote>
<h3 id="空结构体的作用"><a class="markdownIt-Anchor" href="#空结构体的作用"></a> <a href="https://geektutu.com/post/hpg-empty-struct.html" target="_blank" rel="noopener">空结构体的作用：</a></h3>
<p>因为空结构体不占据内存空间，因此被广泛作为各种场景下的占位符使用。一是节省资源，二是空结构体本身就具备很强的语义，即这里不需要任何值，仅作为占位符。</p>
<h4 id="21-实现集合set"><a class="markdownIt-Anchor" href="#21-实现集合set"></a> 2.1 实现集合(Set)</h4>
<p>Go 语言标准库没有提供 Set 的实现，<u>通常使用 map 来代替</u>。事实上，对于集合来说，只需要 map 的键，而不需要值。即使是将值设置为 bool 类型，也会多占据 1 个字节，那假设 map 中有一百万条数据，就会浪费 1MB 的空间，因此可以将值设置为 struct{}空结构，从而减少整个数据结构的大小</p>
<h4 id="22-不发送数据的信道channel"><a class="markdownIt-Anchor" href="#22-不发送数据的信道channel"></a> 2.2 不发送数据的信道(channel)</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	&lt;-ch</span><br><span class="line">	fmt.Println(<span class="string">"do something"</span>)</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> worker(ch)</span><br><span class="line">	ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Second */</span></span><br><span class="line"><span class="comment">// 创建一个信号通道</span></span><br><span class="line">waitc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">goroutine <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// 发送信号: 投递元素</span></span><br><span class="line">    waitc &lt;- <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 发送信号: 关闭</span></span><br><span class="line">    <span class="built_in">close</span>(waitc)</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// 收到信号，做出对应的动作</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-waitc:</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>有时候使用 channel 不需要发送任何的数据，只作为通知信号用来通知子协程(goroutine)执行任务，或只用来控制协程并发度。这种情况下，使用空结构体作为占位符就非常合适了。</p>
<p>这种场景我们思考下，是否一定是非 <code>struct{}</code> 不可？其实不是，而且也不多这几个字节的内存，所以这种情况真的就只是不关心 <code>chan</code> 的元素值而已，所以才用的 <code>struct{}</code>。</p>
<h4 id="23-仅包含方法的结构体"><a class="markdownIt-Anchor" href="#23-仅包含方法的结构体"></a> 2.3 仅包含方法的结构体</h4>
<p>在部分场景下，结构体只包含方法，不包含任何的字段。例如上面例子中的 <code>Door</code>，在这种情况下，<code>Door</code> 事实上可以用任何的数据结构替代。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Door <span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> Door <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>
<p>无论是 <code>int</code> 还是 <code>bool</code> 都会浪费额外的内存，因此呢，这种情况下，声明为空结构体是最合适的。</p>
<h3 id="原理分析"><a class="markdownIt-Anchor" href="#原理分析"></a> 原理分析：</h3>
<p><strong>特殊变量：zerobase</strong></p>
<p>空结构体是没有内存大小的结构体。这句话是没有错的，但是更准确的来说，其实是有一个特殊起点的，那就是 <code>zerobase</code> 变量，这是一个 <code>uintptr</code> 全局变量，占用 8 个字节。当在任何地方定义无数个 <code>struct {}</code> 类型的变量，编译器都只是把这个 <code>zerobase</code> 变量的地址给出去。换句话说，在 golang 里面，涉及到所有内存 size 为 0 的内存分配，那么就是用的同一个地址 <code>&amp;zerobase</code> 。</p>
<h3 id="内存管理特殊处理"><a class="markdownIt-Anchor" href="#内存管理特殊处理"></a> 内存管理特殊处理</h3>
<p><strong>mallocgc</strong></p>
<p>编译器在编译期间，识别到 <code>struct {}</code> 这种特殊类型的内存分配，会统统分配出 <code>runtime.zerobase</code> 的地址出去，这个代码逻辑是在 <code>mallocgc</code> 函数里面：</p>
<p>代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    <span class="comment">// 分配 size 为 0 的结构体，把全局变量 zerobase 的地址给出去即可；</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.Pointer(&amp;zerobase)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>小结：golang 使用 <code>mallocgc</code> 分配内存的时候，如果 size 为 0 的时候，统一返回的都是全局变量 <code>zerobase</code> 的地址。</p>
<p>有这种全局唯一的特殊的地址也方便后面一些逻辑的特殊处理。</p>
<p>from： <a href="https://zhuanlan.zhihu.com/p/351176221#:~:text=golang%20%E6%AD%A3%E5%B8%B8%E7%9A%84%20struct%20%E5%B0%B1%E6%98%AF%E6%99%AE%E9%80%9A%E7%9A%84%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E5%9D%97%EF%BC%8C%E5%BF%85%E5%AE%9A%E6%98%AF%E5%8D%A0%E7%94%A8%E4%B8%80%E5%B0%8F%E5%9D%97%E5%86%85%E5%AD%98%E7%9A%84%EF%BC%8C%E5%B9%B6%E4%B8%94%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF%E8%A6%81%E7%BB%8F%E8%BF%87%E8%BE%B9%E7%95%8C%EF%BC%8C%E9%95%BF%E5%BA%A6%E7%9A%84%E5%AF%B9%E9%BD%90%E7%9A%84%EF%BC%8C%E4%BD%86%E6%98%AF%E2%80%9C%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%E2%80%9D%E6%98%AF%E4%B8%8D%E5%8D%A0%E5%86%85%E5%AD%98%E7%9A%84%EF%BC%8Csize%20%E4%B8%BA%200%EF%BC%9B%20%E6%8F%90%E7%A4%BA%EF%BC%9A%E4%BB%A5%E4%B8%8B%E9%83%BD%E6%98%AF%E5%9F%BA%E4%BA%8E%20go1.13.3,%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%E6%98%AF%E6%B2%A1%E6%9C%89%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%82%20%E8%BF%99%E5%8F%A5%E8%AF%9D%E6%98%AF%E6%B2%A1%E6%9C%89%E9%94%99%E7%9A%84%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9B%B4%E5%87%86%E7%A1%AE%E7%9A%84%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%85%B6%E5%AE%9E%E6%98%AF%E6%9C%89%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E8%B5%B7%E7%82%B9%E7%9A%84%EF%BC%8C%E9%82%A3%E5%B0%B1%E6%98%AF%20zerobase%20%E5%8F%98%E9%87%8F%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%20uintptr%20%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%8C%E5%8D%A0%E7%94%A8%208%20%E4%B8%AA%E5%AD%97%E8%8A%82%E3%80%82" target="_blank" rel="noopener">Go 最细节篇 — 空结构体是什么?</a></p>
<h1 id="vscode配置go"><a class="markdownIt-Anchor" href="#vscode配置go"></a> Vscode配置Go</h1>
<h2 id="1首先安装好go"><a class="markdownIt-Anchor" href="#1首先安装好go"></a> 1.首先<a href="https://gomirrors.org/" target="_blank" rel="noopener">安装好Go</a></h2>
<h2 id="2vscode中下载go环境插件"><a class="markdownIt-Anchor" href="#2vscode中下载go环境插件"></a> 2.vscode中下载Go环境插件</h2>
<p><img src="https://i.loli.net/2021/07/27/K8MeLk2fh7O5wAR.png" alt=""></p>
<h2 id="3安装go程序插件"><a class="markdownIt-Anchor" href="#3安装go程序插件"></a> 3.安装Go程序插件</h2>
<blockquote>
<p>Go语言开发的时候为我们提供诸如代码提示、代码自动补全等功能。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开输入框</span></span><br><span class="line">ctrl + shift + p </span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入</span></span><br><span class="line">Go:Install/Update Tools</span><br></pre></td></tr></table></figure>
<p>▲由于网络问题会无法安装插件，网上老版的方法是在Go目录下从github手动下载好文件，但亲测无效，转而采用新方法如下。</p>
<h3 id="先设置goproxy"><a class="markdownIt-Anchor" href="#先设置goproxy"></a> 先设置<code>GOPROXY</code></h3>
<ul>
<li>打开终端执行以下命令：<code>go env -w GOPROXY=https://goproxy.cn,direct</code></li>
<li>环境配置中按照https://goproxy.io/zh/中写的配置Goproxy</li>
</ul>
<h3 id="重试下载插件"><a class="markdownIt-Anchor" href="#重试下载插件"></a> 重试下载插件</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开输入框</span></span><br><span class="line">ctrl + shift + p </span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入</span></span><br><span class="line">Go:Install/Update Tools</span><br></pre></td></tr></table></figure>
<h3 id="设置插件配置"><a class="markdownIt-Anchor" href="#设置插件配置"></a> 设置插件配置</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">"go.goroot": "",</span><br><span class="line">"go.gopath": "",</span><br><span class="line">"go.inferGopath": true,</span><br><span class="line">"go.autocompleteUnimportedPackages": true,</span><br><span class="line">"go.gocodePackageLookupMode": "go",</span><br><span class="line">"go.gotoSymbol.includeImports": true,</span><br><span class="line">"go.useCodeSnippetsOnFunctionSuggest": true,</span><br><span class="line">"go.useCodeSnippetsOnFunctionSuggestWithoutType": true,</span><br><span class="line">"go.docsTool": "gogetdoc",</span><br></pre></td></tr></table></figure>
<h2 id="配置go代码片段快捷键"><a class="markdownIt-Anchor" href="#配置go代码片段快捷键"></a> 配置Go代码片段快捷键</h2>
<p>还是按<code>Ctrl/Command+Shift+P</code>,按下图输入<code>&gt;snippets</code>，选择回车，然后在弹出的窗口点击选择<code>go</code>选项：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"println"</span>:&#123;</span><br><span class="line">		<span class="attr">"prefix"</span>: <span class="string">"pln"</span>,</span><br><span class="line">		<span class="attr">"body"</span>:<span class="string">"fmt.Println($0)"</span>,</span><br><span class="line">		<span class="attr">"description"</span>: <span class="string">"println"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"printf"</span>:&#123;</span><br><span class="line">		<span class="attr">"prefix"</span>: <span class="string">"plf"</span>,</span><br><span class="line">		<span class="attr">"body"</span>: <span class="string">"fmt.Printf(\"$0\")"</span>,</span><br><span class="line">		<span class="attr">"description"</span>: <span class="string">"printf"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"m"</span>:&#123;</span><br><span class="line">		<span class="attr">"prefix"</span>: <span class="string">"main"</span>,</span><br><span class="line">		<span class="attr">"body"</span>: [</span><br><span class="line">			<span class="string">"package main"</span>,</span><br><span class="line">			<span class="string">"import (\"fmt\")"</span>,</span><br><span class="line">			<span class="string">"func main() &#123;"</span>,</span><br><span class="line">			<span class="string">"$0"</span>,</span><br><span class="line">			<span class="string">"&#125;"</span></span><br><span class="line">		],</span><br><span class="line">		<span class="attr">"description"</span>: <span class="string">"main"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="vscode配置终端"><a class="markdownIt-Anchor" href="#vscode配置终端"></a> VScode配置终端</h2>
<p>在settings.json中设置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 终端设置为cmder</span><br><span class="line">"terminal.integrated.shell.windows": "cmd.exe",</span><br><span class="line">"terminal.integrated.env.windows": &#123;"CMDER_ROOT": "E:\\cmder"&#125;,</span><br><span class="line">"terminal.integrated.shellArgs.windows": ["/k", "E:\\cmder\\vendor\\init.bat"],</span><br></pre></td></tr></table></figure>
<p>from : <a href="https://www.jianshu.com/p/c3b162df3b57" target="_blank" rel="noopener">https://www.jianshu.com/p/c3b162df3b57</a></p>
<h2 id="vscode-go插件的这些用法"><a class="markdownIt-Anchor" href="#vscode-go插件的这些用法"></a> vscode-go插件的这些用法</h2>
<p>见：<a href="https://www.bilibili.com/video/BV16E411M7U2?from=search&amp;seid=14120539975802622623&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener">【教程】vscode-go插件的这些用法，你真的知道么?</a>——图文：<a href="https://blog.csdn.net/weixin_36186183/article/details/113538572" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36186183/article/details/113538572</a></p>
<ul>
<li>fill stuct：输入为 <code>接受者变量名 接受者类型 packageName.interfaceName</code></li>
<li>extract to variable: <code>go get -v github.com/godoctor/godoctor</code></li>
</ul>
<h1 id="go-module模块管理"><a class="markdownIt-Anchor" href="#go-module模块管理"></a> go module模块管理</h1>
<p><code>go module</code>是Go1.11版本之后官方推出的版本管理工具，并且从<code>Go1.13</code>版本开始，<code>go module</code>将是Go语言默认的依赖管理工具。到今天<code>Go1.14</code>版本推出之后<code>Go modules</code> 功能已经被正式推荐在生产环境下使用了。</p>
<p>一共两种情况</p>
<ul>
<li>
<p>在同一个模块下</p>
<ul>
<li>各个go文件根据go.mod下定义的模块名导入即可</li>
</ul>
</li>
<li>
<p>不在同一个模块下</p>
<ul>
<li>将无法找到的绝对引用路径在mod中进行require重定向</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── p1</span><br><span class="line">│   ├── <span class="keyword">go</span>.mod</span><br><span class="line">│   └── main.<span class="keyword">go</span></span><br><span class="line">└── p2</span><br><span class="line">    ├── <span class="keyword">go</span>.mod</span><br><span class="line">    └── p2.<span class="keyword">go</span></span><br><span class="line"><span class="comment">// p2/go.mod</span></span><br><span class="line">module liwenzhou.com/q1mi/p2</span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p1/main.go按如下方式导入p2内容</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"liwenzhou.com/q1mi/p2"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p2.New()</span><br><span class="line">	fmt.Println(<span class="string">"main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>p1/main.go</code>中想要导入<code>p2.go</code>中定义的函数。需要在<code>moduledemo/go.mod</code>中进行<code>replace</code>设置才能在moduledemo模块中使用mypackage的内容</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p1/go.mod</span></span><br><span class="line">module github.com/q1mi/p1	<span class="comment">// 当前模块名</span></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span>						<span class="comment">// go版本</span></span><br><span class="line">require <span class="string">"liwenzhou.com/q1mi/p2"</span> v0<span class="number">.0</span><span class="number">.0</span>		<span class="comment">// 指定版本</span></span><br><span class="line">replace <span class="string">"liwenzhou.com/q1mi/p2"</span> =&gt; <span class="string">"../p2"</span>	<span class="comment">// 重定向模块路径，右边为文件的相对路径</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://www.liwenzhou.com/posts/Go/import_local_package_in_go_module/" target="_blank" rel="noopener">https://www.liwenzhou.com/posts/Go/import_local_package_in_go_module/</a></p>
<h1 id="功能函数"><a class="markdownIt-Anchor" href="#功能函数"></a> 功能函数</h1>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strings库</span></span><br><span class="line">strings.Index(origin, dest)</span><br><span class="line">strings.Contains(origin, target)</span><br><span class="line">strings.Join(remainingArgs, <span class="string">"-"</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">n &lt; 0 ,用 new 替换所有匹配上的 old；n=-1: </span></span><br><span class="line"><span class="comment">用 new 替换前 5 个匹配的 old（实际多于 5 个）</span></span><br><span class="line"><span class="comment">fmt.Println("n=5: ", strings.Replace(s, old, new, 5 )) </span></span><br><span class="line"><span class="comment">用 new 替换前 7 个匹配上的 old，如果s中old数量不足7，则表现为全转换；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Replace</span><span class="params">(s, old, <span class="built_in">new</span> <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">strings</span>.<span class="title">FieldsFunc</span><span class="params">()</span> <span class="title">Golang</span>中的函数用于在每次运行的满足<span class="title">f</span><span class="params">(c)</span>的<span class="title">Unicode</span>代码点<span class="title">c</span>处拆分给定的字符串<span class="title">str</span>，并返回由<span class="title">str</span>组成的切片数组。</span></span><br><span class="line"><span class="function"><span class="title">f</span>:= <span class="title">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123; </span><br><span class="line">    <span class="keyword">return</span> unicode.IsNumber(c) </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// FieldsFunc() function splits the string passed </span></span><br><span class="line"><span class="comment">// on the return values of the function f </span></span><br><span class="line"><span class="comment">// String will therefore be split when a number </span></span><br><span class="line"><span class="comment">// is encontered and returns all non-numbers </span></span><br><span class="line">fmt.Printf(<span class="string">"Fields are:%q\n"</span>,  </span><br><span class="line">           strings.FieldsFunc(<span class="string">"ABC123PQR456XYZ789"</span>, f)) </span><br><span class="line"></span><br><span class="line"><span class="comment">// cobra是go语⾔的第三⽅命令⾏处理⼯具</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// os/exec包LookPath函数， LookPath在PATH环境变量命名的目录中搜索可执行文件(名为可执行文件), 然后得到输出其路径</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LookPath</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br><span class="line">path, err := exec.LookPath(fmt.Sprintf("%s-%s", prefix, filename))</span><br><span class="line"><span class="comment">// 执行外部命令:https://blog.csdn.net/whatday/article/details/109277998</span></span><br><span class="line">cmd := exec.Command(<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"ping 127.0.0.1"</span>)</span><br><span class="line"><span class="comment">// 1.后台运行Run一个命令 bash -c 方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CmdBash</span><span class="params">(commandName <span class="keyword">string</span>)</span> *<span class="title">exec</span>.<span class="title">Cmd</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">"/bin/bash"</span>, <span class="string">"-c"</span>, commandName)</span><br><span class="line">	fmt.Println(line)(cmd.Args)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> out bytes.Buffer</span><br><span class="line">		cmd.Stdout = &amp;out</span><br><span class="line">		cmd.Stderr = os.Stderr</span><br><span class="line">		_ = cmd.Run()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.使用管道: ps cax | grep myapp</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    grep := exec.Command(<span class="string">"grep"</span>, <span class="string">"redis"</span>)</span><br><span class="line">    ps := exec.Command(<span class="string">"ps"</span>, <span class="string">"cax"</span>)</span><br><span class="line">    <span class="comment">// Get ps's stdout and attach it to grep's stdin.</span></span><br><span class="line">    pipe, _ := ps.StdoutPipe()</span><br><span class="line">    <span class="keyword">defer</span> pipe.Close()</span><br><span class="line"></span><br><span class="line">    grep.Stdin = pipe</span><br><span class="line">    <span class="comment">// Run ps first.</span></span><br><span class="line">    ps.Start()</span><br><span class="line">    <span class="comment">// Run and get the output of grep.</span></span><br><span class="line">    res, _ := grep.Output()</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(res))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 在指定位置执行命令，为cmd变量增加Dir属性即可</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Run 阻塞进程，直到命令执行结束</span></span><br><span class="line"><span class="comment">Start 非阻塞执行</span></span><br><span class="line"><span class="comment">- Wait 阻塞进程，等待命令执行结束, 与 Star 配合使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="网络相关"><a class="markdownIt-Anchor" href="#网络相关"></a> 网络相关</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Way 1: NewRequest */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendDingMsg</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	webHook := <span class="string">`https://oapi.dingtalk.com/robot/send?access_token=04c381fc31944ad2905f31733e31fa15570ae12efc857062dab16b605a369e4c`</span></span><br><span class="line">	content := <span class="string">`&#123;"msgtype": "text",</span></span><br><span class="line"><span class="string">		"text": &#123;"content": "`</span>+ msg + <span class="string">`"&#125;</span></span><br><span class="line"><span class="string">	&#125;`</span></span><br><span class="line">    <span class="comment">//创建一个请求, func NewRequest(method, url string, body io.Reader)</span></span><br><span class="line">	req, err := http.NewRequest(<span class="string">"POST"</span>, webHook, strings.NewReader(content))	<span class="comment">// *Reader</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// handle error</span></span><br><span class="line">	&#125;</span><br><span class="line">	client := &amp;http.Client&#123;&#125;</span><br><span class="line">	<span class="comment">//设置请求头</span></span><br><span class="line">	req.Header.Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json; charset=utf-8"</span>)</span><br><span class="line">	<span class="comment">//发送请求</span></span><br><span class="line">	resp, err := client.Do(req)</span><br><span class="line">	<span class="comment">//关闭请求</span></span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// handle error</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Way2 clinet.Post */</span></span><br><span class="line">client := &amp;http.Client&#123;Timeout: <span class="number">5</span> * time.Second&#125;</span><br><span class="line">jsonStr, _ := json.Marshal(data)			<span class="comment">// []bytes</span></span><br><span class="line"><span class="comment">// Post(url, contentType string, body io.Reader) </span></span><br><span class="line">resp, err := client.Post(url, contentType, bytes.NewBuffer(jsonStr))	<span class="comment">// *Buffer</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">result, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Way3. http.PostForm(url string, data url.Values) */</span></span><br><span class="line">resp, err := http.PostForm(<span class="string">"http://example.com/form"</span>, url.Values&#123;<span class="string">"key"</span>: &#123;<span class="string">"Value"</span>&#125;, <span class="string">"id"</span>: &#123;<span class="string">"123"</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Way4. http.Post */</span></span><br><span class="line"><span class="comment">// Post(url, contentType string, body io.Reader) (resp *Response, err error)</span></span><br><span class="line">resp, err := http.Post(<span class="string">"http://example.com/upload"</span>, <span class="string">"image/jpeg"</span>, &amp;buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">    <span class="comment">// Get方法</span></span><br><span class="line">    req, err := http.Get(URL)</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li>
<p>可以看出来<code>http.NewRequest</code>和<code>http.Post</code>参数中的io.Reader接口都被Reader和Buffer实现了，因此可以传入strings.NewReader和bytes.NewBuffer</p>
</li>
<li>
<p>如果只需要设置Content-Type那么可以使用http.Post；如果想要设置更多的请求头，那么目前来看只能使用http.NewRequest</p>
<ul>
<li><a href="http://http.NewRequst+client.Do" target="_blank" rel="noopener">http.NewRequst+client.Do</a>：(请求方式，URL，参数)+加请求头</li>
<li>http.Post：（URL，content-type，data io.Reader）</li>
<li>http.PostForm：（URL,  data url.Values）</li>
<li>clinet.Post：（URL，content-type，data io.Reader），可以设置请求超时时间</li>
</ul>
<p>返回值都是(resp *Response, err error)，要想读取其内容，需要通过ioutil.ReadAll(resp.Body)得到[]byte 的content，然后再将content通过string(content)转成string类型的结果</p>
</li>
<li>
<p>对于data传参，我们希望的是能够像Python一样直接构造Dict那么简洁，而看了上述三个方法，其中url.Values是最像的。可以看到http.PostForm是可以传url.Values的，这应该是种更专门的封装。而针对其他情况下来看，NewRequest明显更普遍适用些。好在的是，http的网络请求，data都可以以strings.NewReader(string)的形式传出，因此虽然没办法直接写Json形式的Dict，但也给了我们大差不差的方式，将JsonDict用字符串来表示</p>
</li>
</ul>
<h1 id="优秀代码"><a class="markdownIt-Anchor" href="#优秀代码"></a> 优秀代码</h1>
<p>K8S：</p>
<ol>
<li>接口的使用与实现 + 结构体 ===&gt; 类</li>
<li>类Student的构造函数: NewStudent，如options.go下定义了struct Options，然后又定义了NewOptions</li>
<li>除了以类的方式暴露成员函数，还可以以package.FuncName，如scheduler.New(…,scheduler.WithPodInitialBackoffSeconds(),)</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// PluginHandler is capable of parsing command line arguments</span></span><br><span class="line"><span class="comment">// and performing executable filename lookups to search</span></span><br><span class="line"><span class="comment">// for valid plugin files, and execute found plugins.</span></span><br><span class="line"><span class="keyword">type</span> PluginHandler <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// exists at the given filename, or a boolean false.</span></span><br><span class="line">	<span class="comment">// Lookup will iterate over a list of given prefixes</span></span><br><span class="line">	<span class="comment">// in order to recognize valid plugin filenames.</span></span><br><span class="line">	<span class="comment">// The first filepath to match a prefix is returned.</span></span><br><span class="line">	Lookup(filename <span class="keyword">string</span>) (<span class="keyword">string</span>, <span class="keyword">bool</span>)</span><br><span class="line">	<span class="comment">// Execute receives an executable's filepath, a slice</span></span><br><span class="line">	<span class="comment">// of arguments, and a slice of environment variables</span></span><br><span class="line">	<span class="comment">// to relay to the executable.</span></span><br><span class="line">	Execute(executablePath <span class="keyword">string</span>, cmdArgs, environment []<span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultPluginHandler implements PluginHandler</span></span><br><span class="line"><span class="keyword">type</span> DefaultPluginHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	ValidPrefixes []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewDefaultPluginHandler instantiates the DefaultPluginHandler with a list of</span></span><br><span class="line"><span class="comment">// given filename prefixes used to identify valid plugin filenames.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultPluginHandler</span><span class="params">(validPrefixes []<span class="keyword">string</span>)</span> *<span class="title">DefaultPluginHandler</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;DefaultPluginHandler&#123;</span><br><span class="line">		ValidPrefixes: validPrefixes,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lookup implements PluginHandler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *DefaultPluginHandler)</span> <span class="title">Lookup</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, prefix := <span class="keyword">range</span> h.ValidPrefixes &#123;</span><br><span class="line">		path, err := exec.LookPath(fmt.Sprintf(<span class="string">"%s-%s"</span>, prefix, filename))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> || <span class="built_in">len</span>(path) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> path, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="string">""</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute implements PluginHandler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *DefaultPluginHandler)</span> <span class="title">Execute</span><span class="params">(executablePath <span class="keyword">string</span>, cmdArgs, environment []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Windows does not support exec syscall.</span></span><br><span class="line">	<span class="keyword">if</span> runtime.GOOS == <span class="string">"windows"</span> &#123;</span><br><span class="line">		cmd := exec.Command(executablePath, cmdArgs...)</span><br><span class="line">		cmd.Stdout = os.Stdout</span><br><span class="line">		cmd.Stderr = os.Stderr</span><br><span class="line">		cmd.Stdin = os.Stdin</span><br><span class="line">		cmd.Env = environment</span><br><span class="line">		err := cmd.Run()</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			os.Exit(<span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// invoke cmd binary relaying the environment and args given</span></span><br><span class="line">	<span class="comment">// append executablePath to cmdArgs, as execve will make first argument the "binary name".</span></span><br><span class="line">	<span class="keyword">return</span> syscall.Exec(executablePath, <span class="built_in">append</span>([]<span class="keyword">string</span>&#123;executablePath&#125;, cmdArgs...), environment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="golang新手可能会踩的50个坑"><a class="markdownIt-Anchor" href="#golang新手可能会踩的50个坑"></a> Golang新手可能会踩的50个坑：</h2>
<p><a href="https://www.topgoer.com/%E8%B5%84%E6%96%99%E4%B8%8B%E8%BD%BD/Golang%E6%96%B0%E6%89%8B%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%B8%A9%E7%9A%8450%E4%B8%AA%E5%9D%91.html" target="_blank" rel="noopener">https://www.topgoer.com/资料下载/Golang新手可能会踩的50个坑.html</a></p>
<h1 id="golang命令行库cobra的使用"><a class="markdownIt-Anchor" href="#golang命令行库cobra的使用"></a> golang命令行库Cobra的使用</h1>
<p>Cobra提供简单的接口来创建强大的现代化CLI接口，比如git与go工具。Cobra同时也是一个程序, <strong>用于创建CLI程序</strong></p>
<h2 id="cobra提供的功能"><a class="markdownIt-Anchor" href="#cobra提供的功能"></a> Cobra提供的功能</h2>
<ul>
<li>▲.简易的子命令行模式，如 app server， app fetch等等</li>
<li>完全兼容posix命令行模式</li>
<li>▲.嵌套子命令subcommand</li>
<li>支持全局，局部，串联flags</li>
<li>▲.使用Cobra很容易的生成应用程序和命令，使用cobra create appname和cobra add cmdname</li>
<li>▲.如果命令输入错误，将提供智能建议，如 app srver，将提示srver没有，是否是app server</li>
<li>▲.自动生成commands和flags的帮助信息</li>
<li>▲.自动生成详细的help信息，如app help</li>
<li>自动识别-h，–help帮助flag</li>
<li>▲.自动生成应用程序在bash下命令自动完成功能</li>
<li>自动生成应用程序的man手册</li>
<li>命令行别名</li>
<li>零活定义help和usage信息</li>
<li>可选的紧密集成的<a href="https://github.com/spf13/viper" target="_blank" rel="noopener">viper</a> apps</li>
</ul>
<h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2>
<p>Cobra是建立在结构的<strong>命令</strong>、<strong>参数</strong>和<strong>标志</strong>之上。<br>
命令代表操作,参数和标志是这些行动的修饰符。<br>
最好的应用程序就像读取句子。用户会知道如何使用本机应用程序，因为他们将理解如何使用它。</p>
<p>比如下面的例子，<code>server</code>是命令，<code>port</code>是标志:<code>hugo server --port=1313</code></p>
<p><strong>安装</strong></p>
<p>使用Cobra很简单。首先，使用<code>go get</code>安装最新版本</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="keyword">get</span> -u github.com/spf13/cobra</span><br></pre></td></tr></table></figure>
<p>然后在你项目里引用Cobra</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/spf13/cobra"</span></span><br></pre></td></tr></table></figure>
<h2 id="使用cobra库"><a class="markdownIt-Anchor" href="#使用cobra库"></a> 使用Cobra库</h2>
<p>使用Cobra，需要创建一个空的main.go文件和一个rootCmd文件。你可以选择在合适的地方添加额外的命令。</p>
<h3 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h3>
<p><strong>创建rootCmd</strong></p>
<p>Cobra不需要特殊的构造函数。简单的就可以创建你的命令。</p>
<p>理想情况下你把这个放在在 <code>app/cmd/root.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rootCmd = &amp;cobra.Command&#123;</span><br><span class="line">  Use:   <span class="string">"hugo"</span>,</span><br><span class="line">  Short: <span class="string">"Hugo is a very fast static site generator"</span>,</span><br><span class="line">  Long: <span class="string">`A Fast and Flexible Static Site Generator built with</span></span><br><span class="line"><span class="string">                love by spf13 and friends in Go.</span></span><br><span class="line"><span class="string">                Complete documentation is available at http://hugo.spf13.com`</span>,</span><br><span class="line">  Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Do Stuff Here</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := rootCmd.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会另外定义标志和处理配置init()函数。</p>
<p>所以cmd/root.go下完整的rootCmd为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/spf13/cobra"</span></span><br><span class="line">	<span class="string">"github.com/spf13/viper"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// Used for flags.</span></span><br><span class="line">	cfgFile     <span class="keyword">string</span></span><br><span class="line">	userLicense <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	rootCmd = &amp;cobra.Command&#123;</span><br><span class="line">		Use:   <span class="string">"cobra"</span>,</span><br><span class="line">		Short: <span class="string">"A generator for Cobra based Applications"</span>,</span><br><span class="line">		Long: <span class="string">`Cobra is a CLI library for Go that empowers applications.</span></span><br><span class="line"><span class="string">This application is a tool to generate the needed files</span></span><br><span class="line"><span class="string">to quickly create a Cobra application.`</span>,</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute executes the root command.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Execute</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> rootCmd.Execute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cobra.OnInitialize(initConfig)</span><br><span class="line"></span><br><span class="line">	rootCmd.PersistentFlags().StringVar(&amp;cfgFile, <span class="string">"config"</span>, <span class="string">""</span>, <span class="string">"config file (default is $HOME/.cobra.yaml)"</span>)</span><br><span class="line">	rootCmd.PersistentFlags().StringP(<span class="string">"author"</span>, <span class="string">"a"</span>, <span class="string">"YOUR NAME"</span>, <span class="string">"author name for copyright attribution"</span>)</span><br><span class="line">	rootCmd.PersistentFlags().StringVarP(&amp;userLicense, <span class="string">"license"</span>, <span class="string">"l"</span>, <span class="string">""</span>, <span class="string">"name of license for the project"</span>)</span><br><span class="line">	rootCmd.PersistentFlags().Bool(<span class="string">"viper"</span>, <span class="literal">true</span>, <span class="string">"use Viper for configuration"</span>)</span><br><span class="line">	viper.BindPFlag(<span class="string">"author"</span>, rootCmd.PersistentFlags().Lookup(<span class="string">"author"</span>))</span><br><span class="line">	viper.BindPFlag(<span class="string">"useViper"</span>, rootCmd.PersistentFlags().Lookup(<span class="string">"viper"</span>))</span><br><span class="line">	viper.SetDefault(<span class="string">"author"</span>, <span class="string">"NAME HERE &lt;EMAIL ADDRESS&gt;"</span>)</span><br><span class="line">	viper.SetDefault(<span class="string">"license"</span>, <span class="string">"apache"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// rootCmd.AddCommand(addCmd)</span></span><br><span class="line">	<span class="comment">// rootCmd.AddCommand(initCmd)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initConfig</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> cfgFile != <span class="string">""</span> &#123;</span><br><span class="line">		<span class="comment">// Use config file from the flag.</span></span><br><span class="line">		viper.SetConfigFile(cfgFile)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Find home directory.</span></span><br><span class="line">		home, err := os.UserHomeDir()</span><br><span class="line">		cobra.CheckErr(err)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Search config in home directory with name ".cobra" (without extension).</span></span><br><span class="line">		viper.AddConfigPath(home)</span><br><span class="line">		viper.SetConfigType(<span class="string">"yaml"</span>)</span><br><span class="line">		viper.SetConfigName(<span class="string">".cobra"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	viper.AutomaticEnv()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := viper.ReadInConfig(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Using config file:"</span>, viper.ConfigFileUsed())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加version命令, cmd/version.go ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/spf13/cobra"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  rootCmd.AddCommand(versionCmd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> versionCmd = &amp;cobra.Command&#123;</span><br><span class="line">  Use:   <span class="string">"version"</span>,</span><br><span class="line">  Short: <span class="string">"Print the version number of Hugo"</span>,</span><br><span class="line">  Long:  <span class="string">`All software has versions. This is Hugo's`</span>,</span><br><span class="line">  Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"this is cobra test"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部可执行文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// import "github.com/spf13/cobra/cobra/cmd"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"ctest/cmd"</span>			<span class="comment">// ctest为mod文件中的moduleName</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd.Execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合官网教程的视频：<a href="https://www.bilibili.com/video/BV16A41177o6?from=search&amp;seid=2094489749248420707&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener">https://www.bilibili.com/video/BV16A41177o6?from=search&amp;seid=2094489749248420707&amp;spm_id_from=333.337.0.0</a></p>
<p>额外使用：</p>
<h3 id="参数验证"><a class="markdownIt-Anchor" href="#参数验证"></a> 参数验证</h3>
<ul>
<li>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认情况下flag时可选的,如果你希望缺失flag的时候报错,可以标记为Required flags,如下</span></span><br><span class="line">rootCmd.Flags().StringVarP(&amp;Region, <span class="string">"region"</span>, <span class="string">"r"</span>, <span class="string">""</span>, <span class="string">"AWS region (required)"</span>)</span><br><span class="line">rootCmd.MarkFlagRequired(<span class="string">"region"</span>)</span><br><span class="line"><span class="comment">// 或者对于PersistentFlag来说</span></span><br><span class="line">rootCmd.PersistentFlags().StringVarP(&amp;Region, <span class="string">"region"</span>, <span class="string">"r"</span>, <span class="string">""</span>, <span class="string">"AWS region (required)"</span>)</span><br><span class="line">rootCmd.MarkPersistentFlagRequired(<span class="string">"region"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>Positional and Custom Arguments</strong></p>
<p>位置参数的验证,可以使用commnad的 args字段</p>
<p>下列验证器是内置的:</p>
<ul>
<li><code>NoArgs</code> - 如果没有任何参数,command会报错</li>
<li><code>ArbitraryArgs</code> - command接受任何参数</li>
<li><code>OnlyValidArgs</code> - 如果有任何位置参数不在 validArgs的范围里面, command会报错</li>
<li><code>MinimumNArgs(int)</code> - 当位置参数的个数少于n时,command 会报错</li>
<li><code>MaximumNArgs(int)</code> - 当位置参数的个数大于n时,command会报错</li>
<li><code>ExactArgs(int)</code> - 当位置参数的个数不正好是n个时,command会报错</li>
<li><code>ExactValidArgs(int)</code> - 当不是正好有n个位置参数或者有任何位置参数不属于ValidArgs,command会报错.</li>
<li><code>RangeArgs(min, max)</code> - 如果参数的个数不是在min和max之间,command会报错</li>
</ul>
<p>关于自定义验证器的一个例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cmd = &amp;cobra.Command&#123;</span><br><span class="line">  Short: <span class="string">"hello"</span>,</span><br><span class="line">  Args: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> errors.New(<span class="string">"requires a color argument"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> myapp.IsValidColor(args[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">"invalid color specified: %s"</span>, args[<span class="number">0</span>])</span><br><span class="line">  &#125;,</span><br><span class="line">  Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>预设定的模板方法：</strong></p>
<ul>
<li>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义的帮助，三种方式</span></span><br><span class="line">cmd.SetHelpCommand(cmd *Command)</span><br><span class="line">cmd.SetHelpFunc(f <span class="function"><span class="keyword">func</span><span class="params">(*Command, []<span class="keyword">string</span>)</span>)</span></span><br><span class="line"><span class="function"><span class="title">cmd</span>.<span class="title">SetHelpTemplate</span><span class="params">(s <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function">// 自定义<span class="title">usage</span>, 当用户提供了一个无效的<span class="title">flag</span>或者<span class="title">command</span>,<span class="title">cobra</span>会回复一份<span class="title">usage</span></span></span><br><span class="line"><span class="function"><span class="title">cmd</span>.<span class="title">SetUsageFunc</span><span class="params">(f <span class="keyword">func</span>(*Command)</span> <span class="title">error</span>)</span></span><br><span class="line"><span class="function"><span class="title">cmd</span>.<span class="title">SetUsageTemplate</span><span class="params">(s <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function">// 自定义<span class="title">version</span> <span class="title">flag</span></span></span><br><span class="line"><span class="function"><span class="title">cmd</span>.<span class="title">SetVersionTemplate</span><span class="params">(s <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="prerun-and-postrun-hooks"><a class="markdownIt-Anchor" href="#prerun-and-postrun-hooks"></a> PreRun and PostRun Hooks</h3>
<p>在你main函数里的run函数运行之前和之后,也是可以运行函数的.<code>PersistentPreRun</code> 和<code>PreRun</code> 函数会在<code>Run</code>之前执行,<code>PersistentPostRun</code> 和 <code>PostRun</code>会在<code>Run</code>之后执行. 符合<code>Persistent*Run</code>格式的函数如果子命令没有定义自己的Run,就会继承.这些函数的执行顺序如下:</p>
<ul>
<li><code>PersistentPreRun</code></li>
<li><code>PreRun</code></li>
<li><code>Run</code></li>
<li><code>PostRun</code></li>
<li><code>PersistentPostRun</code></li>
</ul>
<p>比较全面的使用介绍文章：<a href="https://www.jianshu.com/p/9a2870d52fe9" target="_blank" rel="noopener">golang 命令行解析库cobra的使用</a></p>
<p>为命令增加参数比较优雅的写法，from K8S</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProxyCommand</span><span class="params">()</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">	fs := cmd.Flags()</span><br><span class="line">	opts.AddFlags(fs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Options)</span> <span class="title">AddFlags</span><span class="params">(fs *pflag.FlagSet)</span></span> &#123;</span><br><span class="line">	o.addOSFlags(fs)</span><br><span class="line"></span><br><span class="line">	fs.StringVar(&amp;o.ConfigFile, <span class="string">"config"</span>, o.ConfigFile, <span class="string">"The path to the configuration file."</span>)</span><br><span class="line">	fs.StringVar(&amp;o.WriteConfigTo, <span class="string">"write-config-to"</span>, o.WriteConfigTo, <span class="string">"If set, write the default configuration values to this file and exit."</span>)</span><br><span class="line">	fs.StringVar(&amp;o.config.ClientConnection.Kubeconfig, <span class="string">"kubeconfig"</span>, o.config.ClientConnection.Kubeconfig, <span class="string">"Path to kubeconfig file with authorization information (the master location can be overridden by the master flag)."</span>)</span><br><span class="line">	fs.Float32Var(&amp;o.config.ClientConnection.QPS, <span class="string">"kube-api-qps"</span>, o.config.ClientConnection.QPS, <span class="string">"QPS to use while talking with kubernetes apiserver"</span>)</span><br><span class="line">	fs.Var(&amp;o.config.DetectLocalMode, <span class="string">"detect-local-mode"</span>, <span class="string">"Mode to use to detect local traffic"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="pflag"><a class="markdownIt-Anchor" href="#pflag"></a> pflag</h1>
<blockquote>
<p>pflag和跟cobra都是spf13组织下的。cobra不但是一个功能强大的 Golang 包，还是一个 CLI 工具，可以用来生成应用程序和命令文件，如<code>npm</code>命令，以及子命令<code>&lt;npm&gt; install</code>；而pflag主要是丰富标准库中的flag包用来处理CLI参数，如<code>--dev</code>；</p>
</blockquote>
<p>pflag 包的设计目的就是替代标准库中的 flag 包，因此它具有更强大的功能并且与标准的兼容性更好。pflag 包与 flag 包的工作原理甚至是代码实现都是类似的，下面是 pflag 相对 flag 的一些优势：</p>
<ul>
<li>支持更加精细的参数类型：例如，flag 只支持 uint 和 uint64，而 pflag 额外支持 uint8、uint16、int32 等类型。</li>
<li>支持更多参数类型：ip、ip mask、ip net、count、以及所有类型的 slice 类型。</li>
<li>兼容标准 flag 库的 Flag 和 FlagSet：pflag 更像是对 flag 的扩展。</li>
<li>原生支持更丰富的功能：支持 shorthand、deprecated、hidden 等高级功能。</li>
</ul>
<p>安装：<code>go get github.com/spf13/pflag</code></p>
<h2 id="使用说明"><a class="markdownIt-Anchor" href="#使用说明"></a> 使用说明</h2>
<p>最简单demo</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> flag <span class="string">"github.com/spf13/pflag"</span></span><br><span class="line"><span class="comment">// 一般都设置为全局变量, 局部变量也可</span></span><br><span class="line"><span class="comment">// Way1. 将输入参数用变量记录</span></span><br><span class="line"><span class="keyword">var</span> cliName = flag.StringP(<span class="string">"name"</span>, <span class="string">"n"</span>, <span class="string">"Cl"</span>, <span class="string">"请输入你的名字"</span>)</span><br><span class="line"><span class="comment">// Way2. 将输入参数保存到变量指针</span></span><br><span class="line"><span class="keyword">var</span> cliAge <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Way2. 将输入参数保存到变量指针</span></span><br><span class="line">	flag.IntVarP(&amp;cliAge, <span class="string">"age"</span>, <span class="string">"a"</span>, <span class="number">25</span>, <span class="string">"清输入你的年纪"</span>)</span><br><span class="line"></span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="built_in">println</span>(*cliName)</span><br><span class="line">	<span class="built_in">println</span>(cliAge)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到有两种赋值给变量的方式</p>
<p><strong>将输入参数用变量记录</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义命令行参数对应的变量</span></span><br><span class="line"><span class="keyword">var</span> cliName = flag.StringP(<span class="string">"name"</span>, <span class="string">"n"</span>, <span class="string">"nick"</span>, <span class="string">"Input Your Name"</span>)</span><br><span class="line"><span class="keyword">var</span> cliAge = flag.IntP(<span class="string">"age"</span>, <span class="string">"a"</span>,<span class="number">22</span>, <span class="string">"Input Your Age"</span>)</span><br><span class="line"><span class="keyword">var</span> cliGender = flag.StringP(<span class="string">"gender"</span>, <span class="string">"g"</span>,<span class="string">"male"</span>, <span class="string">"Input Your Gender"</span>)</span><br><span class="line"><span class="keyword">var</span> cliOK = flag.BoolP(<span class="string">"ok"</span>, <span class="string">"o"</span>, <span class="literal">false</span>, <span class="string">"Input Are You OK"</span>)</span><br><span class="line"><span class="keyword">var</span> cliDes = flag.StringP(<span class="string">"des-detail"</span>, <span class="string">"d"</span>, <span class="string">""</span>, <span class="string">"Input Description"</span>)</span><br><span class="line"><span class="keyword">var</span> cliOldFlag = flag.StringP(<span class="string">"badflag"</span>, <span class="string">"b"</span>, <span class="string">"just for test"</span>, <span class="string">"Input badflag"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>将输入参数保存到变量指针</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs.StringVar(&amp;o.ConfigFile, <span class="string">"config"</span>, o.ConfigFile, <span class="string">"The path to the configuration file."</span>)</span><br><span class="line">fs.StringVar(&amp;o.WriteConfigTo, <span class="string">"write-config-to"</span>, o.WriteConfigTo, <span class="string">"If set, write the default configuration values to this file and exit."</span>)</span><br></pre></td></tr></table></figure>
<p>函数原型：<code>func StringVar(p *string, name string, value string, usage string)</code>，StringVar定义了一个有指定名字，默认值，和用法说明的string标签。 参数p指向一个存储标签解析值的string变量，对应的参数输入后会被保存到p变量中。</p>
<p>这种取地址赋值的做法，可以更好、更灵活地结构化编程。</p>
<h2 id="参数输入"><a class="markdownIt-Anchor" href="#参数输入"></a> 参数输入</h2>
<blockquote>
<p><code>--</code> 表示完整的选项名称，e.g.<code>--name</code>；<code>-</code>表示 shorthand，e.g.<code>-n</code></p>
</blockquote>
<p><strong>布尔类型的参数</strong><br>
布尔类型的参数有下面几种写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--flag               // 等同于 --flag=true        </span><br><span class="line">--flag=value</span><br><span class="line">--flag value         // 这种写法只有在没有设置默认值时才生效</span><br></pre></td></tr></table></figure>
<p><strong>非布尔类型的参数</strong></p>
<p>下面是传递参数的方式和参数最终的取值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--age=30             cliAge=30</span><br><span class="line">--age                cliAge=25</span><br><span class="line">--age 30			cliAge=30</span><br><span class="line">[nothing]            cliAge=22</span><br></pre></td></tr></table></figure>
<p><strong>shorthand</strong>也是同样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-a=30</span><br><span class="line">-a</span><br><span class="line">-a 30</span><br><span class="line">[nothing]            cliAge=22</span><br></pre></td></tr></table></figure>
<p><strong>标准化参数的名称</strong><br>
如果我们创建了名称为 --des-detail 的参数，但是用户却在传参时写成了 --des_detail 或 --des.detail 会怎么样？默认情况下程序会报错退出，但是我们可以通过 pflag 提供的 SetNormalizeFunc 功能轻松的解决这个问题：</p>
<p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码">](javascript:void(0)😉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func wordSepNormalizeFunc(f *flag.FlagSet, name string) flag.NormalizedName &#123;</span><br><span class="line">    from := []string&#123;&quot;-&quot;, &quot;_&quot;&#125;</span><br><span class="line">    to := &quot;.&quot;</span><br><span class="line">    for _, sep := range from &#123;</span><br><span class="line">        name = strings.Replace(name, sep, to, -1)</span><br><span class="line">    &#125;</span><br><span class="line">    return flag.NormalizedName(name)</span><br><span class="line">&#125;</span><br><span class="line">flag.CommandLine.SetNormalizeFunc(wordSepNormalizeFunc)</span><br></pre></td></tr></table></figure>
<p><strong>标准化参数的名称</strong><br>
如果我们创建了名称为 --des-detail 的参数，但是用户却在传参时写成了 --des_detail 或 --des.detail 会怎么样？默认情况下程序会报错退出，但是我们可以通过 pflag 提供的 SetNormalizeFunc 功能轻松的解决这个问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordSepNormalizeFunc</span><span class="params">(f *flag.FlagSet, name <span class="keyword">string</span>)</span> <span class="title">flag</span>.<span class="title">NormalizedName</span></span> &#123;</span><br><span class="line">    from := []<span class="keyword">string</span>&#123;<span class="string">"-"</span>, <span class="string">"_"</span>&#125;</span><br><span class="line">    to := <span class="string">"."</span></span><br><span class="line">    <span class="keyword">for</span> _, sep := <span class="keyword">range</span> from &#123;</span><br><span class="line">        name = strings.Replace(name, sep, to, <span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag.NormalizedName(name)</span><br><span class="line">&#125;</span><br><span class="line">flag.CommandLine.SetNormalizeFunc(wordSepNormalizeFunc)</span><br></pre></td></tr></table></figure>
<p><strong>NoOptDefVal 用法</strong><br>
pflag 包支持通过简便的方式为参数设置默认值之外的值，实现方式为设置参数的 NoOptDefVal 属性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cliAge = flag.IntP(<span class="string">"age"</span>, <span class="string">"a"</span>,<span class="number">22</span>, <span class="string">"Input Your Age"</span>)</span><br><span class="line">flag.Lookup(<span class="string">"age"</span>).NoOptDefVal = <span class="string">"25"</span></span><br></pre></td></tr></table></figure>
<p>下面是传递参数的方式和参数最终的取值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parsed Arguments     Resulting Value</span><br><span class="line">--age=30             cliAge=30</span><br><span class="line">--age                cliAge=25</span><br><span class="line">[nothing]            cliAge=22</span><br></pre></td></tr></table></figure>
<p>可见，通过NoOptDefVal可以实现bool flag的效果，即如果出现该flag则设置成NoOptDefVal值</p>
<h2 id="pflagflagset"><a class="markdownIt-Anchor" href="#pflagflagset"></a> pflag.FlagSet</h2>
<p>命令参数flag集合</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddEtcdFlags adds flags related to etcd storage for a specific APIServer to the specified FlagSet</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdOptions)</span> <span class="title">AddFlags</span><span class="params">(fs *pflag.FlagSet)</span></span> &#123;</span><br><span class="line">    fs.StringSliceVar(&amp;s.EtcdServersOverrides, <span class="string">"etcd-servers-overrides"</span>, s.EtcdServersOverrides, <span class="string">""</span>+</span><br><span class="line">        <span class="string">"Per-resource etcd servers overrides, comma separated. The individual override "</span>+</span><br><span class="line">        <span class="string">"format: group/resource#servers, where servers are http://ip:port, semicolon separated."</span>)</span><br><span class="line">    fs.StringVar(&amp;s.StorageConfig.Type, <span class="string">"storage-backend"</span>, s.StorageConfig.Type,</span><br><span class="line">        <span class="string">"The storage backend for persistence. Options: 'etcd3' (default), 'etcd2'."</span>)</span><br><span class="line">    fs.IntVar(&amp;s.StorageConfig.DeserializationCacheSize, <span class="string">"deserialization-cache-size"</span>, s.StorageConfig.DeserializationCacheSize,</span><br><span class="line">        <span class="string">"Number of deserialized json objects to cache in memory."</span>)</span><br><span class="line">    fs.StringSliceVar(&amp;s.StorageConfig.ServerList, <span class="string">"etcd-servers"</span>, s.StorageConfig.ServerList,</span><br><span class="line">        <span class="string">"List of etcd servers to connect with (scheme://ip:port), comma separated."</span>)</span><br><span class="line">    fs.BoolVar(&amp;s.StorageConfig.Quorum, <span class="string">"etcd-quorum-read"</span>, s.StorageConfig.Quorum,</span><br><span class="line">        <span class="string">"If true, enable quorum read."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddFlags adds flags to fs and binds them to options.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Options)</span> <span class="title">AddFlags</span><span class="params">(fs *pflag.FlagSet)</span></span> &#123;</span><br><span class="line">	o.addOSFlags(fs)</span><br><span class="line"></span><br><span class="line">	fs.StringVar(&amp;o.ConfigFile, <span class="string">"config"</span>, o.ConfigFile, <span class="string">"The path to the configuration file."</span>)</span><br><span class="line">	fs.StringVar(&amp;o.WriteConfigTo, <span class="string">"write-config-to"</span>, o.WriteConfigTo, <span class="string">"If set, write the default configuration values to this file and exit."</span>)</span><br><span class="line">	fs.StringVar(&amp;o.config.ClientConnection.Kubeconfig, <span class="string">"kubeconfig"</span>, o.config.ClientConnection.Kubeconfig, <span class="string">"Path to kubeconfig file with authorization information (the master location can be overridden by the master flag)."</span>)</span><br><span class="line">	fs.Float32Var(&amp;o.config.ClientConnection.QPS, <span class="string">"kube-api-qps"</span>, o.config.ClientConnection.QPS, <span class="string">"QPS to use while talking with kubernetes apiserver"</span>)</span><br><span class="line">	fs.Var(&amp;o.config.DetectLocalMode, <span class="string">"detect-local-mode"</span>, <span class="string">"Mode to use to detect local traffic"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="https://nymrli.top">Mrli</a></p><p> <span>Link:  </span><a href="https://nymrli.top/2021/07/27/Go的配置和使用/">https://nymrli.top/2021/07/27/Go的配置和使用/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2021/08/11/Shiro使用学习/" title="Shiro使用学习"><span>< PreviousPost</span><br><span class="prevTitle">Shiro使用学习</span></a><a class="nextSlogan" href="/2021/03/03/天猫秒杀插件-Chrome插件编写/" title="Chrome插件编写-天猫秒杀插件"><span>NextPost ></span><br><span class="nextTitle">Chrome插件编写-天猫秒杀插件</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: 'Go的配置和使用',
  owner: 'Freedomisgood',
  repo: 'Freedomisgood.github.io',
  oauth: {
    client_id: 'bc5a81fe36017dcd8b63',
    client_secret: '949cec3a1b91742c6249c47259791e4b80a6fa69',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><p class="beian"><span>备案号:苏ICP备18015439号</span></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 60vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#go语法学习"><span class="toc-number">1.</span> <span class="toc-text"> Go语法学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#变量声明"><span class="toc-number">1.1.</span> <span class="toc-text"> 变量声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数定义"><span class="toc-number">1.2.</span> <span class="toc-text"> 函数定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-语言接口"><span class="toc-number">1.3.</span> <span class="toc-text"> Go 语言接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#切片与数组"><span class="toc-number">1.4.</span> <span class="toc-text"> 切片与数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#make"><span class="toc-number">1.5.</span> <span class="toc-text"> make</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if"><span class="toc-number">1.6.</span> <span class="toc-text"> if</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for"><span class="toc-number">1.7.</span> <span class="toc-text"> for</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map使用"><span class="toc-number">1.8.</span> <span class="toc-text"> map使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#空结构体-struct"><span class="toc-number">1.9.</span> <span class="toc-text"> 空结构体 struct{}</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#空结构体的作用"><span class="toc-number">1.9.1.</span> <span class="toc-text"> 空结构体的作用：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-实现集合set"><span class="toc-number">1.9.1.1.</span> <span class="toc-text"> 2.1 实现集合(Set)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-不发送数据的信道channel"><span class="toc-number">1.9.1.2.</span> <span class="toc-text"> 2.2 不发送数据的信道(channel)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-仅包含方法的结构体"><span class="toc-number">1.9.1.3.</span> <span class="toc-text"> 2.3 仅包含方法的结构体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理分析"><span class="toc-number">1.9.2.</span> <span class="toc-text"> 原理分析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存管理特殊处理"><span class="toc-number">1.9.3.</span> <span class="toc-text"> 内存管理特殊处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vscode配置go"><span class="toc-number">2.</span> <span class="toc-text"> Vscode配置Go</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1首先安装好go"><span class="toc-number">2.1.</span> <span class="toc-text"> 1.首先安装好Go</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2vscode中下载go环境插件"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.vscode中下载Go环境插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3安装go程序插件"><span class="toc-number">2.3.</span> <span class="toc-text"> 3.安装Go程序插件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#先设置goproxy"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 先设置GOPROXY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重试下载插件"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 重试下载插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置插件配置"><span class="toc-number">2.3.3.</span> <span class="toc-text"> 设置插件配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#配置go代码片段快捷键"><span class="toc-number">2.4.</span> <span class="toc-text"> 配置Go代码片段快捷键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vscode配置终端"><span class="toc-number">2.5.</span> <span class="toc-text"> VScode配置终端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vscode-go插件的这些用法"><span class="toc-number">2.6.</span> <span class="toc-text"> vscode-go插件的这些用法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#go-module模块管理"><span class="toc-number">3.</span> <span class="toc-text"> go module模块管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#功能函数"><span class="toc-number">4.</span> <span class="toc-text"> 功能函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#网络相关"><span class="toc-number">4.1.</span> <span class="toc-text"> 网络相关</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#优秀代码"><span class="toc-number">5.</span> <span class="toc-text"> 优秀代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#golang新手可能会踩的50个坑"><span class="toc-number">5.1.</span> <span class="toc-text"> Golang新手可能会踩的50个坑：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#golang命令行库cobra的使用"><span class="toc-number">6.</span> <span class="toc-text"> golang命令行库Cobra的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cobra提供的功能"><span class="toc-number">6.1.</span> <span class="toc-text"> Cobra提供的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#概念"><span class="toc-number">6.2.</span> <span class="toc-text"> 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用cobra库"><span class="toc-number">6.3.</span> <span class="toc-text"> 使用Cobra库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本使用"><span class="toc-number">6.3.1.</span> <span class="toc-text"> 基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参数验证"><span class="toc-number">6.3.2.</span> <span class="toc-text"> 参数验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prerun-and-postrun-hooks"><span class="toc-number">6.3.3.</span> <span class="toc-text"> PreRun and PostRun Hooks</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pflag"><span class="toc-number">7.</span> <span class="toc-text"> pflag</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用说明"><span class="toc-number">7.1.</span> <span class="toc-text"> 使用说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参数输入"><span class="toc-number">7.2.</span> <span class="toc-text"> 参数输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pflagflagset"><span class="toc-number">7.3.</span> <span class="toc-text"> pflag.FlagSet</span></a></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>