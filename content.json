{"meta":{"title":"果粒橙的博客","subtitle":"别装作很努力，因为结局不会陪你演戏。","description":"想和你讲，说了会心动 ，缄默会心安。","author":"果粒橙","url":"https://nymrli.top"},"pages":[{"title":"关于我","date":"2018-08-31T07:56:42.000Z","updated":"2018-08-31T11:25:02.929Z","comments":true,"path":"about/index.html","permalink":"https://nymrli.top/about/index.html","excerpt":"","text":"本人南邮自动化本科学生一枚.热爱捣鼓计算机,涉及Python、C、Java等语言.目前在弄Apollo,未来打算弄机器学习、数据挖掘方面"},{"title":"css","date":"2018-08-31T11:13:48.000Z","updated":"2018-08-31T11:19:21.810Z","comments":false,"path":"tags/index.html","permalink":"https://nymrli.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"开学小蓝车180天免费卡","slug":"开学小蓝车180天免费卡","date":"2018-09-02T08:44:54.000Z","updated":"2018-09-02T11:20:01.643Z","comments":true,"path":"2018/09/02/开学小蓝车180天免费卡/","link":"","permalink":"https://nymrli.top/2018/09/02/开学小蓝车180天免费卡/","excerpt":"各位看客老爷,可以加下我的公众号哦!虽然没啥东东….","text":"各位看客老爷,可以加下我的公众号哦!虽然没啥东东….","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"例题4:1-3 古老的密码、刽子手的游戏，救济金发放","slug":"例题4-1-3-古老的密码、刽子手的游戏，救济金发放","date":"2018-09-01T10:46:59.000Z","updated":"2018-09-01T12:38:41.000Z","comments":true,"path":"2018/09/01/例题4-1-3-古老的密码、刽子手的游戏，救济金发放/","link":"","permalink":"https://nymrli.top/2018/09/01/例题4-1-3-古老的密码、刽子手的游戏，救济金发放/","excerpt":"","text":"例题4-1 古老的密码 因为字母可以重排,所以顺序不重要,而又同时因为可以映射,所以字母具体是什么不重要==&gt;只要统计排序后的结果相同就行了 RE(Runtime error)错法加一: 题号提交错误 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;string.h&gt;void Bubblesort(int *cnt)//冒泡排序,从大到小顺序&#123; int i,j; int min=cnt[0]; for (i = 0; i &lt;26; ++i) &#123; for ( j = i+1; j &lt; 26; ++j) &#123; if (cnt[i] &lt; cnt[j]) &#123; min = cnt[i]; cnt[i]=cnt[j]; cnt[j] = min; &#125; &#125; &#125;&#125;int main()&#123; char s[2][105]; //存放猜测字符串的 int cnt[2][27]; //存放字母出现次数 int nlen[2]; //字符串的长度 while(scanf(\"%s%s\",s[0],s[1])!= EOF) &#123; memset(cnt,0,sizeof(cnt)); int i; for ( i = 0; i &lt; 2; ++i) &#123; nlen[i]= strlen(s[i]); int j; for ( j = 0; j &lt; nlen[i]; ++j) cnt[i][s[i][j]-'A'] ++; Bubblesort(cnt[i]); &#125; int k; for ( k = 0; k &lt; 26; ++k) &#123; if (cnt[0][k] != cnt[1][k]) &#123; printf(\"NO\\n\"); break; &#125; &#125; if (k==26) printf(\"YES\\n\" ); //如果26个字母出现次数比完全相等,则可以说相同. &#125; return 0;&#125; 例题4-2 刽子手的游戏 注意全局变量是否使用的问题,全局变量尽量少用…但维护内容较多的情况下,可以考虑 采用”自顶向下”的顺序 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 100char ans[maxn],gue[maxn];int left,chance;int win,lose;void guess(char ch)&#123; int bad=1; int i; for ( i = 0; i &lt; strlen(ans); ++i) //判断ch字母是否在字符串中 &#123; if (ans[i]==ch) &#123; ans[i] = ' '; bad =0; left--; //如果在的话,还剩未猜中字母数-1,机会不变 &#125; &#125; if (bad) chance--; //如果不在的话机会-1 if(!chance) lose=1; if(!left) win=1;&#125;int main()&#123; int rnd; while(scanf(\"%d%s%s\",&amp;rnd,ans,gue)==3 &amp;&amp; rnd !=-1) &#123; printf(\"Round %d\\n\",rnd); win = lose =0; left= strlen(ans); chance = 7; int i; int anslen=strlen(gue); for( i=0;i&lt; anslen;i++) &#123; guess(gue[i]); if(win || lose) break;&#125; if(win) printf(\"You win.\\n\"); else if(lose) printf(\"You lose.\\n\"); else printf(\"You chickened out.\\n\"); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;string.h&gt;char a[1000],g[1000];//储存字符串 int abook[26],gbook[26];//标记26个字母出现频率 int main()&#123; int k; int alen,glen; int i; int j; int suc,fau; int acount; while(scanf(\"%d\",&amp;k)==1&amp;&amp;k!=-1)&#123; scanf(\"%s%s\",a,g); memset(abook,0,sizeof(abook)); memset(gbook,0,sizeof(gbook)); alen=strlen(a); glen=strlen(g); for(i=0;i&lt;alen;i++)//统计答案字母频率 abook[a[i]-'a']++; acount=0; for(i=0;i&lt;26;i++) if(abook[i])//统计答案的字母组成个数（扣除雷同字母） acount++; suc=0;//猜对次数 fau=0;//猜错次数 for(i=0;i&lt;glen;i++)&#123;//以猜测字母为基准进行扫描 j=g[i]-'a'; if(abook[j]==0)&#123;//答案无此字母，猜测错误 fau++; if(fau==7)//彻底失败 break; &#125;else if(abook[j]!=0)&#123;//猜中字母 suc++; abook[j]=0;//将此字母从答案中剔除出去，此句比较关键!(再猜无效) if(suc==acount)//成功 break; &#125; &#125; printf(\"Round %d\\n\",k); if(fau&gt;=7)//猜错7次及以上 printf(\"You lose.\\n\"); else if(suc==acount)//全部猜对 printf(\"You win.\\n\"); else printf(\"You chickened out.\\n\"); &#125; return 0;&#125; 例题4-3 救济金发放 圆圈如何轮回==&gt;本质上是要求,大于n变成1,小于1变成n…实现1.越界后归正。2.(xxx)%n, 领过设为1,没领过(初始)设为1 较为简洁、清晰的做法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;string.h&gt;int book[100];//领过的标记1，没领过的标记0 int main()&#123; int n,k,m; int kcount,mcount; int ki,mi; int kout,mout; int first; int ncount; while(scanf(\"%d%d%d\",&amp;n,&amp;k,&amp;m)==3&amp;&amp;n&amp;&amp;k&amp;&amp;m)&#123; memset(book,0,sizeof(book)); ncount=0; ki=0; mi=n+1; first=1; while(ncount!=n)&#123;//n个人全被处理完毕//处理手法有些类似快速排序 kcount=0; mcount=0; //每数一个人,都要判断是不是该越过他.只有0(未领过,才计数) while(kcount!=k)&#123;//k系列处理 ki++; if(ki&gt;n)//ki越界处理 ki=1; if(book[ki]==0)//未被选中计数 ki为当前值 kcount++; &#125; while(mcount!=m)&#123;//m系列处理 mi--; if(mi&lt;1)//mi越界处理 mi=n; if(book[mi]==0)//未被选中计数 mi为当前值 mcount++; &#125; book[ki]=1;//不用担心ki==mi(重复设置为1不影响) book[mi]=1; if(first)&#123;//打印处理 first=0; if(ki!=mi)&#123; printf(\"%3d%3d\",ki,mi); ncount+=2; &#125; else&#123; printf(\"%3d\",ki); ncount++; &#125; &#125;else&#123; if(ki!=mi)&#123; printf(\",%3d%3d\",ki,mi); ncount+=2; &#125; else&#123; printf(\",%3d\",ki); ncount++; &#125; &#125; &#125; printf(\"\\n\"); &#125; return 0;&#125; 书上做法123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 25int n,k,m,a[maxn];int go(int p,int d,int t)&#123; while(t--) //每数一个人都要判断他是否已经领过 do&#123; p = (n+p+d)%n; &#125;while(!a[p]); //==0,领过 return p;&#125;int main()&#123; while(scanf(\"%d,%d,%d\",&amp;n,&amp;k,&amp;m)==3 &amp;&amp; n) &#123; for (int i = 0; i &lt; n; ++i) a[i]=i; int left =n; int p1 =n,p2=1; while(left) &#123; p1= go(p1,-1,k); p2= go(p2,1,m); printf(\"%d\",p1);left--; if(p1!=p2) printf(\" %d\",p2); a[p1]=a[p2]=0; //领了设置为0 if(left) printf(\",\"); //注意输出格式 &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"ACM竞赛入门","slug":"ACM竞赛入门","permalink":"https://nymrli.top/tags/ACM竞赛入门/"},{"name":"C","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"WampSever配置本地环境，解决打开打开本地网站问题","slug":"WampSever配置本地环境，解决打开打开本地网站问题","date":"2018-09-01T06:19:39.000Z","updated":"2018-09-01T06:26:52.393Z","comments":true,"path":"2018/09/01/WampSever配置本地环境，解决打开打开本地网站问题/","link":"","permalink":"https://nymrli.top/2018/09/01/WampSever配置本地环境，解决打开打开本地网站问题/","excerpt":"","text":"WampServer是一款由法国人开发的Apache Web服务器、PHP解释器以及MySQL数据库的整合软件包。免去了开发人员将时间花费在繁琐的配置环境过程，从而腾出更多精力去做开发。 直接点击本地的.html是静态加载的，需要动态加载的文件是无法被加载的。会出现如下情况。 于是选用了Wamp搭本地服务器浏览网站，这样就能成功加载动态文件了。 在此分享下配置WampSever时碰到的问题和解决的方法： 服务器是否已正常运行如果能登上则表示服务器能够正常运行。(在地址栏中输入localhost:端口(或是127.0.0.1:端口) 或是左键图标选择’localhost’) localhost 指你所在的计算机本身。 在windows系统它成了127.0.0.1的别名 ，在Unix系统下，查看网卡配置会发现作为本地回环的方式，一定程度上使用localhost比127.0.0.1要快一些。 在Hosts文件中，localhost指向的IP是127.0.0.1这个关系是可以修改的。 查看、修改端口 配置本地环境、添加项目、打开本地网站 1项目中是空的,需要手动将要打开的网站放到'www'目录中 1可以选择输入路径，也可以直接左键选择'www目录'打开 1将要打开网站的文件夹复制到'www目录下'，会发现刚添加的文件夹出现在了项目中。 勾选’Add localhost in url’1看似到此已经大功告成，然而再点击进去这些文件夹时会出现如下情况： 1可以看到的是URL并不对，我们是想要实现通过web服务器的方式访问这些网站，然而这个明显没达到我们想要的效果，根据提示，我找到了原因。 1右键选择'Wamp Settings'中将'Add localhost in url'选项勾上后再次如上打开项目即可。（记得重新打开一次localhost页面或是刷新一下） 1可以看到网站成功地通过web服务器打开了，那些之前提示需要动态加载的文件也成功加载了。 撒花完结！~200成功！ ▲.看到这，我相信你也明白了为什么必须要有’Add localhost in url’这步了。同时也猜到了，其实直接在网址里面输入正确的网址也是可以的，如http://localhost:8080/data-visualize-chain-master/,结果也是能打开的。 希望能对你们有所帮助。","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"WAMP","slug":"WAMP","permalink":"https://nymrli.top/tags/WAMP/"}]},{"title":"Ubuntu下Sublime配置Python环境使用指导:","slug":"Ubuntu下Sublime配置Python环境使用指导","date":"2018-09-01T06:04:47.000Z","updated":"2018-09-01T06:26:28.406Z","comments":true,"path":"2018/09/01/Ubuntu下Sublime配置Python环境使用指导/","link":"","permalink":"https://nymrli.top/2018/09/01/Ubuntu下Sublime配置Python环境使用指导/","excerpt":"","text":"Sublime配置python编译环境及搭建虚拟环境:(windows下大致相同)1.编译环境配置1import urllib.request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 1.点击 官方网址 从 Sublime Text 3 官方获取用于安装的代码。从菜单栏View –&gt;Show Console或者使用Ctrl+`(esc键下面的按键)，调出sublime的控制台，将官网中的python代码粘贴进去并按Enter执行，最终可以安装完成。在控制台中粘贴刚才的代码，然后点击回车。最后重启ST3。 2.现在你可以通过快捷键 cmd+shift+P 打开 Package Control 来安装其他的插件了。输入 install 然后你就能看见屏幕上出现了 Package Control: Install Package，点击回车,然后搜索sublimeREPL 安装成功后，可以在菜单栏的’TOOL’中找到SublimeREPL，如图所示 2.将菜单栏改为中文若需要将菜单栏改成中文可如上操作下载插件“ConvertToUTF8”或是安装插件“ChineseLocalizations”(本人使用的是这个，没试ConvertToUTF8的效果) (参考博客:http://blog.51cto.com/11970781/2087971) 3.安装Anaconda插件 1.点击刚刚生成的Package Control -&gt;输入install 2.进入安装界面，安装好后再在新窗口命令行中输入Anaconda并点击第一个备选项进行安装。 安装完成后会显示messages文档。 安装Anaconda插件完成之后，会看到如下选项栏，说明Anaconda安装成功。 - Goto Definitions 能够在你的整个工程中查找并且显示任意一个变量，函数或者类的定义。 - Find Usage 能够快速的查找某个变量，函数或者类在某个特定文件中的什么地方被使用了。 - Show Documentation： 能够显示一个函数或者类的说明性字符串(当然，是在定义了字符串的情况下) Anaconda会自动补全代码，之前用惯了pycharm发现突然没了代码补全后很不习惯，Anaconda的补全功能虽然没有pycharm那么好用，但还是不错的 还有需要注意的是，安装Anaconda插件后，如果python代码没有遵循PEP8规范，会出现白色的框框，或是可以使用快捷键Ctrl+Alt+R进行规范代码(这个可以去除，步骤如下) 在Settings-User选项中添加配置:{“anaconda_linting”:false} 4.安装虚拟环境 1.首先使用终端安装virtualenv，pip3 install virtualenv2.在需要创建的地方进行虚拟环境的搭建，代码如下： 123mkdir pytest(文件夹名)cd pytestvirtualenv venv 在终端进入虚拟环境的话是在pytest文件夹下输入命令source /bin/activate而要在sublime中进入虚拟环境的话就得按照如下操作： １．首先在sublime中安装virtualenv插件，Ctrl + Shift + P，然后输入install,回车，然后搜索virtualenv。 2. 安装完成后，直接按Ctrl + Shift + P，再输入Activate，若没有该选项则virtualenv安装中出现问题，需要重新安装。如果有的会选择Activate就能发现刚刚创建的虚拟环境，选中后回车即可进入虚拟环境 3. 如果Activate选中后没有出现我们刚刚创建的虚拟环境，则需要我们手动添加路径.Ctrl + Shift + P，然后输入Add directory，回车，屏幕下面会出现输入行（Directory path）:再将刚创建的虚拟环境路径填入即可 另外，我曾碰到过Add directory后仍然没用的情况。那时，可选择“”Project”=&gt;”Add folder to project”选择文件后=&gt;”Save Project as”==&gt;保存好即可 工程配置文件为： .sublime-workspace、.sublime-project 其中sublime-project为: 123456789101112131415161718&#123; \"build_systems\": [ &#123; \"file_regex\": \"^[ ]File \"(...?)\", line ([0-9]*)\", \"name\": \"Anaconda Python Builder\", \"selector\": \"source.python\", \"shell_cmd\": \"\"python\" -u \"$file\"\" &#125; ], \"folders\": [ &#123; \"path\": \"爬虫\" &#125; ], \"virtualenv\": \"G:\\pachong\\venv\"&#125; 这样环境就配置好了。按Ctrl+B编译时，观察”Tools”-&gt;”Build System”-&gt;是否为”Python+ Virtualenv”，如果不是，则选用这个再Ctrl+B就是在虚拟环境中编译了! ubuntu下sublime默认情况下好像不能输入中文，需要用下面命令就可以完美支持中文输入： 1234sudo apt-get update &amp;&amp; sudo apt-get upgradegit clone https://github.com/lyfeyaj/sublime-text-imfix.gitcd sublime-text-imfix./sublime-imfix 转自CV_YOU的博客 完美解决Sublime无法输入中文问题 截图好像有点问题，菜单栏都没有截到，用到的三个分别为“项目(Project)”，“首选项(Preferences)”，“帮助(Help)”","categories":[],"tags":[{"name":"Sublime Text","slug":"Sublime-Text","permalink":"https://nymrli.top/tags/Sublime-Text/"},{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"}]},{"title":"python pywin32 PyUserInput实现自动化脚本","slug":"python-win32api-win32gui-win32con-PyUserInput实现自动化脚本","date":"2018-08-31T11:43:00.000Z","updated":"2018-08-31T11:56:56.677Z","comments":true,"path":"2018/08/31/python-win32api-win32gui-win32con-PyUserInput实现自动化脚本/","link":"","permalink":"https://nymrli.top/2018/08/31/python-win32api-win32gui-win32con-PyUserInput实现自动化脚本/","excerpt":"","text":"pywin32用spy++工具查找到句柄，再结合PyUserInput就能很好地实现自动化脚本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152import win32guiimport win32conimport win32api# 从顶层窗口向下搜索主窗口，无法搜索子窗口# FindWindow(lpClassName=None, lpWindowName=None) 窗口类名 窗口标题名handle = win32gui.FindWindow(\"Notepad\", None) # 获取窗口位置left, top, right, bottom = win32gui.GetWindowRect(handle)#获取某个句柄的类名和标题title = win32gui.GetWindowText(handle) clsname = win32gui.GetClassName(handle)# 打印句柄# 十进制print(handle)# 十六进制print(\"%x\" %(handle) )# 搜索子窗口# 枚举子窗口hwndChildList = [] win32gui.EnumChildWindows(handle, lambda hwnd, param: param.append(hwnd), hwndChildList)# FindWindowEx(hwndParent=0, hwndChildAfter=0, lpszClass=None, lpszWindow=None) # 父窗口句柄 若不为0，则按照z-index的顺序从hwndChildAfter向后开始搜索子窗体，否则从第一个子窗体开始搜索。 子窗口类名 子窗口标题subHandle = win32gui.FindWindowEx(handle, 0, \"EDIT\", None)# 获得窗口的菜单句柄menuHandle = win32gui.GetMenu(subHandle)# 获得子菜单或下拉菜单句柄 # 参数：菜单句柄 子菜单索引号subMenuHandle = win32gui.GetSubMenu(menuHandle, 0)# 获得菜单项中的的标志符，注意，分隔符是被编入索引的 # 参数：子菜单句柄 项目索引号 menuItemHandle = win32gui.GetMenuItemID(subMenuHandle, 0)# 发送消息，加入消息队列，无返回 # 参数：句柄 消息类型 WParam IParamwin32gui.postMessage(subHandle, win32con.WM_COMMAND, menuItemHandle, 0)# wParam的定义是32位整型，high word就是他的31至16位，low word是它的15至0位。# 当参数超过两个，wParam和lParam不够用时，可以将wParam就给拆成两个int16来使用。# 这种时候在python里记得用把HIWORD的常数向左移16位，再加LOWORD，即wParam = HIWORD&lt;&lt;16+LOWORD。# 下选框内容更改# 参数：下选框句柄； 消息内容； #参数下选框的哪一个item，以0起始的待选选项的索引；如果该值为-1，将从组合框列表中删除当前选项，并使当前选项为空；# 参数CB_Handle为下选框句柄，PCB_handle下选框父窗口句柄if win32api.SendMessage(CB_handle, win32con.CB_SETCURSEL, 1, 0) == 1:# 下选框的父窗口命令# 参数：父窗口句柄； 命令； # 参数：WParam：高位表示类型，低位表示内容；参数IParam，下选框句柄# CBN_SELENDOK当用户选择了有效的列表项时发送，提示父窗体处理用户的选择。 LOWORD为组合框的ID. HIWORD为CBN_SELENDOK的值。 win32api.SendMessage(PCB_handle, win32con.WM_COMMAND, 0x90000, CB_handle) # CBN_SELCHANGE当用户更改了列表项的选择时发送，不论用户是通过鼠标选择或是通过方向键选择都会发送此通知。LOWORD为组合框的ID. HIWORD为CBN_SELCHANGE的值。 win32api.SendMessage(PCB_handle, win32con.WM_COMMAND, 0x10000, CB_handle) # 设置文本框内容，等窗口处理完毕后返回true。中文需编码成gbk # 参数：句柄；消息类型；# 参数WParam，无需使用； # 参数IParam，要设置的内容，字符串win32api.SendMessage(handle, win32con.WM_SETTEXT, 0, os.path.abspath(fgFilePath).encode('gbk'))# 控件点击确定,处理消息后返回0# 参数:窗口句柄; 消息类型; 参数WParam HIWORD为0（未使用），LOWORD为控件的ID; 参数IParam 0（未使用）,确定控件的句柄win32api.SendMessage(Mhandle, win32con.WM_COMMAND, 1, confirmBTN_handle)# 获取窗口文本不含截尾空字符的长度# 参数：窗口句柄； 消息类型； 参数WParam； 参数IParambufSize = win32api.SendMessage(subHandle, win32con.WM_GETTEXTLENGTH, 0, 0) +1# 利用api生成BufferstrBuf = win32gui.PyMakeBuffer(bufSize)print(strBuf)# 发送消息获取文本内容# 参数：窗口句柄； 消息类型；文本大小； 存储位置length = win32gui.SendMessage(subHandle, win32con.WM_GETTEXT, bufSize, strBuf)# 反向内容，转为字符串# text = str(strBuf[:-1])address, length = win32gui.PyGetBufferAddressAndLen(strBuf) text = win32gui.PyGetString(address, length) # print('text: ', text)# 鼠标单击事件#鼠标定位到(30,50)win32api.SetCursorPos([30,150])#执行左单键击，若需要双击则延时几毫秒再点击一次即可win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP | win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)#右键单击win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTUP | win32con.MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0)def click1(x,y): #第一种 win32api.SetCursorPos((x,y)) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN,x,y,0,0) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP,x,y,0,0)def click2(x,y): #第二种 ctypes.windll.user32.SetCursorPos(x,y) ctypes.windll.user32.mouse_event(2,0,0,0,0) ctypes.windll.user32.mouse_event(4,0,0,0,0)def click_it(pos): #第三种 handle= win32gui.WindowFromPoint(pos) client_pos =win32gui.ScreenToClient(handle,pos) tmp=win32api.MAKELONG(client_pos[0],client_pos[1]) win32gui.SendMessage(handle, win32con.WM_ACTIVATE,win32con.WA_ACTIVE,0) win32gui.SendMessage(handle, win32con.WM_LBUTTONDOWN,win32con.MK_LBUTTON,tmp) win32gui.SendMessage(handle, win32con.WM_LBUTTONUP,win32con.MK_LBUTTON,tmp)# 发送回车win32api.keybd_event(13,0,0,0)win32api.keybd_event(13,0,win32con.KEYEVENTF_KEYUP,0)# 关闭窗口win32gui.PostMessage(win32lib.findWindow(classname, titlename), win32con.WM_CLOSE, 0, 0)# 检查窗口是否最小化，如果是最大化if(win32gui.IsIconic(hwnd)):# win32gui.ShowWindow(hwnd, win32con.SW_SHOWNORMAL) win32gui.ShowWindow(hwnd, 8) sleep(0.5)# SW_HIDE：隐藏窗口并激活其他窗口。nCmdShow=0。# SW_MAXIMIZE：最大化指定的窗口。nCmdShow=3。# SW_MINIMIZE：最小化指定的窗口并且激活在Z序中的下一个顶层窗口。nCmdShow=6。# SW_RESTORE：激活并显示窗口。如果窗口最小化或最大化，则系统将窗口恢复到原来的尺寸和位置。在恢复最小化窗口时，应用程序应该指定这个标志。nCmdShow=9。# SW_SHOW：在窗口原来的位置以原来的尺寸激活和显示窗口。nCmdShow=5。# SW_SHOWDEFAULT：依据在STARTUPINFO结构中指定的SW_FLAG标志设定显示状态，STARTUPINFO 结构是由启动应用程序的程序传递给CreateProcess函数的。nCmdShow=10。# SW_SHOWMAXIMIZED：激活窗口并将其最大化。nCmdShow=3。# SW_SHOWMINIMIZED：激活窗口并将其最小化。nCmdShow=2。# SW_SHOWMINNOACTIVE：窗口最小化，激活窗口仍然维持激活状态。nCmdShow=7。# SW_SHOWNA：以窗口原来的状态显示窗口。激活窗口仍然维持激活状态。nCmdShow=8。# SW_SHOWNOACTIVATE：以窗口最近一次的大小和状态显示窗口。激活窗口仍然维持激活状态。nCmdShow=4。# SW_SHOWNORMAL：激活并显示一个窗口。如果窗口被最小化或最大化，系统将其恢复到原来的尺寸和大小。应用程序在第一次显示窗口的时候应该指定此标志。nCmdShow=1。 感谢python win32api win32gui win32con 窗口句柄 发送消息 常用方法 键盘输入，代码主要来自于他 ▲.需要注意在windows和mac下接口参数可能有所不同。win32虽然也可控制键盘，但不如使用PyUserInput的方便。安装PyUserInput教程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pymouse import PyMousefrom pykeyboard import PyKeyboard#实例化m = PyMouse() k = PyKeyboard()x_dim, y_dim = m.screen_size()# 鼠标点击 参数:x,y,button=1(左键)、2(右键)、3(中间),次数m.click(x_dim, y_dim, button=1,n=1) # 键盘输入 参数:str,间隔k.type_string('Hello, World!',interval=0)# 按住一个键k.press_key('H')# 松开一个键k.release_key('H')# 相当于===&gt;按住并松开，tap一个键k.tap_key('e')# tap支持重复的间歇点击键,参数:str,次数,间隔k.tap_key('l',n=2,interval=5) #创建组合键===&gt;press_key和release_key结合使用k.press_key(k.alt_key)k.tap_key(k.tab_key)k.release_key(k.alt_key)# 特殊功能键k.tap_key(k.function_keys[5]) # Tap F5k.tap_key(k.numpad_keys['Home']) # Tap 'Home' on the numpadk.tap_key(k.numpad_keys[5], n=3) # Tap 5 on the numpad, thrice# Mac系统按键k.press_keys(['Command','shift','3'])# Windows系统按键k.press_keys([k.windows_l_key,'d'])其中pymouse的PyMouseEvent和pykeyboard的PyKeyboardEvent还可用于监听鼠标和键盘事件的输入class Clickonacci(PyMouseEvent): def __init__(self): PyMouseEvent.__init__(self) self.fibo = fibo() def click(self, x, y, button, press): '''Print Fibonacci numbers when the left click is pressed.''' if button == 1: if press: print('Press times:%d'.format(press)) else: # Exit if any other mouse button used self.stop()C = Clickonacci()C.run()class TapRecord(PyKeyboardEvent): def __init__(self): PyKeyboardEvent.__init__(self) def tap(self, keycode, character, press): print(time.time(), keycode, character, press)t = TapRecord()t.run()#这些对象是一个架构用于监听鼠标和键盘的输入；他们除了监听之外不会做任何事，需要继承重构他们#PyKeyboardEvent为编写完成，所以这里是一个继承PyMouseEvent的例子：","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"}]},{"title":"Hello 搭建Hexo博客","slug":"hello-hexo","date":"2018-08-30T13:14:27.000Z","updated":"2018-09-01T10:33:39.636Z","comments":true,"path":"2018/08/30/hello-hexo/","link":"","permalink":"https://nymrli.top/2018/08/30/hello-hexo/","excerpt":"","text":"电脑环境是Windows，安装好git后，所有搭建操作均在git bash内完成 1.需要安装git, node.js, npm 注:第一次安装Git会让配置user信息 123&gt; $git config --global user.name \"yourname\" #（yourname是git的用户名）&gt; $git config --global user.email \"youremail\"）&gt; 2.使用npm安装hexo： npm install -g hexo3.创建hexo文件夹，并单击鼠标右键选择 Git bash：(我的创建路径是：E:\\hexo）4.在刚刚打开的git bash命令框中操作：1234$hexo init #hexo 会自动创建网站所需要的文件$npm install #安装依赖包$hexo generate # 等价于hexo g$hexo server #现在可以用127.0.0.1:4000访问hexo默认的hello world界面,等价于hexo s 5.部署到github (https://github.com/)， 首先注册登录,然后创建页面仓库，Repository name 命名必须是 youname.github.io ，（youname 就是你注册时候用的name） ssh-keygen -t rsa -C &quot;email&quot; #生成ssh密钥，按三次回车键，密码为空,这边会生成id_rsa和_rsa.pub文件，打开id_rsa.pub，复制全文添加到GitHub 的Add SSH key中。 最后可以验证一下ssh -T git@github.com,看出现的是不是Hi &quot;Yourname&quot;如果出现了你的github用户名,则成功了 6.下载Hexo主题 $git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia #下载hexo的yilia 模板到自己的文件目录下 打开项目目录下的_config.yml文件，更改theme：yilia ▲注意: _config.yml文件中配置时:后面都要加空格,与:隔开 7.开启评论功能：使用gitment$npm install gitment --save #安装gitment 然后在 https://github.com/settings/applications/new 进行注册，获取Client ID和Client Secret ▲注意:其中Authorization callback URL是个坑: 这一项不能乱填,不让就不能&quot;初始化评论&quot;.. 应该怎么填呢? 如果你绑定了自己的域名就直接写自己的域名: https://nymrli.top/ 如果没有的话才填写http://Freedomisgood.github.io,否则会一直弹回博客首页,而不能”初始化评论”或者”发表评论” 其中的原因就在于,既可以通过www.nymrli.top解析，也可通过nymrli.top解析,还可以通http://Freedomisgood.github.io解析,而Authorization callback URL只能写一个.(最终解析到的网站)…===&gt;就是nymrli.top △.感谢IsResultXaL提供的思路 打开themes/yilia目录下的_config.yml文件进行修改并保存： 再次生成网站,提交网站:hexo d -g就可以输入网址:https://yourname.github.io打开你的博客了 8.显示文章摘要图片 1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 在hexo目录下打开git Bsh或者power Shell,npm install hexo-asset-image --save安装插件 再运行hexo n &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： 1![你想输入的替代文字](xxxx/图片名.jpg) ▲ .之前一直失败,原因在于,我写图片链接的时候是直接拖动图片到编辑器中的,路径为![v2-代替文字](E:\\hexo\\source\\_posts\\xxxx\\图片名.jpg),后来一直错误,无法正常显示后，发现只需要写成![代替文字](xxxx\\图片名.jpg)即可.. 文章总体框架:12345678910---layout: phototitle: Hello Hexodate: 2018-08-30 21:14:27tags: - hexo---![代替文字](xxxx\\图片名.jpg)&lt;!--more--&gt;正文 →推一个不错的文章Hexo+Coding+Github部署个人博客Error全集,如果出现未能解决的问题,希望能从这篇文章略微得到启发.","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"hexo","slug":"hexo","permalink":"https://nymrli.top/tags/hexo/"}]},{"title":"Python字典基本操作介绍","slug":"Python字典基本操作介绍","date":"2018-08-30T13:14:27.000Z","updated":"2018-09-01T06:03:37.532Z","comments":true,"path":"2018/08/30/Python字典基本操作介绍/","link":"","permalink":"https://nymrli.top/2018/08/30/Python字典基本操作介绍/","excerpt":"","text":"创建字典 info={} info=dict() 初始化字典法一123key = 'name'info = &#123; key 'cold'&#125;==&#123;'name''cold'&#125; 法二12info = dict(key = 'cold')==&#123;'key''cold'&#125; 法三1#还有可以使用dict(zip(a,b))其中a,b都是列表,会生成以A中元素为键,B中元素为值的字典 插入新的键值对(更新) info.update(name=’cold’, blog=’www.linuxzen.com&#39;) 在字典有没有k这个键时可以使用dict.setdefault(key,value) 还可以使用dict(var = value)其中var可以是变量,也可以不是,注意不用加 或是_dict[‘xxx’]=’yyy’ 获得键值 确定存在的情况下- info.get(‘xxx’) info[‘xxx’] 不确定是否存在 info.get(‘xxx’) 遍历字典 获得key,再通过key来获得valuefor key in dicprint(%d,%d%(key,_dict[key])) 使用dict.items()for key,value in dic.items()print ‘key is %s,value is %s’%(key,value) 字典删除del info[&#39;xxx&#39;]","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]}]}