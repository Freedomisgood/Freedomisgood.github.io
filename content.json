{"meta":{"title":"果粒橙的博客","subtitle":"别装作很努力，因为结局不会陪你演戏。","description":"想和你讲，说了会心动 ，缄默会心安。","author":"果粒橙","url":"https://nymrli.top"},"pages":[{"title":"关于我","date":"2018-08-31T07:56:42.000Z","updated":"2018-09-04T04:36:10.718Z","comments":true,"path":"about/index.html","permalink":"https://nymrli.top/about/index.html","excerpt":"","text":"本人南邮自动化本科学生一枚.热爱捣鼓计算机,涉及Python、C、Java等语言.参加Robocup,ACM,未来打算弄机器学习、数据挖掘方面"},{"title":"css","date":"2018-08-31T11:13:48.000Z","updated":"2018-08-31T11:19:21.810Z","comments":false,"path":"tags/index.html","permalink":"https://nymrli.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"\\r - \\n - \\r\\n的区别","slug":"回车和换行区别","date":"2018-10-13T12:33:33.000Z","updated":"2018-10-13T12:34:31.882Z","comments":true,"path":"2018/10/13/回车和换行区别/","link":"","permalink":"https://nymrli.top/2018/10/13/回车和换行区别/","excerpt":"","text":"\\r - \\n - \\r\\n 的区别代码演示:123456781: string s1 = \"已经习惯了回车和换行一次搞定\\n，敲一个回车键，即是回\";2: 3: Console.WriteLine(s1);4: s1 = \"已经习惯了回车和换行一次搞定\\r，敲一个回车键，即是回\";5: Console.WriteLine(s1);6: s1 = \"已经习惯了回车和换行一次搞定\\r\\n，敲一个回车键，即是回\";7: Console.WriteLine(s1);8: Console.ReadLine(); Result:==&gt; 回车、换行的区别: \\r , \\n, \\r\\n的区别其实是回车与换行的区别 符号 ASCII码 意义 \\n 10 换行 \\r 13 回车CR 先来段历史 回车”（Carriage Return）和“换行”（Line Feed）这两个概念的来历和区别。 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33，Linux/Unix下的tty概念也来自于此）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。 于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。 后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。 在Windows中： ‘\\r’ 回车，回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖； ‘\\n’ 换行，换到当前位置的下一行，而不会回到行首； Unix系统里，每行结尾只有“&lt;换行&gt;”，即”\\n”；Windows系统里面，每行结尾是“&lt;回车&gt;&lt;换行&gt;”，即“\\r\\n”；Mac系统里，每行结尾是“&lt;回车&gt;”，即”\\r”；。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。 例 $ echo -en &#39;12\\n34\\r56\\n\\r78\\r\\n&#39; &gt; tmp.txt ==&gt;Linux中遇到换行符(“\\n”)会进行回车+换行的操作，回车符反而只会作为控制字符(“^M”)显示，不发生回车的操作。而windows中要回车符+换行符(“\\r\\n”)才会回车+换行，缺少一个控制符或者顺序不对都不能正确的另起一行。 ▲注意点： 在解析文本或其他格式的文件内容时，常常要碰到判定回车换行的地方，这个时候就要注意既要判定”**r**\\n”又要判定”\\n”。 写程序时可能得到一行,将其进行trim掉’**r**’,这样能得到你所需要的string了。 拓展程序测试 123456789101112131415161718192021222324252627282930/*==========================程序二===============================*/#include &lt;stdio.h&gt;int main(void)&#123; int i; FILE *fp; if((fp=fopen(\"test.txt\",\"w\")) == NULL) &#123; fprintf(stderr,\"open file error\\n\"); return 1; &#125; for(i=0;i&lt;100;i++) fprintf(fp,\"test\\n\"); fclose(fp); return 0;&#125;/*==========================程序二===============================*/#include &lt;stdio.h&gt;int main(void)&#123; int i; FILE *fp; if((fp=fopen(\"test.bin\",\"wb\")) == NULL) &#123; fprintf(stderr,\"open file error\\n\"); return 1; &#125; for(i=0;i&lt;100;i++) fprintf(fp,\"test\\n\"); fclose(fp); return 0;&#125; ​ 程序一输出文件大小是600字节，程序二输出文件大小是500字节，用记事本打开程序一的输出没有什么问题，每行一个test，打开程序二的输出发现所有的test连成一行，test之间是一个黑色方框符号分隔。用UltraEdit-32以16进制编辑模式打开test.bin可以查看到黑色方框符号就是0A也就是\\n，打开test.txt则会发现换行是\\r\\n，这就是两个文件大小相差100字节的原因。Unix类系统用户打开windows中的文件就会遇到这种苦恼。为什么会有这种区别呢？ 毕竟是源自Unix系统，C语言中使用\\n表示换行，而在实际的文件中换行符号需要同操作系统一致，所以当我们在C中使用fopen打开一个文本文件时流实现了实际换行符与C中\\n之间的转换。在windows中当我们用fopen打开文本文件，然后从中读到\\r\\n时流会转换为\\n，而当我们往文件中写入\\n时流会转换为\\r\\n。程序一是打开文本文件，程序二打开的是二进制文件，因为流只对文本文件进行换行表示的转换，以二进制模式打开流不会做任何处理。所以当你以二进制模式打开一个文本文件时将产生错乱，你必须亲自将\\r\\n解释为\\n,同样的问题也会出现在以文本模式打开二进制文件的情况.这也解释了为什么Unix类系统中的文件不区分文本文件和二进制文件的原因。 当我们使用标准输入输出函数时有这种情况吗？再回到我们熟悉的标准输入输出stdin,stdout​ C的控制台程序在加载进内存成为进程运行前C运行时库自动打开三个设备并关联到三个流：标准输入流stdin，标准输出流stdout，标准出错流stderr ​ 通常在通用计算机中，没有重定向前这三个流对应的设备是：键盘，显示器，显示器。这三个都是字符设备，所以是以文本文件的模式打开的，在windows下当我们在键盘上敲入回车键时产生字符\\r\\n，但是在OS内核把键盘驱动中读到的字符发送给流的缓冲区时流会将之转换为\\n，当我们向控制台输出\\n时流将之转换为\\r\\n再传递至内核，当我们绕过标准输入输出直接调用windows中coredll.lib进行控制台输入输出时就必须面对这一现实，程序员负责实现这一转换。 摘自:https://www.cnblogs.com/xiaotiannet/p/3510586.html","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"https://nymrli.top/tags/编程/"}]},{"title":"云服务器Ubuntu更改默认python版本","slug":"云服务器Ubuntu更改默认python版本","date":"2018-10-12T05:07:48.000Z","updated":"2018-10-12T05:08:26.679Z","comments":true,"path":"2018/10/12/云服务器Ubuntu更改默认python版本/","link":"","permalink":"https://nymrli.top/2018/10/12/云服务器Ubuntu更改默认python版本/","excerpt":"","text":"云服务器Ubuntu更改默认python版本1、基于用户修改 Python 版本：想要为某个特定用户修改 Python 版本，只需要在其 home 目录下创建一个 alias(别名) 即可。打开该用户的 ~/.bashrc文件，添加新的别名信息来修改默认使用的 Python 版本。 vim ~/.bashrc 增加一行alias python=python3 source ~/.bashrc再输入python --version,就能发现显示的是Python 3.x啦 2、 在系统级修改 Python 版本(建议)12# update-alternatives --list pythonupdate-alternatives: error: no alternatives for python 如果出现以上所示的错误信息，则表示 Python 的替代版本尚未被 update-alternatives 命令识别。想解决这个问题，我们需要更新一下替代列表，将 python2.7 和 python3.4 放入其中。 1234# update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1update-alternatives: using /usr/bin/python2.7 to provide /usr/bin/python (python) in auto mode# update-alternatives --install /usr/bin/python python /usr/bin/python3.4 2update-alternatives: using /usr/bin/python3.4 to provide /usr/bin/python (python) in auto mode –install 选项使用了多个参数用于创建符号链接。最后一个参数指定了此选项的优先级，如果我们没有手动来设置替代选项，那么具有最高优先级的选项就会被选中。这个例子中，我们为 /usr/bin/python3.4 设置的优先级为2，所以update-alternatives 命令会自动将它设置为默认 Python 版本。 1234# 接下来，我们再次列出可用的 Python 替代版本。# update-alternatives --list python/usr/bin/python2.7/usr/bin/python3.4","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"服务器","slug":"服务器","permalink":"https://nymrli.top/tags/服务器/"}]},{"title":"nginx+uwsi搭建django环境服务器","slug":"nginx+uwsi搭建django环境服务器","date":"2018-10-12T04:44:09.000Z","updated":"2018-10-12T04:45:38.227Z","comments":true,"path":"2018/10/12/nginx+uwsi搭建django环境服务器/","link":"","permalink":"https://nymrli.top/2018/10/12/nginx+uwsi搭建django环境服务器/","excerpt":"","text":"阿里云搭建服务器更新源12sudo apt-get updatesudo apt-get upgrade 安装nginx1234sudo apt-get install nginxsudo /etc/init.d/nginx start (start可以改成restart/stop)#或是sudo service nginx start然后浏览器输入服务器IP,观察是否有welcom to nginx! 安装py3和virtualenv12sudo apt-get install git python3 python3-pipsudo pip3 install virtualenv 修改python版本:法一:(不建议)123456789$ gedit ~/.bashrc #gedit .bash_aliases在顶部加入一行alias python=python3$ source ~/.bashrc #或是source ~/.bash_aliases o$ python --version就会发现是Python 3.5.2啦/*orOpen your .bashrc file nano ~/.bashrc. Type alias python=python3 on to a new line at the top of the file then save the file with ctrl+o and close the file with ctrl+x. Then, back at your command line type source ~/.bashrc. Now your alias should be permanent.*/ Ubuntu16.04切换python3和python2▲.切换Python3为默认版本：(建议)12sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150 切换Python2为默认版本： 1sudo update-alternatives --config python 安装虚拟环境12cd /var/wwwsudo virtualenv env35 下载和配置网站1234sudo git clone https://github.com/KyrieWang233/homework_submission-master.gitsource env35/bin/activatecd home...sudo pip3 install -r requirements.txt 123456sudo python manage.py collectstaticsudo python manage.py migratepython manage.py createsuperusersudo vim settings.py将其中的ALLOWED_HOST=[*]改为自己的IP然后输入 python manage.py runserver 0.0.0.0:8000 安装、测试uwsgi12sudo pip3 install uwsgiuwsgi --http :8000 --module homework_submission.wsgi 编辑/var/www下的uwsgi.ini12345678910[uwsgi]chdir=/var/www/homework_submission-mastermodule=homework_submission.wsgihome=/var/www/env35master=Trueprocesses=10socket= :8001chmod socket=666vacuum=Truemax-requests=5000 编辑/var/www下的nginx.conf12345678910111213141516upstream django&#123;server 127.0.0.1:8001;&#125;server &#123;listen 80;server_name sast.nymrli.top;charset utf-8;client_max_body_size 75M;location /static&#123;alias /var/www/homework_submission-master/static; &#125;location /&#123;uwsgi_pass django;include /var/www/uwsgi_params;&#125;&#125; 编辑/var/www下的uwsgi_params12345678910111213141516uwsgi_param QUERY_STRING $query_string;uwsgi_param REQUEST_METHOD $request_method;uwsgi_param CONTENT_TYPE $content_type;uwsgi_param CONTENT_LENGTH $content_length; uwsgi_param REQUEST_URI $request_uri; uwsgi_param PATH_INFO $document_uri; uwsgi_param DOCUMENT_ROOT $document_root; uwsgi_param SERVER_PROTOCOL $server_protocol; uwsgi_param REQUEST_SCHEME $scheme; uwsgi_param HTTPS $https if_not_empty; uwsgi_param REMOTE_ADDR $remote_addr; uwsgi_param REMOTE_PORT $remote_port; uwsgi_param SERVER_PORT $server_port; uwsgi_param SERVER_NAME $server_name; 软连接12345cd /etc/nginxcd sites-enabledrm defaultln -s /var/www/nginx.conf homework_submissionls 重启nginx/etc/init.d/nginx restart 运行uwsgi12cd /var/wwwuwsgi --ini uwsgi.ini 让uwsgi自启动 vim /etc/rc.local(注意非虚拟环境也得安装uwsgi模块) 1234添加下面代码:/usr/local/bin/uwsgi --ini /var/www/uwsgi.iniexit 0 uwsgi的热启动 在uwsgi.ini中加入 py-autoreload=1 重启一下:killall -9 uwsgi、/usr/local/bin/uwsgi --ini /var/www/uwsgi.ini 总结关于etc/ linit. d 如果你使用过inux系统,那么你一定听说过 init. d目录,这个目录到底是干嘛的呢?它归根结底只做了一件事情,但这件事情非同小可,是为整个系统做的,因此它非常重要。init.d目录包含许多系统各种服务的启动和停止脚本 关于 /etc/rc.local rc.local也是我经常使用的一个脚本,该脚本是在系统初始化级别脚本运行之后再执行的,因此可以安’, ‘地在里面添加你想在系统启动之后执行的脚本. 总结 Linux是灵活的,正因为它的灵活性,我们总是可以找到许多不同的办法来解决同一个问题，服务的例子就是一个很好的佐证,有了 /etc/init.d目录下的脚本,再加上 /etc/rc. local这个利器，你可以放心的确保你的服务可以完美的启动和运行","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"服务器","slug":"服务器","permalink":"https://nymrli.top/tags/服务器/"}]},{"title":"小程序开发遇到的坑","slug":"小程序开发遇到的坑","date":"2018-10-04T12:26:58.000Z","updated":"2018-10-04T12:30:16.418Z","comments":true,"path":"2018/10/04/小程序开发遇到的坑/","link":"","permalink":"https://nymrli.top/2018/10/04/小程序开发遇到的坑/","excerpt":"","text":"小程序开发遇到的坑function 与 =&gt; 的区别 在JS中，箭头函数并不是简单的function(){}匿名函数的简写语法糖，实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，在编写函数时就已经确定了。而匿名函数的this指向运行时实际调用该方法的对象，无法在编写函数时确定。 箭头函数和普通函数的区别 不可以当做构造函数，也就是说，不可以使用 new 命令，否则会抛出错误。 this、arguments、caller等对象在函数体内都不存在。 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。 ==&gt;箭头函数除了传入的参数之外，其它的对象都没有！在箭头函数引用了this、arguments或者参数之外的变量，那它们一定不是箭头函数本身包含的，而是从父级作用域继承的。 代码实例:123456789101112function Test() &#123; this.num = 100; this.func = function()&#123; console.log(this.num); // 100 setTimeout(function()&#123; console.log(this.num); // undefined &#125;, 500); &#125;;&#125;var obj = new Test();obj.func();//这里的方法里调用了setTimeout函数，该函数500毫秒后调用我们定义的函数时，实际上是window对象调用的，所以这时匿名函数的this是指向window而不是指向obj了。 在箭头函数出现之前一般都是这么写的： 12345678910111213141516171819202122232425function Test() &#123; this.num = 100; this.func = function()&#123; console.log(this.num); // 100 var that = this; //保存一份当前的this对象 setTimeout(function()&#123; console.log(that.num); // 100 &#125;, 500); &#125;;&#125;var obj = new Test();obj.func();//这是利用了闭包的概念。箭头函数可以看做这种方式的语法糖。//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //function Test() &#123; this.num = 100; this.func = function()&#123; console.log(this.num); // 100 setTimeout(() =&gt; &#123; console.log(this.num); // 100 //箭头函数没有this,所以从上层父级继承 &#125;, 500); &#125;;&#125;var obj = new Test();obj.func(); ▲同时需要注意的是:this是指向当前的对象，随着上下文作用域的切换this的执行this的指向会发生改变，我们可以先保存一份this的值然后再使用：var that = this 生成带参数的二维码123456789101112131415161718192021222324 onShow:function()&#123; var that = this; function get_code() &#123; wx.request(&#123; url: 'https://api.weixin.qq.com/cgi- bin/token?grant_type=client_credential&amp;appid=' + that.data.APP_ID + '&amp;secret=' + that.data.APP_SECRET, method: 'GET', success: function (res) &#123; // console.log(res.data.access_token); wx.request(&#123; data: &#123; 'path': \"pages/index\" &#125;, url: 'https://api.weixin.qq.com/wxa/getwxacode?access_token=' + res.data.access_token, method: 'POST', success: function (res) &#123; console.log(res.data);//2jin zhi &#125; &#125;) &#125; &#125;) &#125; get_code();&#125;//官方接口得到的是图片的二进制流 通过草料微信小程序生成二维码: 12345678910111213141516171819202122232425262728293031const app = getApp()Page(&#123; data: &#123; APP_ID: 'wx05818046869e4078', APP_SECRET: '5d4429375e84d6ab9476b643f8733af9', path: 'pages/index', photo:null, &#125;, onShow:function()&#123; var that = this; console.log(that.data.APP_ID + ' ' + that.data.APP_SECRET + ' ' + that.data.path) wx.request(&#123; url: 'https://cli.im/home/weapp/create', method:'POST', data:&#123; 'weapp_id': that.data.APP_ID,'weapp_secret': that.data.APP_SECRET,'weapp_url': that.data.path &#125;, header:&#123; 'content- type': 'application/x- www- form- urlencoded' &#125;, success:(res)=&gt;&#123; console.log(res.data.data) that.setData(&#123; photo: res.data.data &#125;) &#125; &#125;) &#125;&#125;) 组件的自定义数据属性:123&lt;view bindtap=\"f0\" data- xxx- yyy='blabla'&gt;&lt;/view&gt;//在点击触发事件f0的参数event中,dataset为自定义参数的字典,其中,键值为驼峰命名法.xxxYyy ▲.bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡 wx.requests是异步调用的 wx.requests这个api是不会阻塞的,什么时候收到response就什么时候调用回调函数(success…),如果在wx.requests方法调用后还有运行代码(1),则(1)比回调函数早执行 组件: 以某种方式对 业务逻辑和 功能**的封装 特点:高内聚,可复用 视图组件 表单组件 媒体组件 画布组件 基础内容组件 导航组件 地图组件 开放能力组件 自定义组件:​ 内容略 ES6新特性:js中let和var定义变量的区别 声明后未赋值，表现相同: 如果未在 let 、var 语句中初始化您的变量，则将自动为其分配 JavaScript 值 undefined 使用未声明的变量，表现不同: var有变量提升，let无变量提升 重复声明同一个变量时，表现不同： var重复声明时覆盖，let重复声明时报错 变量作用范围，表现不同： 使用 let 语句声明一个变量，该变量的范围限于声明它的块中。 ==&gt;代码演示: 123456789101112(function() &#123; var varTest = 'test var OK.'; let letTest = 'test let OK.'; &#123; var varTest = 'varTest changed.'; let letTest = 'letTest changed.'; &#125; console.log(varTest); //输出\"varTest changed.\"，内部\"&#123;&#125;\"中声明的varTest变量覆盖外部的letTest声明 console.log(letTest); //输出\"test let OK.\"，内部\"&#123;&#125;\"中声明的letTest和外部的letTest不是同一个变量&#125;());","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://nymrli.top/tags/微信小程序/"}]},{"title":"带表头的单链表的基本操作","slug":"带表头的单链表的基本操作","date":"2018-09-27T14:12:17.000Z","updated":"2018-09-27T14:25:50.649Z","comments":true,"path":"2018/09/27/带表头的单链表的基本操作/","link":"","permalink":"https://nymrli.top/2018/09/27/带表头的单链表的基本操作/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int ElemType;typedef int Status;typedef struct Node&#123; ElemType elem; struct Node *link;&#125;Node;typedef struct &#123; struct Node* head; int n;&#125;Headlist;Status Init(Headlist *L)&#123; L-&gt;head = (Node*)malloc(sizeof(Node)); if(!L-&gt;head) return ERROR; L-&gt;head-&gt;link = NULL; L-&gt;n = 0; return OK;&#125;void Sort(Headlist *L)&#123; Node *p=L-&gt;head,*pre=NULL; Node *r=p-&gt;link; p-&gt;link = NULL; p=r; //r保存原来的结点顺序 while(p != NULL)&#123; r = p-&gt;link; //r继续取下一个结点 pre = L-&gt;head; //pre重新构造L,从头开始循环 while(pre-&gt;link != NULL &amp;&amp; pre-&gt;link-&gt;elem &lt; p-&gt;elem) // 如果链表非空 且 新链表与当前结点数值比较 pre = pre-&gt;link; //如果当前要插入的结点值大于循环中当前已排序结点,则取已排序链表下一个结点继续比较 p-&gt;link = pre-&gt;link; //找到p要插入的位置后,插入:若3&lt;pre=5&lt;bigger=7&lt;8,p=6,则 p=&gt;bigger pre-&gt;link = p; // pre=&gt;p,插入即可 p=r; // p继续取下个结点依次按原来顺序循环遍历原来链表 &#125;&#125;void deleleab(Headlist *L, int a,int b)&#123; Node *q = L-&gt;head,*p=L-&gt;head-&gt;link; // q为上一个,p为当前的 while( p ) if(p-&gt;elem &gt;= a &amp;&amp; p-&gt;elem &lt;= b) &#123; q-&gt;link = p-&gt;link; // 1 - 2 - 3 1==&gt;3,1的指针域指向3 free(p); //释放2 p = q-&gt;link; // 当前的指针变成3 &#125;else&#123; p = p-&gt;link; q = p-&gt;link; &#125; &#125;Status Converse(Headlist *L)&#123; Node *p = NULL,*cur= NULL; Node *q = L-&gt;head-&gt;link; if(L-&gt;head &amp;&amp; L-&gt;head-&gt;link)&#123; //如果表不存在或是为空,则return ERROR while( q != NULL ) //q按照原来的顺序依次遍历各结点 &#123; cur = q; //cur为当前结点 q = q-&gt;link; //q保存下一个结点 L-&gt;head-&gt;link = cur; //为了不动头结点,所以头结点link始终指向当前要加的结点 cur-&gt;link = p; //当前的link指向上一个结点 p = cur; //保存上一个结点 &#125; &#125;else return ERROR; return OK;&#125;Status Insert(Headlist *L,int j,ElemType x)&#123; Node *p=NULL,*q=NULL; int i; if(j&lt;-1 || j&gt; L-&gt; n-1) return ERROR; p = L-&gt;head; for(i=0;i&lt;=j;i++) p=p-&gt;link; q = (Node *)malloc(sizeof(Node)); q-&gt;elem = x; q-&gt;link = p-&gt;link; p-&gt;link = q; L-&gt;n++; return OK;&#125;Status Output(Headlist L)&#123; Node *p = L.head-&gt;link; if(!L.n) return ERROR; while(p)&#123; printf(\"%d \",p-&gt;elem ); p = p-&gt;link; &#125; return OK;&#125;Status Destory(Headlist *L)&#123; Node *p=NULL; while(L-&gt;head)&#123; //不断删除head所指向的内存,直到head被释放 p = L-&gt;head-&gt;link; free(L-&gt;head); L-&gt;head = p; &#125; return OK; &#125;Status Delete(Headlist *L,int j)&#123; //下标j Node *p = L-&gt;head,*q = L-&gt;head; // q = tmp int i; if(!L-&gt;n) return ERROR; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; for(i = 0 ;i&lt;=j-1;i++) p = p-&gt;link; q = p; p = p-&gt;link; q-&gt;link = p-&gt;link; free(p); return OK;&#125;Status Find(Headlist *L,int j,ElemType *x)&#123; Node *p= L-&gt;head; int i; if ( j&lt;0 || j&gt;L-&gt;n) return ERROR; for(i = 0 ;i&lt;=j;i++) p = p-&gt;link; *x = p-&gt;elem; return OK;&#125;int main()&#123; int x; Headlist list; Init(&amp;list); Insert(&amp;list,-1,3); Insert(&amp;list,0,2); Insert(&amp;list,-1,5); Insert(&amp;list,2,7); Insert(&amp;list,-1,1); printf(\"the linked list is :\"); Output(list); printf(\"\\nAfter sorted:\"); Sort(&amp;list); Output(list); printf(\"\\nAfter Conversed:\"); Converse(&amp;list); Output(list); printf(\"\\nAfter delete index of 0,the list is:\"); Delete(&amp;list,0); Output(list); Find(&amp;list,2,&amp;x); printf(\"\\nthe index of 2:%d\\n\",x); Destory(&amp;list); system(\"pause\"); return 0;&#125;//无论是什么都要略过head表头结点,表头结点的elem是任意的. (一)实验中遇到的主要问题及解决方法 1.题目二，带表头的单链表在插入时出现了点问题，书上给出的方法是错的，且是C++代码。于是在尝试理解他的想法及每步Debug中终于写出了正确的代码。（L-&gt;head-&gt;link = NULL,其中L-&gt;head-&gt;data 不填） 2.题目二中带表头节点的单链表中插入时for( j=0;j&lt;=i; j++) 和之前j&lt;i以及删除时for( j=0;j&lt;=i-1; j++) 和之前j&lt;i-1有很大不同,通过debug知道了是为了略过第一个表头节点。 3.逆置过程中,为了不动表头,略过第一个表头结点时出现了点麻烦.并且在第一个元素逆置后指向NULL,第二个结点指向第一个结点时没有想明白,后来才想到了先让P=NULL,然后记录上一个结点就能达到效果了.同时还有个问题是一直没有保存原来链表的顺序,再因为P=NULL导致会访问到非法内存而程序崩溃 （二）实验心得 2.题目二中,带表头单链表和不带表头单链表,在删除和插入时的循环条件不同要注意.及初始化时带表头的L-&gt;head-&gt;link= NULL; 与 无表头的 L-&gt;first = NULL;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"带表头的单链表应用——多项式","slug":"带表头的单链表应用——多项式","date":"2018-09-27T14:04:31.000Z","updated":"2018-09-27T14:26:11.753Z","comments":true,"path":"2018/09/27/带表头的单链表应用——多项式/","link":"","permalink":"https://nymrli.top/2018/09/27/带表头的单链表应用——多项式/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define Overflow 2#define Underflow 3#define Notpresent 4#define Duplicate 5typedef int ElemType;typedef int Status;typedef struct PNode&#123; ElemType ceof; ElemType exp; struct PNode *link;&#125;PNode;typedef struct &#123; struct PNode *head;&#125;polynominal;Status Init(polynominal *p)&#123; p-&gt;head = (PNode *)malloc(sizeof(PNode)); p-&gt;head-&gt;exp = -1; p-&gt;head-&gt;link = NULL; return OK;&#125;Status Create(polynominal *p)&#123; PNode *pn = NULL,*q=NULL,*pre=NULL; Init(p); //p-&gt;head = (PNode *)malloc(sizeof(PNode)); //p-&gt;head-&gt;exp = -1; //p-&gt;head-&gt;link = NULL; for (;;) // &lt;==&gt;while(1) &#123; pn = (PNode *)malloc(sizeof(PNode)); printf(\"ceof:\\n\"); scanf(\"%d\",&amp;pn-&gt;ceof); printf(\"exp:\\n\"); scanf(\"%d\",&amp;pn-&gt;exp); if (pn-&gt;exp &lt; 0) &#123;printf(\"End the input\\n\"); break;&#125; pre = p-&gt;head; //pre从链表头开始 q=p-&gt;head-&gt;link; while(q &amp;&amp; q-&gt;exp &gt; pn-&gt;exp)&#123; //pn为当前结点,q为链表中结点 pre = q; // q = q-&gt;link; &#125; pn-&gt;link = q; // 在pre和q之间插入pn,(q为null时,相当于末尾插入pn) pre-&gt;link = pn; // pre =&gt; pn =&gt; q &#125; return OK;&#125;Status Sort(polynominal *L)&#123; //从大到小 PNode *p=L-&gt;head,*pre=NULL; PNode *r=p-&gt;link; p-&gt;link = NULL; p=r; //r保存原来的结点顺序 while(p != NULL)&#123; r = p-&gt;link; //r继续取下一个结点 pre = L-&gt;head; //pre重新构造L,从头开始循环 while(pre-&gt;link != NULL &amp;&amp; pre-&gt;link-&gt;exp &lt; p-&gt;exp) // 如果链表非空 且 新链表与当前结点数值比较 pre = pre-&gt;link; //如果当前要插入的结点值大于循环中当前已排序结点,则取已排序链表下一个结点继续比较 p-&gt;link = pre-&gt;link; //找到p要插入的位置后,插入:若3&lt;pre=5&lt;bigger=7&lt;8,p=6,则 p=&gt;bigger pre-&gt;link = p; // pre=&gt;p,插入即可 p=r; // p继续取下个结点依次按原来顺序循环遍历原来链表 &#125; return OK;&#125;Status Add(polynominal *px,polynominal *qx)&#123; //目的:将q改成p+q PNode *q1=qx-&gt;head, *p=px-&gt;head-&gt;link; //q1指向qx表头结点 PNode *q=q1-&gt;link; //p指向多项式px第一个结点,q指向qx第一个 PNode *temp = NULL; //q1是q前驱 while( q &amp;&amp; p)&#123; while( p-&gt;exp &lt; q-&gt;exp )&#123; //找到qx中 大于等于q指数项的项,q不断右移 q1 = q; q = q-&gt;link; &#125; if (p-&gt;exp == q-&gt;exp )&#123; q-&gt;ceof = q-&gt;ceof + p-&gt;ceof; if (q-&gt;ceof == 0)&#123; q1-&gt;link = q-&gt;link; //释放当前q的内存 free(q); q = q1-&gt;link; p = p-&gt;link; &#125;else&#123; //p\\q都右移 q1 = q; //q1 q = q-&gt;link; p = p-&gt;link; &#125; &#125;else&#123; //p-&gt;exp &gt; q-&gt;exp temp = (PNode * )malloc(sizeof(PNode)); temp-&gt;ceof = p-&gt;ceof; temp-&gt;exp = p-&gt;exp; temp-&gt;link = q1-&gt;link; q1-&gt;link = temp; p = p-&gt;link; &#125; &#125; return OK;&#125;void Output(polynominal *p)&#123; PNode *q = p-&gt;head-&gt;link; int last = 0; while( q!=NULL )&#123; if(q-&gt;link == NULL) last =1; printf(\"%dx^%d\", q-&gt;ceof,q-&gt;exp); if(!last) printf(\"+\"); //此处注意个+的小细节 q = q-&gt;link; &#125; printf(\"\\n\");&#125;void Destory(polynominal *p)&#123; PNode *q = NULL; while(p-&gt;head)&#123; //不断删除head所指向的内存,直到head被释放 q = p-&gt;head-&gt;link; free(p-&gt;head); p-&gt;head = q; &#125;&#125;/***********合并同类项*****************//***********合并即free*****************/Status unify(polynominal *t)&#123; PNode *p=NULL; PNode *q=NULL; PNode *last=NULL; PNode *tmp; //while(p-&gt;link != NULL)&#123; for(p=t-&gt;head-&gt;link;p!=NULL;p=p-&gt;link)&#123; //选择 last = p; for(q=last-&gt;link; q!=NULL ; )&#123; //q指针向后推移指向下一结点 if(q-&gt;exp == p-&gt;exp)&#123; //相等计算 p-&gt;ceof += q-&gt;ceof; //q为 滑动项 tmp = q-&gt;link; last-&gt;link = q-&gt;link; //last保存上一个q free(q); // 吧q的空间释放掉 q= tmp; &#125;else&#123; last= q; q=q-&gt;link;&#125; //如果不相等就判断下一个 &#125; &#125; return OK;&#125;polynominal Multiply(polynominal *px,polynominal *qx)&#123; PNode *p = px-&gt;head; PNode *q = qx-&gt;head; PNode *x = NULL; PNode *tmp = NULL; polynominal newpoly; Init(&amp;newpoly); x = newpoly.head; for (p=px-&gt;head-&gt;link; p!=NULL; p=p-&gt;link)&#123; for (q=qx-&gt;head-&gt;link; q!=NULL; q=q-&gt;link)&#123; tmp = (PNode*)malloc(sizeof(PNode)); tmp-&gt;ceof = p-&gt;ceof * q-&gt;ceof; tmp-&gt;exp = p-&gt;exp + q-&gt;exp; tmp-&gt;link = x-&gt;link; //新生成的结点指向上一个生成的结点的地址 x-&gt;link = tmp; //使链表记录当前tmp结点 x = x-&gt;link; //取下一个结点 &#125; &#125; unify(&amp;newpoly); Sort(&amp;newpoly); return newpoly;&#125;int main()&#123; polynominal p,q; polynominal mul; Create(&amp;p); Output(&amp;p); // printf(\"After unify:\\n\"); Unify // unify(&amp;p); // Output(p); Create(&amp;q); Output(&amp;q); // Add(&amp;p,&amp;q); ADD // printf(\"q:\"); // Output(q); printf(\"After Multiplied:\\n\"); mul = Multiply(&amp;p,&amp;q); Output(&amp;mul); system(\"pause\"); return 0;&#125;//其中Sort,unify,add,multiply,需要捉摸一下 (一)实验中遇到的主要问题及解决方法 1.题目二，带表头的单链表在插入时出现了点问题，书上给出的方法是错的，且是C++代码。于是在尝试理解他的想法及每步Debug中终于写出了正确的代码。（L-&gt;head-&gt;link = NULL,其中L-&gt;head-&gt;data 不填） 2.题目二中带表头节点的单链表中插入时for( j=0;j&lt;=i; j++) 和之前j&lt;i以及删除时for( j=0;j&lt;=i-1; j++) 和之前j&lt;i-1有很大不同,通过debug知道了是为了略过第一个表头节点。 3.逆置过程中,为了不动表头,略过第一个表头结点时出现了点麻烦.并且在第一个元素逆置后指向NULL,第二个结点指向第一个结点时没有想明白,后来才想到了先让P=NULL,然后记录上一个结点就能达到效果了.同时还有个问题是一直没有保存原来链表的顺序,再因为P=NULL导致会访问到非法内存而程序崩溃 4.合并同类项的过程中,使用了选择排序类似的思想,但是在里层for(q=last-&gt;link; q!=NULL ; )出了问题,一开始写成 for(q=last-&gt;link; q!=NULL ; q=q-&gt;link)但是如果指数相等,q就会被free掉,此时q=q-&gt;link就会出问题 （二）实验心得 1.题目一中，顺序表是malloc动态申请的空间，是连续的，可以直接通过下标访问。 2.题目二中,带表头单链表和不带表头单链表,在删除和插入时的循环条件不同要注意.及初始化时带表头的L-&gt;head-&gt;link = NULL; 与 无表头的 L-&gt;first = NULL; 3.Debug过程中F10和F11的区别,在malloc和free处按F11会进入malloc函数、free函数的汇编的运行过程 4.排序和逆置时都要有个指针记住原来链表的顺序,然后才能再依次按顺序进行. 5.理清要做的事,再下手写代码,画图有时很重要.","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nymrli.top/tags/数据结构/"}]},{"title":"小程序蓝牙","slug":"小程序蓝牙API","date":"2018-09-20T02:57:01.000Z","updated":"2018-10-04T12:30:02.067Z","comments":true,"path":"2018/09/20/小程序蓝牙API/","link":"","permalink":"https://nymrli.top/2018/09/20/小程序蓝牙API/","excerpt":"","text":"提供蓝牙模块APIwx.openBluetoothAdapter(OBJECT)​ 初始化小程序蓝牙模块 wx.closeBluetoothAdapter(OBJECT)​ 关闭蓝牙模块，使其进入未初始化状态。 wx.getBluetoothAdapterState(OBJECT)​ 获取本机蓝牙适配器状态 wx.onBluetoothAdapterStateChange(CALLBACK)​ 监听蓝牙适配器状态变化事件 wx.startBluetoothDevicesDiscovery(OBJECT)​ 开始搜寻附近的蓝牙外围设备。注意，该操作比较耗费系统资源，请在搜索并连接到设备后调用 stop 方法停止搜索。 wx.stopBluetoothDevicesDiscovery(OBJECT)​ 停止搜寻附近的蓝牙外围设备。若已经找到需要的蓝牙设备并不需要继续搜索时，建议调用该接口停止蓝牙搜索。 wx.getBluetoothDevices(OBJECT)​ 获取在小程序蓝牙模块生效期间所有已发现的蓝牙设备，包括已经和本机处于连接状态的设备。 wx.onBluetoothDeviceFound(CALLBACK)​ 监听寻找到新设备的事件 wx.createBLEConnection(OBJECT)​ 连接低功耗蓝牙设备。 wx.closeBLEConnection(OBJECT)​ 断开与低功耗蓝牙设备的连接 wx.getBLEDeviceServices(OBJECT)​ 获取蓝牙设备所有 service（服务） wx.getBLEDeviceCharacteristics(OBJECT)​ 获取蓝牙设备某个服务中的所有 characteristic（特征值） wx.readBLECharacteristicValue(OBJECT)​ 读取低功耗蓝牙设备的特征值的二进制数据值。注意：必须设备的特征值支持read才可以成功调用，具体参照 characteristic 的 properties 属性 wx.writeBLECharacteristicValue(OBJECT)​ 向低功耗蓝牙设备特征值中写入二进制数据。注意：必须设备的特征值支持write才可以成功调用，具体参照 characteristic 的 properties 属性 tips: 并行调用多次读写接口存在读写失败的可能性* wx.notifyBLECharacteristicValueChange(OBJECT)​ 启用低功耗蓝牙设备特征值变化时的 notify 功能，订阅特征值。注意：必须设备的特征值支持notify或者indicate才可以成功调用，具体参照 characteristic 的 properties 属性 ​ 另外，必须先启用notify才能监听到设备 characteristicValueChange 事件 wx.onBLEConnectionStateChange(CALLBACK)​ 监听低功耗蓝牙连接状态的改变事件，包括开发者主动连接或断开连接，设备丢失，连接异常断开等等 wx.onBLECharacteristicValueChange(CALLBACK)​ 监听低功耗蓝牙设备的特征值变化。必须先启用notify接口才能接收到设备推送的notification。 ### 示例代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150// pages/bluetooth/bluetooth.jsPage(&#123; data:&#123;&#125;, onLoad:function(options)&#123; // 页面初始化 options为页面跳转所带来的参数 &#125;, //初始化蓝牙适配器 openBluetooth:function()&#123; wx.openBluetoothAdapter(&#123; success: function(res)&#123; console.log(res.errMsg) // success wx.showToast(&#123; title:\"初始化蓝牙适配器成功\", duration:2000 &#125;) &#125;, &#125;) &#125;,//关闭蓝牙模块closeBluetooth:function()&#123; wx.openBluetoothAdapter() wx.closeBluetoothAdapter(&#123; success: function(res)&#123; // success console.log(\"success\"+res) &#125; &#125;)&#125;,//获取本机蓝牙适配器状态getBluetoothAdapterState:function()&#123;wx.getBluetoothAdapterState(&#123; success: function(res)&#123; // success console.log(\"res:\"+res) console.log(\"errMsg:\"+res.errMsg) &#125;&#125;)&#125;,//监听蓝牙适配器状态变化事件 onBluetoothAdapterStateChange:function()&#123; wx.onBluetoothAdapterStateChange(function(res) &#123; console.log(`adapterState changed, now is`, res) &#125;)&#125;, // 开始搜寻附近的蓝牙外围设备 startBluetoothDevicesDiscovery:function()&#123; wx.startBluetoothDevicesDiscovery(&#123; success: function (res) &#123; console.log(res) &#125; &#125;)&#125;, // 停止搜寻附近的蓝牙外围设备 stopBluetoothDevicesDiscovery:function()&#123; wx.stopBluetoothDevicesDiscovery(&#123; success: function (res) &#123; console.log(res) &#125; &#125;)&#125;, //获取所有已发现的蓝牙设备 getBluetoothDevices:function()&#123; wx.getBluetoothDevices(&#123; success: function(res)&#123; // success console.log(res) &#125;, &#125;) &#125;, //监听寻找到新设备的事件 onBluetoothDeviceFound:function()&#123; wx.onBluetoothDeviceFound(function(res) &#123; // callback console.log(res) &#125;) &#125;, //根据 uuid 获取处于已连接状态的设备 getConnectedBluetoothDevices:function()&#123; wx.getConnectedBluetoothDevices(&#123; success: function (res) &#123; console.log(res) &#125;&#125;)&#125;,//连接低功耗蓝牙设备createBLEConnection:function()&#123; wx.createBLEConnection(&#123; deviceId: 'AC:BC:32:C1:47:80', success: function(res)&#123; // success console.log(res) &#125;, fail: function(res) &#123; // fail &#125;, complete: function(res) &#123; // complete &#125; &#125;)&#125;,//断开与低功耗蓝牙设备的连接closeBLEConnection:function()&#123; wx.closeBLEConnection(&#123; deviceId: 'AC:BC:32:C1:47:80', success: function (res) &#123; console.log(res) &#125;&#125;)&#125;,//监听低功耗蓝牙连接的错误事件，包括设备丢失，连接异常断开等等onBLEConnectionStateChanged:function()&#123; wx.onBLEConnectionStateChanged(function(res) &#123; console.log(`device $&#123;res.deviceId&#125; state has changed, connected: $&#123;res.connected&#125;`)&#125;)&#125;,//获取蓝牙设备所有 service（服务）getBLEDeviceServices:function()&#123; wx.getBLEDeviceServices(&#123; deviceId: '48:3B:38:88:E3:83', success: function(res)&#123; // success console.log('device services:', res.services.serviceId) &#125;, fail: function(res) &#123; // fail &#125;, complete: function(res) &#123; // complete &#125; &#125;)&#125;,//获取蓝牙设备所有 characteristic（特征值）getBLEDeviceCharacteristics:function()&#123; wx.getBLEDeviceCharacteristics(&#123; deviceId: '48:3B:38:88:E3:83', serviceId: 'serviceId', success: function(res)&#123; // success &#125;, fail: function(res) &#123; // fail &#125;, complete: function(res) &#123; // complete &#125; &#125;)&#125;&#125;)","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://nymrli.top/tags/微信小程序/"}]},{"title":"电信路由器上网","slug":"电信路由器上网","date":"2018-09-20T02:01:16.000Z","updated":"2018-10-04T07:32:40.777Z","comments":true,"path":"2018/09/20/电信路由器上网/","link":"","permalink":"https://nymrli.top/2018/09/20/电信路由器上网/","excerpt":"","text":"链接: https://pan.baidu.com/s/1QaW7DMhjb2YHd0ZVWterSw 密码：联系QQ1063052964,或是在下方评论处留言QQ","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"小程序入门学习","slug":"小程序入门学习","date":"2018-09-20T01:57:01.000Z","updated":"2018-09-20T02:06:14.438Z","comments":true,"path":"2018/09/20/小程序入门学习/","link":"","permalink":"https://nymrli.top/2018/09/20/小程序入门学习/","excerpt":"","text":"IDE搭建:下载:微信公众平台官网 预备知识: 个人认为入门小程序相对比较简单,需要了解HTML+CSS 大概知道是干啥的就行,JavaScrip还是要看看的，推荐教程 廖雪峰的博客以及W3Cschool的JS教程 项目目录结构介绍: 小程序中一共有四种类型的文件: js ———- JavaScrip文件 json ——– 项目配置文件，负责窗口颜色等等 wxml ——- 类似HTML文件 wxss ——- 类似CSS文件 重要文件-APP讲解: app.json(必需) :监听并处理小程序的生命周期函数、声明全局变量。 app.js(建议保存) : *作为配置整个APP的入口,可以什么都不写只输入{}.对整个小程序的全局配置。记录了页面组成(定义了每个页面)，配置小程序的窗口 背景色，配置导航条样式，配置默认标题。* ​ ==&gt;没有最简单的小程序也能运行. app.wxml app.wxss ===&gt; 所以只有app.js和app.json的项目是最简单的小程序 具体页面下的 js文件配置页面入口 wxml配置布局 一起完成对页面的渲染 wxss样式文件 json配置文件 会覆盖app.json和app.wxss全局设置的内容,实现单个网页的个性化 app.js 12345678910111213141516171819202122232425262728293031323334353637Page(&#123; //* 页面的初始数据 data: &#123; &#125;, // * 生命周期函数--监听页面加载 onLoad: function (options) &#123; &#125;, //* 生命周期函数--监听页面初次渲染完成 onReady: function () &#123; &#125;, //* 生命周期函数--监听页面显示 onShow: function () &#123; &#125;, //* 生命周期函数--监听页面隐藏 onHide: function () &#123; &#125;, //* 生命周期函数--监听页面卸载 onUnload: function () &#123; &#125;, //* 页面相关事件处理函数--监听用户下拉动作 onPullDownRefresh: function () &#123; &#125;, //* 页面上拉触底事件的处理函数 onReachBottom: function () &#123; &#125;, //* 用户点击右上角分享 onShareAppMessage: function () &#123; &#125;&#125;) app.json 1234\"pages\":[ \"pages/index/index\" //pages 里面的路径其实是指向js文件的,其中第一个就是登陆首页] 实现路由配置,及全局的某些设置 app.js** 定义了每个页面,每个页面的.js又调用了Page()方法实现该页面的配置信息 小程序事件 事件 == 事件类型+具体事件 具体事件 tap longtap toustart、touchend、touchmove、touchcancel(电话中断) submint、input…… 事件类型 bind 冒泡事件 catch 非冒泡事件 currentTarget 被绑定的组件 dataset 控件相应的属性 target 发生事件的组件 页面跳转 navigateTo({ url :&#39;xxx&#39; }) &lt;navigator url=&quot;../logs/logs?id=1&amp;title=&#39;as&#39;&quot; &gt; &lt;/navigator&gt; Flex容器和元素容器属性 flex-direction : 决定主轴方向 flex-wrap : 处理如何换行 flex-flow : flex-dirction和flex-wrap合并简写 justify-content: 元素在主轴的对齐方式 space-bewteen 两端对齐 center 居中对齐 flex-start 左侧对齐 flex-end 右侧对齐 align-items : 元素在交叉轴的对齐方式 stretch 拉伸,当没设置item高度时,占满整个容器 baseline :以文字为底线对齐 元素属性 flex-grow (默认0): 当有多余空间时,元素的放大比例 flex-shrink(默认1) : 当空间不足时,元素的放大比例 flex-basis: 元素在主轴上占据的空间 flex : flex-grow、flex-shrink、flex-basis的合并简写 order : 定义元素的排列顺序 align-self : 定义元素自身的对齐方式 定位 相对定位: 相对定位的元素是相对自身进行定位,参照物是自己 绝对定位 : 绝对定位的元素是相对离它最近的一个已定位的父级元素进行定位,如果没有,则以整个页面进行定位 margin和padding的区别 margin是指从 自身边框 到 另一个容器边框 之间的距离，就是容器外距离。（外边距） padding是指 自身边框 到 自身内部另一个容器边框 之间的距离，就是容器内距离。（内边距） rpx 动态单位 css布局实例123456789101112wxml: &lt;view class='list-item' wx:for=\"&#123;&#123;listItem&#125;&#125;\"&gt; &lt;view class='list-item-images'&gt; &lt;image src='../../images/img2.png' class='list-item-images-img' /&gt; &lt;!-- &lt;image class='avatar' src='../../images/avatar.png'/&gt; --&gt; &lt;/view&gt; &lt;view class=\"list-item-text\"&gt; &lt;text&gt;这是一个标题&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 123456789101112131415wxss:.list-item&#123; height:500rpx; //整个 图片+文字 一共高为500rpx width: 100%;&#125; .list-item-images&#123; height: 300rpx; // 其中图片的高度为300rpx width: 100%;&#125;.list-item-images image&#123; //图片高、宽全部伸展 height: 100%; width: 100%;&#125;","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://nymrli.top/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://nymrli.top/tags/微信小程序/"}]},{"title":"Spy++使用介绍","slug":"Spy-使用介绍","date":"2018-09-02T11:39:45.000Z","updated":"2018-09-02T11:40:26.032Z","comments":true,"path":"2018/09/02/Spy-使用介绍/","link":"","permalink":"https://nymrli.top/2018/09/02/Spy-使用介绍/","excerpt":"","text":"Spy++ (SPYXX.EXE) 是一个基于 Win32 的实用工具，它提供系统的进程、线程、窗口和窗口消息的图形视图。使用 Spy++ 可以执行下列操作： 显示系统对象（包括进程、线程和窗口）之间关系的图形树。 搜索指定的窗口、线程、进程或消息。 查看选定的窗口、线程、进程或消息的属性。 我们可以使用微软的Spy++来查看窗口类名等信息，然后再结合pywin32实现。 加载初始界面: 然后点击工具栏的望远镜。如图所示: 出现搜索窗口，然后通过移动靶心到想要查找句柄的窗口后单击就行了。==&gt;它的句柄、标题、类都会显示 再点击确定。 此时会有两种情况。 成功搜索到 搜索不到 原因是你查找的窗口是在打开spy++后打开的，解决的办法就是按F5进行刷新，然后就行了 成功后都会出现如下： 右键，点击“属性”能看到更多详细内容。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"}]},{"title":"解决安装PyUserInput、pyHook遇到的问题——AttributeError: 'HookManager' object has no attribute 'keyboard_hook","slug":"解决安装PyUserInput、pyHook遇到的问题——AttributeError-HookManager-object-has-no-attribute-keyboard-hook","date":"2018-09-02T11:33:32.000Z","updated":"2018-09-02T11:33:55.065Z","comments":true,"path":"2018/09/02/解决安装PyUserInput、pyHook遇到的问题——AttributeError-HookManager-object-has-no-attribute-keyboard-hook/","link":"","permalink":"https://nymrli.top/2018/09/02/解决安装PyUserInput、pyHook遇到的问题——AttributeError-HookManager-object-has-no-attribute-keyboard-hook/","excerpt":"","text":"安装PyUserInput失败。 经查看发现是pyHook（pyHook是一个用来进行键盘、鼠标等层面事件监控的库。这个库的正常工作需要pythoncom等操作系统的API的支持。）无法安装，不知道是不是因为这个库可以被用于一些比较邪恶的目的。经搜索发现直接pip install pyHook是找不到相关包的，但可以下源码编译安装，可以在 https://www.lfd.uci.edu/~gohlke/pythonlibs/#pyhook 这里可以直接下载到.whl文件，这个文件可以作为pip install 的参数来进行安装。 直接输入pip install pyHook-1.5.1-cp36-cp36m-win_amd64.whl好像还是不行，经提示使用G:\\Py_opencv\\venv\\Scripts\\python.exe -m pip install pyHook-1.5.1-cp36-cp36m-win_amd64.whl第一个参数是python解释器，-m选项可以让python以脚本的方式运行一个模块，pip install后面就是要安装的包名。 pyHook-1.5.1-cp36-cp36m-win_amd64.whl pyHook:库名1.5.1：版本号cp3.6m：Cpython3.6版本,编码是ucs2,UCS2认为每个字符占用2个字节，UCS4认为每个字节占用4个字符，都是UNICODE的编码形式。win_amd64:windows64位环境whl:压缩包，在其中包含了py文件，以及经过编译的pyd文件。可以使用pip安装 电脑系统环境查看，可以右键“我的电脑”-&gt;“属性”查看 然后再直接在命令行里输入pip install pyuserinput或是在pycharm下载安装都可以了。（需要先安装pywin32） 上述下载的pyHook是基于Python2的,在python3下会报错:TypeError: MouseSwitch() missing 8 required positional arguments: &#39;msg&#39;, &#39;x&#39;, &#39;y&#39;, &#39;data&#39;, &#39;flags&#39;, &#39;time&#39;, &#39;hwnd&#39;, and &#39;window_name&#39;或者AttributeError: &#39;HookManager&#39; object has no attribute &#39;keyboard_hook&#39; 感谢:python3.5安装pyHook,解决【TypeError: MouseSwitch() missing 8 required positional arguments: ‘msg’, ‘x’, ‘y’, ‘data’, ‘time’, ‘hwnd’, and ‘window_name’】这个错误！、使用Python 3.5/3.6监听本机任意窗口中的按键操作提供的解决方法 需要的模块：扩展库pyhook_py3k（注意，不要使用pyhook），pywin32。第一步，安装pywin32，地址：http://www.lfd.uci.edu/~gohlke/pythonlibs/#pywin32第二步，下载pyhook_py3k，地址：https://github.com/Answeror/pyhook_py3k第三步，下载swig.exe，地址：http://www.swig.org/download.html ==&gt;.zip格式解压第四步，解压缩pyhook_py3k，并进行编译，命令：python setup.py build_ext –swig=..\\swigwin-3.0.12\\swig.exe，可以根据实际情况修改swig.exe的路径，另外本机最好已安装VC2008第五步，安装编译好的pyhook_py3k，命令：pip install . 然后就可以正常操作了!!~","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"}]},{"title":"开学小蓝车180天免费卡","slug":"开学小蓝车180天免费卡","date":"2018-09-02T08:44:54.000Z","updated":"2018-10-12T04:49:16.676Z","comments":true,"path":"2018/09/02/开学小蓝车180天免费卡/","link":"","permalink":"https://nymrli.top/2018/09/02/开学小蓝车180天免费卡/","excerpt":"各位看客老爷,可以加下我的公众号哦!虽然没啥东东….微信搜索公众号”我只要瓶果粒橙就好”","text":"各位看客老爷,可以加下我的公众号哦!虽然没啥东东….微信搜索公众号”我只要瓶果粒橙就好”","categories":[],"tags":[{"name":"生活福利","slug":"生活福利","permalink":"https://nymrli.top/tags/生活福利/"}]},{"title":"例题4:1-3 古老的密码、刽子手的游戏，救济金发放","slug":"例题4-1-3-古老的密码、刽子手的游戏，救济金发放","date":"2018-09-01T10:46:59.000Z","updated":"2018-09-01T12:38:41.000Z","comments":true,"path":"2018/09/01/例题4-1-3-古老的密码、刽子手的游戏，救济金发放/","link":"","permalink":"https://nymrli.top/2018/09/01/例题4-1-3-古老的密码、刽子手的游戏，救济金发放/","excerpt":"","text":"例题4-1 古老的密码 因为字母可以重排,所以顺序不重要,而又同时因为可以映射,所以字母具体是什么不重要==&gt;只要统计排序后的结果相同就行了 RE(Runtime error)错法加一: 题号提交错误 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;string.h&gt;void Bubblesort(int *cnt)//冒泡排序,从大到小顺序&#123; int i,j; int min=cnt[0]; for (i = 0; i &lt;26; ++i) &#123; for ( j = i+1; j &lt; 26; ++j) &#123; if (cnt[i] &lt; cnt[j]) &#123; min = cnt[i]; cnt[i]=cnt[j]; cnt[j] = min; &#125; &#125; &#125;&#125;int main()&#123; char s[2][105]; //存放猜测字符串的 int cnt[2][27]; //存放字母出现次数 int nlen[2]; //字符串的长度 while(scanf(\"%s%s\",s[0],s[1])!= EOF) &#123; memset(cnt,0,sizeof(cnt)); int i; for ( i = 0; i &lt; 2; ++i) &#123; nlen[i]= strlen(s[i]); int j; for ( j = 0; j &lt; nlen[i]; ++j) cnt[i][s[i][j]-'A'] ++; Bubblesort(cnt[i]); &#125; int k; for ( k = 0; k &lt; 26; ++k) &#123; if (cnt[0][k] != cnt[1][k]) &#123; printf(\"NO\\n\"); break; &#125; &#125; if (k==26) printf(\"YES\\n\" ); //如果26个字母出现次数比完全相等,则可以说相同. &#125; return 0;&#125; 例题4-2 刽子手的游戏 注意全局变量是否使用的问题,全局变量尽量少用…但维护内容较多的情况下,可以考虑 采用”自顶向下”的顺序 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 100char ans[maxn],gue[maxn];int left,chance;int win,lose;void guess(char ch)&#123; int bad=1; int i; for ( i = 0; i &lt; strlen(ans); ++i) //判断ch字母是否在字符串中 &#123; if (ans[i]==ch) &#123; ans[i] = ' '; bad =0; left--; //如果在的话,还剩未猜中字母数-1,机会不变 &#125; &#125; if (bad) chance--; //如果不在的话机会-1 if(!chance) lose=1; if(!left) win=1;&#125;int main()&#123; int rnd; while(scanf(\"%d%s%s\",&amp;rnd,ans,gue)==3 &amp;&amp; rnd !=-1) &#123; printf(\"Round %d\\n\",rnd); win = lose =0; left= strlen(ans); chance = 7; int i; int anslen=strlen(gue); for( i=0;i&lt; anslen;i++) &#123; guess(gue[i]); if(win || lose) break;&#125; if(win) printf(\"You win.\\n\"); else if(lose) printf(\"You lose.\\n\"); else printf(\"You chickened out.\\n\"); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;string.h&gt;char a[1000],g[1000];//储存字符串 int abook[26],gbook[26];//标记26个字母出现频率 int main()&#123; int k; int alen,glen; int i; int j; int suc,fau; int acount; while(scanf(\"%d\",&amp;k)==1&amp;&amp;k!=-1)&#123; scanf(\"%s%s\",a,g); memset(abook,0,sizeof(abook)); memset(gbook,0,sizeof(gbook)); alen=strlen(a); glen=strlen(g); for(i=0;i&lt;alen;i++)//统计答案字母频率 abook[a[i]-'a']++; acount=0; for(i=0;i&lt;26;i++) if(abook[i])//统计答案的字母组成个数（扣除雷同字母） acount++; suc=0;//猜对次数 fau=0;//猜错次数 for(i=0;i&lt;glen;i++)&#123;//以猜测字母为基准进行扫描 j=g[i]-'a'; if(abook[j]==0)&#123;//答案无此字母，猜测错误 fau++; if(fau==7)//彻底失败 break; &#125;else if(abook[j]!=0)&#123;//猜中字母 suc++; abook[j]=0;//将此字母从答案中剔除出去，此句比较关键!(再猜无效) if(suc==acount)//成功 break; &#125; &#125; printf(\"Round %d\\n\",k); if(fau&gt;=7)//猜错7次及以上 printf(\"You lose.\\n\"); else if(suc==acount)//全部猜对 printf(\"You win.\\n\"); else printf(\"You chickened out.\\n\"); &#125; return 0;&#125; 例题4-3 救济金发放 圆圈如何轮回==&gt;本质上是要求,大于n变成1,小于1变成n…实现1.越界后归正。2.(xxx)%n, 领过设为1,没领过(初始)设为1 较为简洁、清晰的做法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;string.h&gt;int book[100];//领过的标记1，没领过的标记0 int main()&#123; int n,k,m; int kcount,mcount; int ki,mi; int kout,mout; int first; int ncount; while(scanf(\"%d%d%d\",&amp;n,&amp;k,&amp;m)==3&amp;&amp;n&amp;&amp;k&amp;&amp;m)&#123; memset(book,0,sizeof(book)); ncount=0; ki=0; mi=n+1; first=1; while(ncount!=n)&#123;//n个人全被处理完毕//处理手法有些类似快速排序 kcount=0; mcount=0; //每数一个人,都要判断是不是该越过他.只有0(未领过,才计数) while(kcount!=k)&#123;//k系列处理 ki++; if(ki&gt;n)//ki越界处理 ki=1; if(book[ki]==0)//未被选中计数 ki为当前值 kcount++; &#125; while(mcount!=m)&#123;//m系列处理 mi--; if(mi&lt;1)//mi越界处理 mi=n; if(book[mi]==0)//未被选中计数 mi为当前值 mcount++; &#125; book[ki]=1;//不用担心ki==mi(重复设置为1不影响) book[mi]=1; if(first)&#123;//打印处理 first=0; if(ki!=mi)&#123; printf(\"%3d%3d\",ki,mi); ncount+=2; &#125; else&#123; printf(\"%3d\",ki); ncount++; &#125; &#125;else&#123; if(ki!=mi)&#123; printf(\",%3d%3d\",ki,mi); ncount+=2; &#125; else&#123; printf(\",%3d\",ki); ncount++; &#125; &#125; &#125; printf(\"\\n\"); &#125; return 0;&#125; 书上做法123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 25int n,k,m,a[maxn];int go(int p,int d,int t)&#123; while(t--) //每数一个人都要判断他是否已经领过 do&#123; p = (n+p+d)%n; &#125;while(!a[p]); //==0,领过 return p;&#125;int main()&#123; while(scanf(\"%d,%d,%d\",&amp;n,&amp;k,&amp;m)==3 &amp;&amp; n) &#123; for (int i = 0; i &lt; n; ++i) a[i]=i; int left =n; int p1 =n,p2=1; while(left) &#123; p1= go(p1,-1,k); p2= go(p2,1,m); printf(\"%d\",p1);left--; if(p1!=p2) printf(\" %d\",p2); a[p1]=a[p2]=0; //领了设置为0 if(left) printf(\",\"); //注意输出格式 &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"ACM竞赛入门","slug":"ACM竞赛入门","permalink":"https://nymrli.top/tags/ACM竞赛入门/"},{"name":"C","slug":"C","permalink":"https://nymrli.top/tags/C/"}]},{"title":"WampSever配置本地环境，解决打开打开本地网站问题","slug":"WampSever配置本地环境，解决打开打开本地网站问题","date":"2018-09-01T06:19:39.000Z","updated":"2018-09-01T06:26:52.393Z","comments":true,"path":"2018/09/01/WampSever配置本地环境，解决打开打开本地网站问题/","link":"","permalink":"https://nymrli.top/2018/09/01/WampSever配置本地环境，解决打开打开本地网站问题/","excerpt":"","text":"WampServer是一款由法国人开发的Apache Web服务器、PHP解释器以及MySQL数据库的整合软件包。免去了开发人员将时间花费在繁琐的配置环境过程，从而腾出更多精力去做开发。 直接点击本地的.html是静态加载的，需要动态加载的文件是无法被加载的。会出现如下情况。 于是选用了Wamp搭本地服务器浏览网站，这样就能成功加载动态文件了。 在此分享下配置WampSever时碰到的问题和解决的方法： 服务器是否已正常运行如果能登上则表示服务器能够正常运行。(在地址栏中输入localhost:端口(或是127.0.0.1:端口) 或是左键图标选择’localhost’) localhost 指你所在的计算机本身。 在windows系统它成了127.0.0.1的别名 ，在Unix系统下，查看网卡配置会发现作为本地回环的方式，一定程度上使用localhost比127.0.0.1要快一些。 在Hosts文件中，localhost指向的IP是127.0.0.1这个关系是可以修改的。 查看、修改端口 配置本地环境、添加项目、打开本地网站 1项目中是空的,需要手动将要打开的网站放到'www'目录中 1可以选择输入路径，也可以直接左键选择'www目录'打开 1将要打开网站的文件夹复制到'www目录下'，会发现刚添加的文件夹出现在了项目中。 勾选’Add localhost in url’1看似到此已经大功告成，然而再点击进去这些文件夹时会出现如下情况： 1可以看到的是URL并不对，我们是想要实现通过web服务器的方式访问这些网站，然而这个明显没达到我们想要的效果，根据提示，我找到了原因。 1右键选择'Wamp Settings'中将'Add localhost in url'选项勾上后再次如上打开项目即可。（记得重新打开一次localhost页面或是刷新一下） 1可以看到网站成功地通过web服务器打开了，那些之前提示需要动态加载的文件也成功加载了。 撒花完结！~200成功！ ▲.看到这，我相信你也明白了为什么必须要有’Add localhost in url’这步了。同时也猜到了，其实直接在网址里面输入正确的网址也是可以的，如http://localhost:8080/data-visualize-chain-master/,结果也是能打开的。 希望能对你们有所帮助。","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"WAMP","slug":"WAMP","permalink":"https://nymrli.top/tags/WAMP/"}]},{"title":"Ubuntu下Sublime配置Python环境使用指导:","slug":"Ubuntu下Sublime配置Python环境使用指导","date":"2018-09-01T06:04:47.000Z","updated":"2018-09-01T06:26:28.406Z","comments":true,"path":"2018/09/01/Ubuntu下Sublime配置Python环境使用指导/","link":"","permalink":"https://nymrli.top/2018/09/01/Ubuntu下Sublime配置Python环境使用指导/","excerpt":"","text":"Sublime配置python编译环境及搭建虚拟环境:(windows下大致相同)1.编译环境配置1import urllib.request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 1.点击 官方网址 从 Sublime Text 3 官方获取用于安装的代码。从菜单栏View –&gt;Show Console或者使用Ctrl+`(esc键下面的按键)，调出sublime的控制台，将官网中的python代码粘贴进去并按Enter执行，最终可以安装完成。在控制台中粘贴刚才的代码，然后点击回车。最后重启ST3。 2.现在你可以通过快捷键 cmd+shift+P 打开 Package Control 来安装其他的插件了。输入 install 然后你就能看见屏幕上出现了 Package Control: Install Package，点击回车,然后搜索sublimeREPL 安装成功后，可以在菜单栏的’TOOL’中找到SublimeREPL，如图所示 2.将菜单栏改为中文若需要将菜单栏改成中文可如上操作下载插件“ConvertToUTF8”或是安装插件“ChineseLocalizations”(本人使用的是这个，没试ConvertToUTF8的效果) (参考博客:http://blog.51cto.com/11970781/2087971) 3.安装Anaconda插件 1.点击刚刚生成的Package Control -&gt;输入install 2.进入安装界面，安装好后再在新窗口命令行中输入Anaconda并点击第一个备选项进行安装。 安装完成后会显示messages文档。 安装Anaconda插件完成之后，会看到如下选项栏，说明Anaconda安装成功。 - Goto Definitions 能够在你的整个工程中查找并且显示任意一个变量，函数或者类的定义。 - Find Usage 能够快速的查找某个变量，函数或者类在某个特定文件中的什么地方被使用了。 - Show Documentation： 能够显示一个函数或者类的说明性字符串(当然，是在定义了字符串的情况下) Anaconda会自动补全代码，之前用惯了pycharm发现突然没了代码补全后很不习惯，Anaconda的补全功能虽然没有pycharm那么好用，但还是不错的 还有需要注意的是，安装Anaconda插件后，如果python代码没有遵循PEP8规范，会出现白色的框框，或是可以使用快捷键Ctrl+Alt+R进行规范代码(这个可以去除，步骤如下) 在Settings-User选项中添加配置:{“anaconda_linting”:false} 4.安装虚拟环境 1.首先使用终端安装virtualenv，pip3 install virtualenv2.在需要创建的地方进行虚拟环境的搭建，代码如下： 123mkdir pytest(文件夹名)cd pytestvirtualenv venv 在终端进入虚拟环境的话是在pytest文件夹下输入命令source /bin/activate而要在sublime中进入虚拟环境的话就得按照如下操作： １．首先在sublime中安装virtualenv插件，Ctrl + Shift + P，然后输入install,回车，然后搜索virtualenv。 2. 安装完成后，直接按Ctrl + Shift + P，再输入Activate，若没有该选项则virtualenv安装中出现问题，需要重新安装。如果有的会选择Activate就能发现刚刚创建的虚拟环境，选中后回车即可进入虚拟环境 3. 如果Activate选中后没有出现我们刚刚创建的虚拟环境，则需要我们手动添加路径.Ctrl + Shift + P，然后输入Add directory，回车，屏幕下面会出现输入行（Directory path）:再将刚创建的虚拟环境路径填入即可 另外，我曾碰到过Add directory后仍然没用的情况。那时，可选择“”Project”=&gt;”Add folder to project”选择文件后=&gt;”Save Project as”==&gt;保存好即可 工程配置文件为： .sublime-workspace、.sublime-project 其中sublime-project为: 123456789101112131415161718&#123; \"build_systems\": [ &#123; \"file_regex\": \"^[ ]File \"(...?)\", line ([0-9]*)\", \"name\": \"Anaconda Python Builder\", \"selector\": \"source.python\", \"shell_cmd\": \"\"python\" -u \"$file\"\" &#125; ], \"folders\": [ &#123; \"path\": \"爬虫\" &#125; ], \"virtualenv\": \"G:\\pachong\\venv\"&#125; 这样环境就配置好了。按Ctrl+B编译时，观察”Tools”-&gt;”Build System”-&gt;是否为”Python+ Virtualenv”，如果不是，则选用这个再Ctrl+B就是在虚拟环境中编译了! ubuntu下sublime默认情况下好像不能输入中文，需要用下面命令就可以完美支持中文输入： 1234sudo apt-get update &amp;&amp; sudo apt-get upgradegit clone https://github.com/lyfeyaj/sublime-text-imfix.gitcd sublime-text-imfix./sublime-imfix 转自CV_YOU的博客 完美解决Sublime无法输入中文问题 截图好像有点问题，菜单栏都没有截到，用到的三个分别为“项目(Project)”，“首选项(Preferences)”，“帮助(Help)”","categories":[],"tags":[{"name":"Sublime Text","slug":"Sublime-Text","permalink":"https://nymrli.top/tags/Sublime-Text/"},{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"}]},{"title":"python pywin32 PyUserInput实现自动化脚本","slug":"python-win32api-win32gui-win32con-PyUserInput实现自动化脚本","date":"2018-08-31T11:43:00.000Z","updated":"2018-08-31T11:56:56.677Z","comments":true,"path":"2018/08/31/python-win32api-win32gui-win32con-PyUserInput实现自动化脚本/","link":"","permalink":"https://nymrli.top/2018/08/31/python-win32api-win32gui-win32con-PyUserInput实现自动化脚本/","excerpt":"","text":"pywin32用spy++工具查找到句柄，再结合PyUserInput就能很好地实现自动化脚本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152import win32guiimport win32conimport win32api# 从顶层窗口向下搜索主窗口，无法搜索子窗口# FindWindow(lpClassName=None, lpWindowName=None) 窗口类名 窗口标题名handle = win32gui.FindWindow(\"Notepad\", None) # 获取窗口位置left, top, right, bottom = win32gui.GetWindowRect(handle)#获取某个句柄的类名和标题title = win32gui.GetWindowText(handle) clsname = win32gui.GetClassName(handle)# 打印句柄# 十进制print(handle)# 十六进制print(\"%x\" %(handle) )# 搜索子窗口# 枚举子窗口hwndChildList = [] win32gui.EnumChildWindows(handle, lambda hwnd, param: param.append(hwnd), hwndChildList)# FindWindowEx(hwndParent=0, hwndChildAfter=0, lpszClass=None, lpszWindow=None) # 父窗口句柄 若不为0，则按照z-index的顺序从hwndChildAfter向后开始搜索子窗体，否则从第一个子窗体开始搜索。 子窗口类名 子窗口标题subHandle = win32gui.FindWindowEx(handle, 0, \"EDIT\", None)# 获得窗口的菜单句柄menuHandle = win32gui.GetMenu(subHandle)# 获得子菜单或下拉菜单句柄 # 参数：菜单句柄 子菜单索引号subMenuHandle = win32gui.GetSubMenu(menuHandle, 0)# 获得菜单项中的的标志符，注意，分隔符是被编入索引的 # 参数：子菜单句柄 项目索引号 menuItemHandle = win32gui.GetMenuItemID(subMenuHandle, 0)# 发送消息，加入消息队列，无返回 # 参数：句柄 消息类型 WParam IParamwin32gui.postMessage(subHandle, win32con.WM_COMMAND, menuItemHandle, 0)# wParam的定义是32位整型，high word就是他的31至16位，low word是它的15至0位。# 当参数超过两个，wParam和lParam不够用时，可以将wParam就给拆成两个int16来使用。# 这种时候在python里记得用把HIWORD的常数向左移16位，再加LOWORD，即wParam = HIWORD&lt;&lt;16+LOWORD。# 下选框内容更改# 参数：下选框句柄； 消息内容； #参数下选框的哪一个item，以0起始的待选选项的索引；如果该值为-1，将从组合框列表中删除当前选项，并使当前选项为空；# 参数CB_Handle为下选框句柄，PCB_handle下选框父窗口句柄if win32api.SendMessage(CB_handle, win32con.CB_SETCURSEL, 1, 0) == 1:# 下选框的父窗口命令# 参数：父窗口句柄； 命令； # 参数：WParam：高位表示类型，低位表示内容；参数IParam，下选框句柄# CBN_SELENDOK当用户选择了有效的列表项时发送，提示父窗体处理用户的选择。 LOWORD为组合框的ID. HIWORD为CBN_SELENDOK的值。 win32api.SendMessage(PCB_handle, win32con.WM_COMMAND, 0x90000, CB_handle) # CBN_SELCHANGE当用户更改了列表项的选择时发送，不论用户是通过鼠标选择或是通过方向键选择都会发送此通知。LOWORD为组合框的ID. HIWORD为CBN_SELCHANGE的值。 win32api.SendMessage(PCB_handle, win32con.WM_COMMAND, 0x10000, CB_handle) # 设置文本框内容，等窗口处理完毕后返回true。中文需编码成gbk # 参数：句柄；消息类型；# 参数WParam，无需使用； # 参数IParam，要设置的内容，字符串win32api.SendMessage(handle, win32con.WM_SETTEXT, 0, os.path.abspath(fgFilePath).encode('gbk'))# 控件点击确定,处理消息后返回0# 参数:窗口句柄; 消息类型; 参数WParam HIWORD为0（未使用），LOWORD为控件的ID; 参数IParam 0（未使用）,确定控件的句柄win32api.SendMessage(Mhandle, win32con.WM_COMMAND, 1, confirmBTN_handle)# 获取窗口文本不含截尾空字符的长度# 参数：窗口句柄； 消息类型； 参数WParam； 参数IParambufSize = win32api.SendMessage(subHandle, win32con.WM_GETTEXTLENGTH, 0, 0) +1# 利用api生成BufferstrBuf = win32gui.PyMakeBuffer(bufSize)print(strBuf)# 发送消息获取文本内容# 参数：窗口句柄； 消息类型；文本大小； 存储位置length = win32gui.SendMessage(subHandle, win32con.WM_GETTEXT, bufSize, strBuf)# 反向内容，转为字符串# text = str(strBuf[:-1])address, length = win32gui.PyGetBufferAddressAndLen(strBuf) text = win32gui.PyGetString(address, length) # print('text: ', text)# 鼠标单击事件#鼠标定位到(30,50)win32api.SetCursorPos([30,150])#执行左单键击，若需要双击则延时几毫秒再点击一次即可win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP | win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)#右键单击win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTUP | win32con.MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0)def click1(x,y): #第一种 win32api.SetCursorPos((x,y)) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN,x,y,0,0) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP,x,y,0,0)def click2(x,y): #第二种 ctypes.windll.user32.SetCursorPos(x,y) ctypes.windll.user32.mouse_event(2,0,0,0,0) ctypes.windll.user32.mouse_event(4,0,0,0,0)def click_it(pos): #第三种 handle= win32gui.WindowFromPoint(pos) client_pos =win32gui.ScreenToClient(handle,pos) tmp=win32api.MAKELONG(client_pos[0],client_pos[1]) win32gui.SendMessage(handle, win32con.WM_ACTIVATE,win32con.WA_ACTIVE,0) win32gui.SendMessage(handle, win32con.WM_LBUTTONDOWN,win32con.MK_LBUTTON,tmp) win32gui.SendMessage(handle, win32con.WM_LBUTTONUP,win32con.MK_LBUTTON,tmp)# 发送回车win32api.keybd_event(13,0,0,0)win32api.keybd_event(13,0,win32con.KEYEVENTF_KEYUP,0)# 关闭窗口win32gui.PostMessage(win32lib.findWindow(classname, titlename), win32con.WM_CLOSE, 0, 0)# 检查窗口是否最小化，如果是最大化if(win32gui.IsIconic(hwnd)):# win32gui.ShowWindow(hwnd, win32con.SW_SHOWNORMAL) win32gui.ShowWindow(hwnd, 8) sleep(0.5)# SW_HIDE：隐藏窗口并激活其他窗口。nCmdShow=0。# SW_MAXIMIZE：最大化指定的窗口。nCmdShow=3。# SW_MINIMIZE：最小化指定的窗口并且激活在Z序中的下一个顶层窗口。nCmdShow=6。# SW_RESTORE：激活并显示窗口。如果窗口最小化或最大化，则系统将窗口恢复到原来的尺寸和位置。在恢复最小化窗口时，应用程序应该指定这个标志。nCmdShow=9。# SW_SHOW：在窗口原来的位置以原来的尺寸激活和显示窗口。nCmdShow=5。# SW_SHOWDEFAULT：依据在STARTUPINFO结构中指定的SW_FLAG标志设定显示状态，STARTUPINFO 结构是由启动应用程序的程序传递给CreateProcess函数的。nCmdShow=10。# SW_SHOWMAXIMIZED：激活窗口并将其最大化。nCmdShow=3。# SW_SHOWMINIMIZED：激活窗口并将其最小化。nCmdShow=2。# SW_SHOWMINNOACTIVE：窗口最小化，激活窗口仍然维持激活状态。nCmdShow=7。# SW_SHOWNA：以窗口原来的状态显示窗口。激活窗口仍然维持激活状态。nCmdShow=8。# SW_SHOWNOACTIVATE：以窗口最近一次的大小和状态显示窗口。激活窗口仍然维持激活状态。nCmdShow=4。# SW_SHOWNORMAL：激活并显示一个窗口。如果窗口被最小化或最大化，系统将其恢复到原来的尺寸和大小。应用程序在第一次显示窗口的时候应该指定此标志。nCmdShow=1。 感谢python win32api win32gui win32con 窗口句柄 发送消息 常用方法 键盘输入，代码主要来自于他 ▲.需要注意在windows和mac下接口参数可能有所不同。win32虽然也可控制键盘，但不如使用PyUserInput的方便。安装PyUserInput教程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pymouse import PyMousefrom pykeyboard import PyKeyboard#实例化m = PyMouse() k = PyKeyboard()x_dim, y_dim = m.screen_size()# 鼠标点击 参数:x,y,button=1(左键)、2(右键)、3(中间),次数m.click(x_dim, y_dim, button=1,n=1) # 键盘输入 参数:str,间隔k.type_string('Hello, World!',interval=0)# 按住一个键k.press_key('H')# 松开一个键k.release_key('H')# 相当于===&gt;按住并松开，tap一个键k.tap_key('e')# tap支持重复的间歇点击键,参数:str,次数,间隔k.tap_key('l',n=2,interval=5) #创建组合键===&gt;press_key和release_key结合使用k.press_key(k.alt_key)k.tap_key(k.tab_key)k.release_key(k.alt_key)# 特殊功能键k.tap_key(k.function_keys[5]) # Tap F5k.tap_key(k.numpad_keys['Home']) # Tap 'Home' on the numpadk.tap_key(k.numpad_keys[5], n=3) # Tap 5 on the numpad, thrice# Mac系统按键k.press_keys(['Command','shift','3'])# Windows系统按键k.press_keys([k.windows_l_key,'d'])其中pymouse的PyMouseEvent和pykeyboard的PyKeyboardEvent还可用于监听鼠标和键盘事件的输入class Clickonacci(PyMouseEvent): def __init__(self): PyMouseEvent.__init__(self) self.fibo = fibo() def click(self, x, y, button, press): '''Print Fibonacci numbers when the left click is pressed.''' if button == 1: if press: print('Press times:%d'.format(press)) else: # Exit if any other mouse button used self.stop()C = Clickonacci()C.run()class TapRecord(PyKeyboardEvent): def __init__(self): PyKeyboardEvent.__init__(self) def tap(self, keycode, character, press): print(time.time(), keycode, character, press)t = TapRecord()t.run()#这些对象是一个架构用于监听鼠标和键盘的输入；他们除了监听之外不会做任何事，需要继承重构他们#PyKeyboardEvent为编写完成，所以这里是一个继承PyMouseEvent的例子：","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"},{"name":"自动化运维","slug":"自动化运维","permalink":"https://nymrli.top/tags/自动化运维/"}]},{"title":"Hello 搭建Hexo博客","slug":"hello-hexo","date":"2018-08-30T13:14:27.000Z","updated":"2018-09-01T10:33:39.636Z","comments":true,"path":"2018/08/30/hello-hexo/","link":"","permalink":"https://nymrli.top/2018/08/30/hello-hexo/","excerpt":"","text":"电脑环境是Windows，安装好git后，所有搭建操作均在git bash内完成 1.需要安装git, node.js, npm 注:第一次安装Git会让配置user信息 123&gt; $git config --global user.name \"yourname\" #（yourname是git的用户名）&gt; $git config --global user.email \"youremail\"）&gt; 2.使用npm安装hexo： npm install -g hexo3.创建hexo文件夹，并单击鼠标右键选择 Git bash：(我的创建路径是：E:\\hexo）4.在刚刚打开的git bash命令框中操作：1234$hexo init #hexo 会自动创建网站所需要的文件$npm install #安装依赖包$hexo generate # 等价于hexo g$hexo server #现在可以用127.0.0.1:4000访问hexo默认的hello world界面,等价于hexo s 5.部署到github (https://github.com/)， 首先注册登录,然后创建页面仓库，Repository name 命名必须是 youname.github.io ，（youname 就是你注册时候用的name） ssh-keygen -t rsa -C &quot;email&quot; #生成ssh密钥，按三次回车键，密码为空,这边会生成id_rsa和_rsa.pub文件，打开id_rsa.pub，复制全文添加到GitHub 的Add SSH key中。 最后可以验证一下ssh -T git@github.com,看出现的是不是Hi &quot;Yourname&quot;如果出现了你的github用户名,则成功了 6.下载Hexo主题 $git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia #下载hexo的yilia 模板到自己的文件目录下 打开项目目录下的_config.yml文件，更改theme：yilia ▲注意: _config.yml文件中配置时:后面都要加空格,与:隔开 7.开启评论功能：使用gitment$npm install gitment --save #安装gitment 然后在 https://github.com/settings/applications/new 进行注册，获取Client ID和Client Secret ▲注意:其中Authorization callback URL是个坑: 这一项不能乱填,不让就不能&quot;初始化评论&quot;.. 应该怎么填呢? 如果你绑定了自己的域名就直接写自己的域名: https://nymrli.top/ 如果没有的话才填写http://Freedomisgood.github.io,否则会一直弹回博客首页,而不能”初始化评论”或者”发表评论” 其中的原因就在于,既可以通过www.nymrli.top解析，也可通过nymrli.top解析,还可以通http://Freedomisgood.github.io解析,而Authorization callback URL只能写一个.(最终解析到的网站)…===&gt;就是nymrli.top △.感谢IsResultXaL提供的思路 打开themes/yilia目录下的_config.yml文件进行修改并保存： 再次生成网站,提交网站:hexo d -g就可以输入网址:https://yourname.github.io打开你的博客了 8.显示文章摘要图片 1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 在hexo目录下打开git Bsh或者power Shell,npm install hexo-asset-image --save安装插件 再运行hexo n &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： 1![你想输入的替代文字](xxxx/图片名.jpg) ▲ .之前一直失败,原因在于,我写图片链接的时候是直接拖动图片到编辑器中的,路径为![v2-代替文字](E:\\hexo\\source\\_posts\\xxxx\\图片名.jpg),后来一直错误,无法正常显示后，发现只需要写成![代替文字](xxxx\\图片名.jpg)即可.. 文章总体框架:12345678910---layout: phototitle: Hello Hexodate: 2018-08-30 21:14:27tags: - hexo---![代替文字](xxxx\\图片名.jpg)&lt;!--more--&gt;正文 →推一个不错的文章Hexo+Coding+Github部署个人博客Error全集,如果出现未能解决的问题,希望能从这篇文章略微得到启发.","categories":[],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://nymrli.top/tags/环境配置/"},{"name":"hexo","slug":"hexo","permalink":"https://nymrli.top/tags/hexo/"}]},{"title":"Python字典基本操作介绍","slug":"Python字典基本操作介绍","date":"2018-08-30T13:14:27.000Z","updated":"2018-09-01T06:03:37.532Z","comments":true,"path":"2018/08/30/Python字典基本操作介绍/","link":"","permalink":"https://nymrli.top/2018/08/30/Python字典基本操作介绍/","excerpt":"","text":"创建字典 info={} info=dict() 初始化字典法一123key = 'name'info = &#123; key 'cold'&#125;==&#123;'name''cold'&#125; 法二12info = dict(key = 'cold')==&#123;'key''cold'&#125; 法三1#还有可以使用dict(zip(a,b))其中a,b都是列表,会生成以A中元素为键,B中元素为值的字典 插入新的键值对(更新) info.update(name=’cold’, blog=’www.linuxzen.com&#39;) 在字典有没有k这个键时可以使用dict.setdefault(key,value) 还可以使用dict(var = value)其中var可以是变量,也可以不是,注意不用加 或是_dict[‘xxx’]=’yyy’ 获得键值 确定存在的情况下- info.get(‘xxx’) info[‘xxx’] 不确定是否存在 info.get(‘xxx’) 遍历字典 获得key,再通过key来获得valuefor key in dicprint(%d,%d%(key,_dict[key])) 使用dict.items()for key,value in dic.items()print ‘key is %s,value is %s’%(key,value) 字典删除del info[&#39;xxx&#39;]","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://nymrli.top/tags/Python/"}]}]}