<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mrli&#39;s Blog</title>
  
  <subtitle>别装作很努力，结局不会陪你演戏。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nymrli.top/"/>
  <updated>2020-12-11T13:02:05.492Z</updated>
  <id>https://nymrli.top/</id>
  
  <author>
    <name>Mrli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>细品单例模式</title>
    <link href="https://nymrli.top/2020/12/11/%E7%BB%86%E5%93%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://nymrli.top/2020/12/11/细品单例模式/</id>
    <published>2020-12-11T02:25:26.000Z</published>
    <updated>2020-12-11T13:02:05.492Z</updated>
    
    <content type="html"><![CDATA[<p>虽然还没正式踏入开发就业浪潮中，但为了保证自己的代码质量，最近还是在学设计模式相关内容。以下为读《研磨设计模式》和《设计模式就该这样学：基于经典框架源码和真实业务场景》的读书笔记。</p><blockquote><p>GoF的《设计模式》就是设计模式的始祖、经典教科书。其描述严谨，举例恰当，分类组织，是应该反复细读的经典，两本书皆提及了GoF这本书，引用了GoF中的部分例子。</p></blockquote><h1 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h1><h2 id="虚拟场景"><a class="markdownIt-Anchor" href="#虚拟场景"></a> 虚拟场景：</h2><p>读取配置文件的内容（假设系统采用的是properties格式的配置文件）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.dp.singleton.example1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来存放配置文件中参数A的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String parameterA;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来存放配置文件中参数B的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String parameterB;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getParameterA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parameterA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getParameterB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parameterB;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AppConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//调用读取配置文件的方法</span></span><br><span class="line">readConfig();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取配置文件，把配置文件中的内容读出来设置到属性上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">Properties p = <span class="keyword">new</span> Properties(); </span><br><span class="line">InputStream in = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">in = AppConfig.class.getResourceAsStream(<span class="string">"AppConfig.properties"</span>);</span><br><span class="line">p.load(in);</span><br><span class="line"><span class="comment">//把配置文件中的内容读出来设置到属性上</span></span><br><span class="line"><span class="keyword">this</span>.parameterA = p.getProperty(<span class="string">"paramA"</span>);</span><br><span class="line"><span class="keyword">this</span>.parameterB = p.getProperty(<span class="string">"paramB"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"装载配置文件出错了，具体堆栈信息如下："</span>);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">in.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="存在的问题"><a class="markdownIt-Anchor" href="#存在的问题"></a> 存在的问题：</h2><p>系统运行期间，如果存在很多个AppConfig的实例对象即配置内容，会严重浪费内存资源。实际上，对于AppConfig这种类<strong>在运行期间只要一个实例对象就够了</strong>。===&gt;单例模式</p><blockquote><p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p></blockquote><h2 id="单例实现思路"><a class="markdownIt-Anchor" href="#单例实现思路"></a> 单例实现思路：</h2><p>一个类能够被创建多个实例的问题根源在于类的构造方法是公开的，也就是可以让类的外部通过构造方法来创建多个实例。换句话说，只要类的构造方法能让类的外部访问，就没有办法去控制外部来创建这个类的实例个数。要想控制一个类只被创建一个实例，那么首要的问题就是要把<strong>创建实例的权限收回来，让类自身来负责自己类实例的创建工作</strong>，然后由这个类来提供外部可以访问这个类实例的方法，这就是单例模式的实现方式。</p><h2 id="单例模式的结构和说明"><a class="markdownIt-Anchor" href="#单例模式的结构和说明"></a> 单例模式的结构和说明：</h2><p><img src="/2020/12/11/细品单例模式/%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="结构图"></p><p>Singleton：私有化构造函数来隐藏构造，从而自己负责创建Singleton类自己的唯一实例，并提供一个getlnstance的方法，让外部来访问这个类的唯一实例。</p><h2 id="基础级单例"><a class="markdownIt-Anchor" href="#基础级单例"></a> 基础级单例</h2><h3 id="饿汉式"><a class="markdownIt-Anchor" href="#饿汉式"></a> 饿汉式</h3><blockquote><p>所谓饿汉式，既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在<strong>装载类的时候就创建对象实例</strong>，写法如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现方式"><a class="markdownIt-Anchor" href="#实现方式"></a> 实现方式：</h4><ol><li>私有化构造方法</li><li>提供获取实例的方法getInstance</li><li>把获取实例的方法变成静态方法</li><li>定义存储实例的属性(成员变量)instance</li><li>将实例成员变量instance定义为静态的（由于要在静态方法中使用，被迫写成static，没用到static特性）</li><li>从而实现控制实例的创建</li></ol><h3 id="懒汉式"><a class="markdownIt-Anchor" href="#懒汉式"></a> 懒汉式</h3><blockquote><p>所谓懒汉式，既然是<strong>懒</strong>，那么在创建对象实例的时候就不着急，<strong>会一直等到马上要使用对象实例的时候才会创建</strong>，懒人嘛，总是推托不开的时候才去真正执行工作，因此在装载对象的时候不创建对象实例，写法如下：</p><p>懒汉式体现了延迟加载的思想，lazy load，这个lazy并不是懒惰的意思，而是延迟的意思，Lazy load在实际开发中是种很常见的思想，可以尽可能的节约资源。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个变量来存储创建好的类实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ▲私有化构造方法，将构造方法权限回收，好在内部控制创建实例的数目</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个方法来为客户端提供类实例， 提供访问方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一个Singleton的实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现方式-2"><a class="markdownIt-Anchor" href="#实现方式-2"></a> 实现方式：</h4><ol><li>私有化构造方法</li><li>提供获取实例的方法getInstance</li><li>把获取实例的方法变成静态方法</li><li>定义存储实例的属性(成员变量)instance</li><li>将实例成员变量instance定义为静态的（利用static在类装载的时候执行的特性，从而实现初始化）</li><li>从而实现控制实例的创建</li></ol><p>🎯以上两种就是最基础的单例写法，在不考虑复杂的条件下仅是满足了定义所要求的功能：运行期间只会被创建一个实例，切提供了一个全局唯一访问点（即getInstance方法）</p><h3 id="优缺点分析"><a class="markdownIt-Anchor" href="#优缺点分析"></a> 优缺点分析：</h3><ul><li>时间和空间：<ul><li>饿汉：空间换时间，类加载时就创建。因此当系统有大量单例对象存在时，系统初始化就会造成大量的内存浪费</li><li>懒汉：时间换空间，每次获取时都需要判断是否需要创建实例</li></ul></li><li>线程安全：<ul><li>饿汉：线程安全，因为虚拟机保证智慧加载以此类推，并且加载类的时候不会并发发生。</li><li>懒汉：需要加上synchronized关键字才能确认线程安全，但synchronized加在方法上会比较影响性能，导致大批量线程阻塞，从而导致程序性能大幅下降</li></ul></li></ul><h2 id="双重检查锁"><a class="markdownIt-Anchor" href="#双重检查锁"></a> 双重检查锁</h2><blockquote><p>为了保证加载时的性能-&gt;即不能采用饿汉，而是得采用懒汉lazy load的模式</p><p>那么如何较好地保证线程安全呢？===&gt;在懒汉式的基础上，我们得到了双重检查锁</p></blockquote><p>懒汉式的做法好比地铁进站限流，在寒风刺骨的冬天，所有人都在站前广场转圈，用户体验会不好；而双重检查就是设置两重检查，好比在入站门处和入厅后再闸口检票处再检查一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对保存实例的变量添加volatile的修饰。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//先检查实例是否存在，如果不存在才进入下面的同步块</span></span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//同步块，线程安全的创建实例</span></span><br><span class="line"><span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line"><span class="comment">//再次检查实例是否存在，如果不存在才真的创建实例</span></span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查加锁机制和懒汉不同的在于并不是进入getInstace方法需要同步(由方法加锁-&gt;方法内部加对象锁)，而是不存在实例的时候才会进入同步块。此处阻塞的不是基于整个LazyDoubleCheckSingleton类的阻塞，而是在getInstance方法内部的阻塞，只要逻辑不复杂，对于调用者是感觉不到的。</p><p>▲注：被volatile修饰的变量的值不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存的，从而使得多个线程能够正确的处理该变量。（由于Java1.4前对volatile关键字实现有问题，因此双重检查锁适用于Java1.5以后）。此外<u>volatile可能会屏蔽JVM一些必要的代码优化，所以会降低运行效率</u>，因此一般建议没有特别需要，不要使用volatile。因此，<strong>不建议系统中大量使用双重检查锁</strong>。</p><h2 id="静态内部类式类级内部类"><a class="markdownIt-Anchor" href="#静态内部类式类级内部类"></a> 静态内部类式（类级内部类）</h2><blockquote><p>虽然双重检查锁较之懒汉和饿汉有了不少优化，但双重检查锁仍存在1.volatile性能、2.synchronized性能，有没有什么办法不使用synchronized关键字，还能实现延迟加载和线程安全呢？==&gt;静态内部类式</p></blockquote><h3 id="什么是类级内部类"><a class="markdownIt-Anchor" href="#什么是类级内部类"></a> 什么是类级内部类？</h3><p>简单点说，<strong>类级内部类</strong>指的是，有<u>static修饰的成员式内部类</u>。如果没有static修饰的成员式内部类被称为<strong>对象级内部类</strong>。</p><ul><li>类级内部类相当于其外部类的static成分，<u>它的对象(类级内部类对象)与外部类对象间不存在依赖关系</u>，因此可直接创建。而对象级内部类的实例，是绑定在外部对象实例中的。</li><li>类级内部类中，可以定义静态的方法。在<u>内部类的静态方法</u>中只能够引用外部类中的<strong>静态</strong>成员方法或者成员变量。</li><li><strong>类级内部类相当于其外部类的成员，只有在第一次被使用的时候才会被装载。</strong></li></ul><h4 id="jvm隐含执行同步的情况"><a class="markdownIt-Anchor" href="#jvm隐含执行同步的情况"></a> JVM隐含执行同步的情况：</h4><ul><li>由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时</li><li>访问final字段时</li><li>在创建线程之前创建对象时</li><li>线程可以看见它将要处理的对象时</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyStaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例没有绑定关系，</span></span><br><span class="line"><span class="comment"> * 而且只有被调用到才会装载，从而实现了延迟加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态初始化器，由JVM来保证线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LazyStaticInnerClassSingleton instance = <span class="keyword">new</span> LazyStaticInnerClassSingleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有化构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazyStaticInnerClassSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyStaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决反射破坏单例问题"><a class="markdownIt-Anchor" href="#解决反射破坏单例问题"></a> 解决反射破坏单例问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyStaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例没有绑定关系，</span></span><br><span class="line"><span class="comment"> * 而且只有被调用到才会装载，从而实现了延迟加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态初始化器，由JVM来保证线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LazyStaticInnerClassSingleton instance = <span class="keyword">new</span> LazyStaticInnerClassSingleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有化构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazyStaticInnerClassSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (LazyStaticInnerClassSingleton.instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不允许创建多个实例"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyStaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举式单例"><a class="markdownIt-Anchor" href="#枚举式单例"></a> 枚举式单例</h2><blockquote><p>虽然静态内部类式已经接近完美了，但还不够优雅，还有没有更优雅的写法呢？—&gt;枚举式单例</p></blockquote><p>对枚举的观点：</p><ul><li>Java的枚举类型实质上是功能齐全的类，因此可以有自己的属性和方法。</li><li>Java枚举类型的基本思想是通过公有的静态final域为每个<u>枚举常量</u>导出<u>实例的类</u>。</li><li>从某个角度讲，<u>枚举</u>是单例的泛型化，<u>本质上是<em>单元素</em>的枚举</u>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个枚举的元素,它就代表了Singleton的一个实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">uniqueInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 示意方法，单例可以有自己的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singletonOperation</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//功能处理</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举来实现单实例控制会更加简洁，而且<strong>无偿地提供了防序列化（需要增加readResove方法）、反射破坏的机制</strong>，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。至于为什么可以这么玩，可以看《设计模式就该这样学：基于经典框架源码和真实业务场景》中的源码分析</p><h2 id="容器式单例"><a class="markdownIt-Anchor" href="#容器式单例"></a> 容器式单例</h2><blockquote><p>适用于需要大量创建单例对象的场景，便于管理，但它是非线程安全的。Spring中有用到容器式单例的写法。容器一般就是一个Map</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ContainerSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ioc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ioc.containsKey(className)) &#123;</span><br><span class="line">                Object obj = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj = Class.forName(className).newInstance();</span><br><span class="line">                    ioc.put(className, obj);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ioc.get(className)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式讲解"><a class="markdownIt-Anchor" href="#模式讲解"></a> 模式讲解：</h2><p>单例模式的范围为一个虚拟机的范围，因为加载类的载类的功能是虚拟机的，一个虚拟机在通过自己的ClassLoader 装载饿汉式实现单例类的时候就会创建一个类的实例。</p><p>▲所以需要注意的是，如果一个虚拟机里面有很多个ClassLoader，而且<u>这些ClassLoader都装载某个类的话(针对饿汉式)，就算这个类是单例，它也会产生很多个实例</u>。当然，如果一个机器上有多个虚拟机，那么每个虚拟机里面都应该至少有一个这个类的实例，也就是说整个机器。<strong>所以这边讨论的单例都不适用于集群环境。</strong></p><p>▲单例模式的本质：控制实例数目</p><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h2><blockquote><p>对于Java来说单例模式就是要保证在一个JVM中只存在单一实例</p></blockquote><ul><li>需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少GC</li><li>某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用</li><li>频繁访问数据库或文件的对象</li><li>对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则无法保证逻辑的统一性。</li></ul><p>p.s. 抽象工厂模式中具体的工厂类就是一个单例</p><h2 id="单例模式的优点"><a class="markdownIt-Anchor" href="#单例模式的优点"></a> 单例模式的优点：</h2><ol><li>可以保证内存中只有一个实例，减少了内存的开销</li><li>可以避免对资源的多重占用</li><li>设置全局访问点，可以优化和共享资源的访问</li></ol><h2 id="单例模式的缺点"><a class="markdownIt-Anchor" href="#单例模式的缺点"></a> 单例模式的缺点：</h2><ol><li>没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径， 违背了开闭原则。好在的是，一般修改单例也比较简单</li><li>在并发测试中，单例不利于代码调试。在调试过程总，如果单例代码没有执行完，也不能模拟生成一个恶心的对象</li><li>单例模式的功能代码通常写在一个类中，如果功能设计不合理，很容易违背单一职责原则</li></ol><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><h2 id="lazy-load-缓存思想"><a class="markdownIt-Anchor" href="#lazy-load-缓存思想"></a> Lazy load-&gt;缓存思想</h2><p>缓存使用场景：当某些资源或者数据被频繁地使用，而这些资源或数据存储在系统外部，比如数据库、硬盘文件等，那么每次操作这些数据的时候都得从数据库或者硬盘上去获取，速度会很慢，将造成性能问题。<br>一个简单的解决方法就是：把这些数据<strong>缓存到内存</strong>里面，每次操作的时候，先到内存里面找，看有没有这些数据，如果有，就直接使用，如果没有就获取它，并设置到缓存中，<u>下一次访问的时候就可以直接从内存中获取了</u>，从而节省大量的时间。当然，缓存是一种<strong>典型的空间换时间</strong>的方案。</p><h3 id="缓存基本实现"><a class="markdownIt-Anchor" href="#缓存基本实现"></a> 缓存基本实现</h3><p>在Java开发中最常见的一种实现缓存的方式就是使用<em>Map</em>，基本步骤如下。<br>（1）先到缓存里面查找，看看是否存在需要使用的数据。<br>（2）如果没有找到，那么就创建一个满足要求的数据，然后把这个数据设置到缓存中，以备下次使用。如果找到了相应的数据，或者是创建了相应的数据，那就直接使用这个数据。</p><h2 id="多例控制模式"><a class="markdownIt-Anchor" href="#多例控制模式"></a> 多例控制模式</h2><p>▲单例模式的本质：控制实例数目，只要按照这种思想，我们除了控制单例以外，还可以限制实例具体数目为2、3、4…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.dp.singleton.example9;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单演示如何扩展单例模式，控制实例数目为3个 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneExtend</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个缺省的key值的前缀</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEFAULT_PREKEY = <span class="string">"Cache"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存实例的容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,OneExtend&gt; map = <span class="keyword">new</span> HashMap&lt;String,OneExtend&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来记录当前正在使用第几个实例，到了控制的最大数目，就返回从1开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义控制实例的最大数目</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM_MAX = <span class="number">3</span>; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">OneExtend</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OneExtend <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">String key = DEFAULT_PREKEY+num;</span><br><span class="line">OneExtend oneExtend = map.get(key);</span><br><span class="line"><span class="keyword">if</span>(oneExtend==<span class="keyword">null</span>)&#123;</span><br><span class="line">oneExtend = <span class="keyword">new</span> OneExtend();</span><br><span class="line">map.put(key, oneExtend);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把当前实例的序号加1</span></span><br><span class="line">num++;</span><br><span class="line"><span class="keyword">if</span>(num &gt; NUM_MAX)&#123;</span><br><span class="line"><span class="comment">//如果实例的序号已经达到最大数目了，那就重复从1开始获取</span></span><br><span class="line">num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> oneExtend;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">OneExtend t1 = getInstance();</span><br><span class="line">OneExtend t2 = getInstance();</span><br><span class="line">OneExtend t3 = getInstance();</span><br><span class="line">OneExtend t4 = getInstance();</span><br><span class="line">OneExtend t5 = getInstance();</span><br><span class="line">OneExtend t6 = getInstance();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"t1=="</span>+t1);</span><br><span class="line">System.out.println(<span class="string">"t2=="</span>+t2);</span><br><span class="line">System.out.println(<span class="string">"t3=="</span>+t3);</span><br><span class="line">System.out.println(<span class="string">"t4=="</span>+t4);</span><br><span class="line">System.out.println(<span class="string">"t5=="</span>+t5);</span><br><span class="line">System.out.println(<span class="string">"t6=="</span>+t6);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然还没正式踏入开发就业浪潮中，但为了保证自己的代码质量，最近还是在学设计模式相关内容。以下为读《研磨设计模式》和《设计模式就该这样学：基于经典框架源码和真实业务场景》的读书笔记。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GoF的《设计模式》就是设计模式的始祖、经典教科书。
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>理解科学计算(numpy,pytorch)中的dim参数</title>
    <link href="https://nymrli.top/2020/12/05/%E7%90%86%E8%A7%A3%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84dim%E5%8F%82%E6%95%B0/"/>
    <id>https://nymrli.top/2020/12/05/理解科学计算中的dim参数/</id>
    <published>2020-12-05T03:53:10.000Z</published>
    <updated>2020-12-10T06:22:37.272Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>😄理解numpy中array和pytorch中tensor的操作是开始科学运算的第一步!</p></blockquote><p>首先明白维度的感念：</p><h2 id="维度"><a class="markdownIt-Anchor" href="#维度"></a> 维度</h2><p>我们通常能听到的都是2D, 3D，其实这边的D就是dimension的含义即维度。2D，我们通常理解为是平面，如我们最熟悉的直角坐标系就是平面坐标系，还有极坐标系。而3D呢，就是在平面的基础上增加了一维——高度，从而使平面的物体立起来了，同样3D也有耳熟能详的坐标系——3维坐标系。</p><p>更官方的解释呢：维度（Dimension），又称为<a href="https://baike.baidu.com/item/%E7%BB%B4%E6%95%B0/6496548" target="_blank" rel="noopener">维数</a>，是<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6/107037" target="_blank" rel="noopener">数学</a>中独立参数的<a href="https://baike.baidu.com/item/%E6%95%B0%E7%9B%AE/7720359" target="_blank" rel="noopener">数目</a>。在<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%AD%A6/313183" target="_blank" rel="noopener">物理学</a>和<a href="https://baike.baidu.com/item/%E5%93%B2%E5%AD%A6/140608" target="_blank" rel="noopener">哲学</a>的领域内，指独立的时空坐标的数目。0维是一个无限小的点，没有长度。<strong>1维是一条无限长的线，只有长度。2维是一个平面，是由长度和宽度(或部分曲线)组成面积。3维是2维加上高度组成体积。4维分为时间上和空间上的4维，人们说的4维通常是指关于物体在时间线上的转移。</strong>（4维准确来说有两种。1.四维时空，是指三维空间加一维时间。2.四维空间，只指四个维度的空间。）四维运动产生了五维。</p><p>从哲学角度看，人们观察、思考与表述某事物的“<u>思维角度</u>”，简称“维度”。例如，人们观察与思考“月亮”这个事物，可以从月亮的“内容、时间、空间”三个思维角度去描述；也可以从月亮的“载体、能量、信息”三个思维角度去描述。这边的维度其实也可以理解为角度，从不同的方面去看待、确定一个事物。</p><p>所以代数上来说，维度其实是数学里在<strong>表示</strong>方面的一个重要的概念，它反映的是一个空间的本质性质。</p><h2 id="科学计算中维度的概念"><a class="markdownIt-Anchor" href="#科学计算中维度的概念"></a> 科学计算中维度的概念</h2><h3 id="从二维点位置-编程中的坐标系"><a class="markdownIt-Anchor" href="#从二维点位置-编程中的坐标系"></a> 从二维点位置-&gt;编程中的坐标系</h3><p>维度的考量主要集中在矩阵的运算上。首先我们来看一个元素：4，其实它就是一个点，可以被认为是0维的。但往往我们不会只有一个元素。我们最常见的是编程中的数组，如[1,2,3,4]，这个是由多个元素构成的，它的维度就是一维的，这个我们也比较好理解。</p><p>而二维是什么呢？我们能直观理解的二维是平面坐标系的那种：(1,3), (4,5)…即给一个x，一个y，那么在平面中就可以在直角坐标系下确定这个点（物）。现在我们规整下这些坐标点[ (1, 3), (4, 5) ]，从这个角度上离我们的矩阵，或是数组好像还是有点远。那么我们继续变形。</p><p>如果我们需要画出坐标系中有哪些点的话， 1.第一种做法就是跟上述一样， 把点都存一个vector中[ (1, 3), (4, 5) ]，然后遍历，再在坐标系中点出。2.第二种呢，就是在坐标系中把所有的位置都列出来，如果有点存在就把它标出来，即跟我们列出迷宫地图一样，先把地图画出来，然后再把宝藏标出来。所以上述的两个点可以理解为。在给出了<code>map[20][20]</code>的地图上，(1, 3)和(4, 5)位置为true， 即<code>map[1][3] = 1</code>, <code>map[4][5] = 1</code>，其他位置<code>map[x][y] = 0</code>，所以这样我们就从[(1, 3), (4, 5)]==&gt; 用map形式表现出了这两个点，两者成功在<strong>二维</strong>上进行了转换。接下来我们就来分析这个二维的map。</p><p>数组，在编程中，我们都不陌生，如<code>int arr[50][50]</code>，虽然可以通过这个二维的数组，根据val的不同来表示三维的量，但是我们这边不把它这么理解，仅是当做<code>bool arr[50][50]</code>来理解维度上的概念。===&gt;同样，面对numpy中的array我们也是这么个理解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line">x = np.random.randint(<span class="number">2</span>, size = (<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line">y = torch.randint(<span class="number">2</span>, size = (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">print(y)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[[0 1 1]</span></span><br><span class="line"><span class="string"> [1 0 1]]</span></span><br><span class="line"><span class="string">tensor([[1, 0, 1],</span></span><br><span class="line"><span class="string">        [0, 0, 1]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>我们从numpy的x上理解，这边是创建了一个2*3的矩阵，其中<code>x[0][1], x[0][2], x[1][0], x[0][2]</code>全1，其余为0，输入<code>x.shape</code>得到的结果是(2, 3)，有两项，跟我们从map的理解上是一致的，这个地图map拥有长和宽两个维度。</p><p>然后我们从编程中观察这个2*3的矩阵或是叫数组，可以发现<code>x[a][b]</code>第一个<code>[]</code>中的内容a范围是从0-1的，第一个<code>[]</code>中的内容b范围是从0-2的，0的话学编程的人都能很快的理解，而第二个的范围却不太那么肯定。为什么呢？因为它跟我们普通认知的直角坐标系不一致。下面我们把x画出来(不改变输出显示的形式，而是让坐标系去适应这种表现形式)。</p><p><img src="/2020/12/05/理解科学计算中的dim参数/%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="坐标系"></p><p>为什么是这样画的呢？首先明确的原则是，不改变输出显示的形式，而是让坐标系去适应这种输出形式，因此输出长啥样，我们坐标系只能去适应。由于我们碰到有x，有y的时候，习惯上把第一个出现的当作x，第二个当作y，所以就有了第一个[]为x，第二个[]为y。</p><p>好了，现在我们确定好坐标系长什么样了。接下来就是具体理解dim的含义了</p><h3 id="编程中坐标系-科学计算中array的dim"><a class="markdownIt-Anchor" href="#编程中坐标系-科学计算中array的dim"></a> 编程中坐标系-&gt;科学计算中array的dim</h3><blockquote><p>想必大家在学习numpy或者torch的时候都被各种函数方法中的dim参数折磨过，感觉怎么理解都有问题，不敢自己使用。因此，这边就是解决，这些函数中的dim到底是怎么确定的</p></blockquote><p>比如我们创建一个高维的array</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A = torch.randint(<span class="number">2</span>, size = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([[[[0, 0, 1, 0],</span></span><br><span class="line"><span class="string">          [1, 1, 0, 1],</span></span><br><span class="line"><span class="string">          [0, 0, 0, 0]],</span></span><br><span class="line"><span class="string">         [[0, 0, 1, 1],</span></span><br><span class="line"><span class="string">          [1, 1, 1, 0],</span></span><br><span class="line"><span class="string">          [0, 1, 0, 0]]]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>举个我自己最初理解dim的笨方法：硬记x为第一维(dim = 0)， y为第二维(dim = 1)</p><p>实际上这种记法是比较低效的，最好的方法是我们怎么定义这个array就怎么记，比如我们这边创建的是一个size=(1, 2, 3, 4)，输出<code>len(A.shape)</code>为4，可以看到这就是个4维的tensor，那么我们顺理成章地就把把各个维度依次定义出来了。如dim = 0地指的就是size = 1的那层，dim = 1就是指size = 2的那层，依次类推。这样说可能有点抽象，因此我们回归简单的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">B = torch.randint(<span class="number">2</span>, size = (<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line">print(B)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([[1, 0],</span></span><br><span class="line"><span class="string">        [1, 1],</span></span><br><span class="line"><span class="string">        [0, 0]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>按照我们刚的定义，dim=0就是size=3的这一层，也就是我们坐标系中的X轴orX面。</p><p>好了，想必大家这个时候还不知道我在说什么。接下来就带大家来测试函数。</p><h4 id="测试dim在函数参数中的定义"><a class="markdownIt-Anchor" href="#测试dim在函数参数中的定义"></a> 测试dim在函数参数中的定义</h4><blockquote><p>提前指出把：要注意函数介绍中dim指的是&quot;<strong>沿着dim这个维度</strong>&quot;or&quot;<strong>删除、增加…dim这个维度(在dim这个维度上进行维度修改)</strong>&quot;</p></blockquote><h5 id="规约计算"><a class="markdownIt-Anchor" href="#规约计算"></a> 规约计算</h5><blockquote><p>一般是指分组聚合计算，表现结果就是会进行维度压缩</p></blockquote><h6 id="sum"><a class="markdownIt-Anchor" href="#sum"></a> sum</h6><blockquote><p>沿着dim累加元素</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C = torch.randint(<span class="number">5</span>, size = (<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line">print(C)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([[2, 3, 3, 4, 0],</span></span><br><span class="line"><span class="string">        [1, 0, 2, 4, 4]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">print(C.sum(dim = <span class="number">0</span>))</span><br><span class="line">print(C.sum(dim = <span class="number">1</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([3, 3, 5, 8, 4])</span></span><br><span class="line"><span class="string">tensor([12, 11])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>可以看到sum就是比较典型的&quot;沿着dim&quot;的例子，当dim = 0时就沿着dim = 0即x轴进行累加，由于sum这个函数会进行维度的压缩，所以最后的结果为<code>tensor([3, 3, 5, 8, 4])</code></p><h6 id="cumprod"><a class="markdownIt-Anchor" href="#cumprod"></a> cumprod</h6><blockquote><p>通过dim指定沿着某个维度计算累积</p><p>其他的函数还有cumsum、prod、sum，实际上两者是相同的，还有mean、median、var、std、min、max</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line">x = torch.Tensor([</span><br><span class="line">    [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">    [<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,]</span><br><span class="line">])</span><br><span class="line">print(torch.cumprod(x, dim = <span class="number">0</span>))</span><br><span class="line">print(torch.cumprod(x, dim = <span class="number">1</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([[ 2.,  3.,  4.,  5.,  6.],</span></span><br><span class="line"><span class="string">        [18., 24., 28., 30., 30.]])</span></span><br><span class="line"><span class="string">tensor([[2.0000e+00, 6.0000e+00, 2.4000e+01, 1.2000e+02, 7.2000e+02],</span></span><br><span class="line"><span class="string">        [9.0000e+00, 7.2000e+01, 5.0400e+02, 3.0240e+03, 1.5120e+04]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># min</span></span><br><span class="line">x = torch.Tensor([</span><br><span class="line">    [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">    [<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,]</span><br><span class="line">])</span><br><span class="line">print(torch.min(x, dim = <span class="number">0</span>))</span><br><span class="line">print(torch.min(x, dim = <span class="number">1</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">torch.return_types.min(</span></span><br><span class="line"><span class="string">    values=tensor([2., 3., 4., 5., 5.]),</span></span><br><span class="line"><span class="string">    indices=tensor([0, 0, 0, 0, 1]) )</span></span><br><span class="line"><span class="string">torch.return_types.min(</span></span><br><span class="line"><span class="string">    values=tensor([2., 5.]),</span></span><br><span class="line"><span class="string">    indices=tensor([0, 4]) )</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mean</span></span><br><span class="line">x = torch.Tensor([</span><br><span class="line">    [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">    [<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,]</span><br><span class="line">])</span><br><span class="line">print(torch.mean(x, dim = <span class="number">0</span>))</span><br><span class="line">print(torch.mean(x, dim = <span class="number">1</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([5.5000, 5.5000, 5.5000, 5.5000, 5.5000])</span></span><br><span class="line"><span class="string">tensor([4., 7.])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h5 id="索引-切片-连接"><a class="markdownIt-Anchor" href="#索引-切片-连接"></a> 索引、切片、连接</h5><h6 id="squeezeunsqueeze"><a class="markdownIt-Anchor" href="#squeezeunsqueeze"></a> squeeze，unsqueeze</h6><blockquote><p>unsqueeze关键字：参数dim指定在第几个维度增加&quot;[]&quot;，以提升维度</p><p>squeeze: unsqueeze的逆操作，删除dim指定的维度</p></blockquote><p>unsqueeze</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">D = torch.Tensor( [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] )</span><br><span class="line">y = D.unsqueeze(dim = <span class="number">0</span>)</span><br><span class="line">print(y, y.shape)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([[1., 2., 3., 4., 5.]]) torch.Size([1, 5])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">y = D.unsqueeze(dim = <span class="number">1</span>)</span><br><span class="line">print(y.shape)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([[1.],</span></span><br><span class="line"><span class="string">        [2.],</span></span><br><span class="line"><span class="string">        [3.],</span></span><br><span class="line"><span class="string">        [4.],</span></span><br><span class="line"><span class="string">        [5.]])  torch.Size([5, 1])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>可以看到的是dim = 0的时候就是在dim = 0 维度上增加了一维， 使得变成了[1, 5]。第二个是在dim=1的位置加了一维变成了[5, 1] （这也就是为什么很多书上会说其实就是在dim维度上加了1）</p><p>▲这个典型就是要区分： <strong>在dim维度上</strong> 和 <strong>沿着dim维度</strong>了</p><p>squeeze</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">F = torch.Tensor( [ [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], </span><br><span class="line">                    [<span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span> ,<span class="number">55</span>]</span><br><span class="line">                  ])</span><br><span class="line">y = torch.squeeze(F, dim = <span class="number">0</span>)</span><br><span class="line">print(y, y.shape)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([[ 0.,  2.,  3.,  4.],</span></span><br><span class="line"><span class="string">        [22., 33., 44., 55.]]) torch.Size([2, 4])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">y = torch.squeeze(F, dim = <span class="number">1</span>)</span><br><span class="line">print(y, y.shape)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([[ 0.,  2.,  3.,  4.],</span></span><br><span class="line"><span class="string">        [22., 33., 44., 55.]]) torch.Size([2, 4])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>这边变换不大的原因是因为dim上没有size=1可以删除</p><h6 id="split"><a class="markdownIt-Anchor" href="#split"></a> split</h6><blockquote><p><strong>按(沿着)dim维度</strong>将tensor分成n个部分</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">x = torch.Tensor([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>],</span><br><span class="line">    [<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">])</span><br><span class="line">print(x)</span><br><span class="line">print(torch.split(x, <span class="number">5</span>, dim = <span class="number">1</span>))</span><br><span class="line"><span class="comment"># 指定划分列表，表示依次有1,2,3,4个长度 (总和得跟dim维度上元素个数相同)</span></span><br><span class="line">print(torch.split(x, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], dim = <span class="number">1</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">tensor([[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.],</span></span><br><span class="line"><span class="string">        [10.,  9.,  8.,  7.,  6.,  5.,  4.,  3.,  2.,  1.]])</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">(tensor([# 可以看到这个是在x[:][6]的地方将tensor切成了两个</span></span><br><span class="line"><span class="string">[ 1.,  2.,  3.,  4.,  5.],</span></span><br><span class="line"><span class="string">        [10.,  9.,  8.,  7.,  6.]</span></span><br><span class="line"><span class="string">        ]), </span></span><br><span class="line"><span class="string">tensor([</span></span><br><span class="line"><span class="string">        [ 6.,  7.,  8.,  9., 10.],</span></span><br><span class="line"><span class="string">        [ 5.,  4.,  3.,  2.,  1.]</span></span><br><span class="line"><span class="string">        ]))</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">(tensor([[ 1.],</span></span><br><span class="line"><span class="string">        [10.]]), tensor([[2., 3.],</span></span><br><span class="line"><span class="string">        [9., 8.]]), tensor([[4., 5., 6.],</span></span><br><span class="line"><span class="string">        [7., 6., 5.]]), tensor([[ 7.,  8.,  9., 10.],</span></span><br><span class="line"><span class="string">        [ 4.,  3.,  2.,  1.]]))</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h6 id="unbind"><a class="markdownIt-Anchor" href="#unbind"></a> unbind</h6><blockquote><p>删除某个维度后，返回所有切片组成的<strong>元组</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">x = torch.rand(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># x = torch.rand(size=(1,2,3))</span></span><br><span class="line">print(x, x.shape)</span><br><span class="line">out = torch.unbind(x, dim = <span class="number">1</span>)</span><br><span class="line">print(out, len(out))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">            [0.3631, 0.6672, 0.9489],</span></span><br><span class="line"><span class="string">            [0.4944, 0.1606, 0.6122]</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">         ])torch.Size([1, 2, 3])</span></span><br><span class="line"><span class="string">         </span></span><br><span class="line"><span class="string">(</span></span><br><span class="line"><span class="string">    tensor([[0.3631, 0.6672, 0.9489]]), torch.Size([1, 3])</span></span><br><span class="line"><span class="string">    tensor([[0.4944, 0.1606, 0.6122]])torch.Size([1, 3])</span></span><br><span class="line"><span class="string">)      2</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">x = torch.Tensor([</span><br><span class="line">        [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,],</span><br><span class="line">        [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],</span><br><span class="line">        [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]],</span><br><span class="line">    </span><br><span class="line">        [[<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>],</span><br><span class="line">        [<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>],</span><br><span class="line">        [<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>]]</span><br><span class="line">])</span><br><span class="line">print(x, x.shape)</span><br><span class="line">out = torch.unbind(x, dim = <span class="number">1</span>)</span><br><span class="line">print(out, len(out))</span><br><span class="line">print(out[<span class="number">0</span>].shape)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([</span></span><br><span class="line"><span class="string">        [[1,2,3,4,],</span></span><br><span class="line"><span class="string">        [5,6,7,8],</span></span><br><span class="line"><span class="string">        [9,10,11,12]],</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">        [[13,14,15,16],</span></span><br><span class="line"><span class="string">        [17,18,19,20],</span></span><br><span class="line"><span class="string">        [21,22,23,24]]</span></span><br><span class="line"><span class="string">])        torch.Size([2, 3, 4])</span></span><br><span class="line"><span class="string">(tensor([</span></span><br><span class="line"><span class="string">[ 1.,  2.,  3.,  4.],</span></span><br><span class="line"><span class="string">        [13., 14., 15., 16.]]), </span></span><br><span class="line"><span class="string">tensor([</span></span><br><span class="line"><span class="string">[ 5.,  6.,  7.,  8.],</span></span><br><span class="line"><span class="string">        [17., 18., 19., 20.]]), </span></span><br><span class="line"><span class="string">tensor([</span></span><br><span class="line"><span class="string">[ 9., 10., 11., 12.],</span></span><br><span class="line"><span class="string">        [21., 22., 23., 24.]])) </span></span><br><span class="line"><span class="string">删除dim = 1, 把size[1] = 3的tensor拆成了3个tensor</span></span><br><span class="line"><span class="string">不要记这个： 因为dim0为z轴， dim1为x轴， dim2为y轴，所以删除dim1就是删除x轴，最后得到的就是yOz平面</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h6 id="cat-stack"><a class="markdownIt-Anchor" href="#cat-stack"></a> cat、stack</h6><blockquote><p>通过关键字dim指定按哪个维度拼接</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">x = torch.randint(<span class="number">1</span>, <span class="number">100</span>, size=(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">print(x)</span><br><span class="line">y = torch.randint(<span class="number">1</span>, <span class="number">100</span>, size=(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">print(y)</span><br><span class="line">res = torch.cat((x, y), dim = <span class="number">1</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">tensor([[71, 56, 44],</span></span><br><span class="line"><span class="string">        [64, 30, 87]])</span></span><br><span class="line"><span class="string">tensor([[39, 56, 63],</span></span><br><span class="line"><span class="string">        [68, 28, 65]])</span></span><br><span class="line"><span class="string">tensor([[71, 56, 44, 39, 56, 63],</span></span><br><span class="line"><span class="string">        [64, 30, 87, 68, 28, 65]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加强高维理解</span></span><br><span class="line">x = torch.randint(<span class="number">1</span>, <span class="number">100</span>, size=(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(x)</span><br><span class="line">y = torch.randint(<span class="number">1</span>, <span class="number">100</span>, size=(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(y)</span><br><span class="line">res = torch.cat((x, y), dim = <span class="number">1</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([[[81, 79, 10,  8],</span></span><br><span class="line"><span class="string">         [47, 30, 48, 35],</span></span><br><span class="line"><span class="string">         [10, 57, 68, 88]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[33, 51, 60, 97],</span></span><br><span class="line"><span class="string">         [27, 14, 83, 51],</span></span><br><span class="line"><span class="string">         [51, 54, 79, 65]]])</span></span><br><span class="line"><span class="string">tensor([[[85,  9, 95, 95],</span></span><br><span class="line"><span class="string">         [29, 99, 12,  8],</span></span><br><span class="line"><span class="string">         [32,  8,  3, 84]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[13, 24, 46, 20],</span></span><br><span class="line"><span class="string">         [86, 83, 72, 10],</span></span><br><span class="line"><span class="string">         [76, 33, 79, 48]]])</span></span><br><span class="line"><span class="string">tensor([[[81, 79, 10,  8],</span></span><br><span class="line"><span class="string">         [47, 30, 48, 35],</span></span><br><span class="line"><span class="string">         [10, 57, 68, 88],</span></span><br><span class="line"><span class="string">         [85,  9, 95, 95],</span></span><br><span class="line"><span class="string">         [29, 99, 12,  8],</span></span><br><span class="line"><span class="string">         [32,  8,  3, 84]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[33, 51, 60, 97],</span></span><br><span class="line"><span class="string">         [27, 14, 83, 51],</span></span><br><span class="line"><span class="string">         [51, 54, 79, 65],</span></span><br><span class="line"><span class="string">         [13, 24, 46, 20],</span></span><br><span class="line"><span class="string">         [86, 83, 72, 10],</span></span><br><span class="line"><span class="string">         [76, 33, 79, 48]]]) torch.Size([2, 6, 4])</span></span><br><span class="line"><span class="string">dim=1即沿元素为3的方向上延伸，所以结果变成了6</span></span><br><span class="line"><span class="string">不要记：也可以理解为沿x轴方向</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>官方文档： <a href="https://pytorch.org/docs/stable/generated/torch.cat.html?highlight=cat#torch.cat" target="_blank" rel="noopener">https://pytorch.org/docs/stable/generated/torch.cat.html?highlight=cat#torch.cat</a></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><h4 id="正确理解姿势"><a class="markdownIt-Anchor" href="#正确理解姿势"></a> 正确理解姿势</h4><p>dim是指tensor在shape上的顺序(可以这么理解)，如x的shape是２ｘ３ｘ４，也就是[2, 3, 4]。故可以这样一一对应来。<br>比如dim = 1就是按具有3个元素的那个轴操作，从而不用死记硬背那些dim = 0是对列操作还是对行操作了。</p><h4 id="强记三维"><a class="markdownIt-Anchor" href="#强记三维"></a> 强记三维</h4><p><img src="/2020/12/05/理解科学计算中的dim参数/3%E7%BB%B4.png" alt="3维"></p><p>但还是不提倡强记，因为一旦高维就理解不了了。</p><h2 id="附"><a class="markdownIt-Anchor" href="#附"></a> 附：</h2><h3 id="关于size的设置"><a class="markdownIt-Anchor" href="#关于size的设置"></a> 关于size的设置</h3><p>在ones、rand等函数上，size = (2,3,4)，我们在C++数组中<code>int arr[x][y][z]</code>的理解是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">2*3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>然后z为4， 但实际上在科学运算中size = (2,3,4)的矩阵是有4个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>∗</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">3*4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>的矩阵叠加而成，这边是要区分的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.randint(<span class="number">1</span>, <span class="number">100</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[[<span class="number">26</span>, <span class="number">36</span>, <span class="number">31</span>, <span class="number">21</span>],</span><br><span class="line">        [<span class="number">74</span>, <span class="number">59</span>, <span class="number">79</span>, <span class="number">32</span>],</span><br><span class="line">        [<span class="number">77</span>, <span class="number">94</span>, <span class="number">81</span>, <span class="number">32</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">72</span>, <span class="number">76</span>, <span class="number">85</span>, <span class="number">93</span>],</span><br><span class="line">        [<span class="number">66</span>, <span class="number">34</span>, <span class="number">80</span>, <span class="number">12</span>],</span><br><span class="line">        [<span class="number">99</span>, <span class="number">17</span>, <span class="number">98</span>, <span class="number">23</span>]]])</span><br><span class="line"></span><br><span class="line">x = torch.randint(<span class="number">1</span>, <span class="number">100</span>, size=(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(x)</span><br><span class="line">print(x[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>])<span class="comment"># 高度索引为1的, 在x = 2, y = 3的元素就是76</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([[[63, 54, 57, 17],</span></span><br><span class="line"><span class="string">         [78, 64, 76, 44],</span></span><br><span class="line"><span class="string">         [96,  3, 59, 37]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[86,  3, 92, 84],</span></span><br><span class="line"><span class="string">         [89, 36,  8, 79],</span></span><br><span class="line"><span class="string">         [10, 87, 15, 76]]])</span></span><br><span class="line"><span class="string">tensor(76)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">x = torch.randint(<span class="number">1</span>, <span class="number">100</span>, size=(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>))</span><br><span class="line">print(x)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([[[[29, 50],</span></span><br><span class="line"><span class="string">          [50, 69],</span></span><br><span class="line"><span class="string">          [95, 70],</span></span><br><span class="line"><span class="string">          [21, 35]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         [[58, 65],</span></span><br><span class="line"><span class="string">          [15, 53],</span></span><br><span class="line"><span class="string">          [96, 25],</span></span><br><span class="line"><span class="string">          [11, 75]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         [[12, 71],</span></span><br><span class="line"><span class="string">          [36, 12],</span></span><br><span class="line"><span class="string">          [71, 92],</span></span><br><span class="line"><span class="string">          [87, 47]]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[[43, 89],</span></span><br><span class="line"><span class="string">          [88, 22],</span></span><br><span class="line"><span class="string">          [61, 56],</span></span><br><span class="line"><span class="string">          [47, 97]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         [[71,  7],</span></span><br><span class="line"><span class="string">          [44, 88],</span></span><br><span class="line"><span class="string">          [54, 32],</span></span><br><span class="line"><span class="string">          [15, 65]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         [[96, 22],</span></span><br><span class="line"><span class="string">          [90, 78],</span></span><br><span class="line"><span class="string">          [30, 85],</span></span><br><span class="line"><span class="string">          [65, 57]]]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="关于如何看图"><a class="markdownIt-Anchor" href="#关于如何看图"></a> 关于如何看图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">res = np.uint8(np.random.rand(<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>) * <span class="number">255</span>)</span><br><span class="line">print(res)</span><br><span class="line">plt.imshow(res)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[[ 19 228 231]</span></span><br><span class="line"><span class="string">  [106  28 252]</span></span><br><span class="line"><span class="string">  [191  98 139]</span></span><br><span class="line"><span class="string">  [171  71 202]</span></span><br><span class="line"><span class="string">  [105 101  93]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> [[155 232 228]</span></span><br><span class="line"><span class="string">  [ 89 119  13]</span></span><br><span class="line"><span class="string">  [142 158 200]</span></span><br><span class="line"><span class="string">  [226 169  55]</span></span><br><span class="line"><span class="string">  [137 187 249]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> [[202 217  96]</span></span><br><span class="line"><span class="string">  [214  44 133]</span></span><br><span class="line"><span class="string">  [144 253 213]</span></span><br><span class="line"><span class="string">  [ 82   4  28]</span></span><br><span class="line"><span class="string">  [172 242 238]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> [[106 103  68]</span></span><br><span class="line"><span class="string">  [236 252  63]</span></span><br><span class="line"><span class="string">  [ 53  49  66]</span></span><br><span class="line"><span class="string">  [ 48 121  62]</span></span><br><span class="line"><span class="string">  [ 64  61 209]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> [[158  80 221]</span></span><br><span class="line"><span class="string">  [220  12 199]</span></span><br><span class="line"><span class="string">  [214  40   3]</span></span><br><span class="line"><span class="string">  [169 142 144]</span></span><br><span class="line"><span class="string">  [140 112 148]]]</span></span><br><span class="line"><span class="string">  """</span></span><br></pre></td></tr></table></figure><p>画图效果如下：</p><p><img src="/2020/12/05/理解科学计算中的dim参数/%E5%9B%BE.png" alt="图"></p><p>可以得到的结果是针对<code>np.random.rand(5,5,3)</code>来说，三个通道被列成了三列，因此每一列就是一个通道。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">res = np.uint8(np.random.rand(<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>) * <span class="number">255</span>)</span><br><span class="line">[[[ <span class="number">19</span> <span class="number">228</span> <span class="number">231</span>]</span><br><span class="line">  [<span class="number">106</span>  <span class="number">28</span> <span class="number">252</span>]</span><br><span class="line">  [<span class="number">191</span>  <span class="number">98</span> <span class="number">139</span>]</span><br><span class="line">  [<span class="number">171</span>  <span class="number">71</span> <span class="number">202</span>]</span><br><span class="line">  [<span class="number">105</span> <span class="number">101</span>  <span class="number">93</span>]]</span><br><span class="line">  </span><br><span class="line">res = np.uint8(np.random.rand(<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>) * <span class="number">255</span>)</span><br><span class="line">[[[<span class="number">217</span> <span class="number">210</span> <span class="number">138</span>]</span><br><span class="line">  [  <span class="number">1</span> <span class="number">148</span>  <span class="number">10</span>]</span><br><span class="line">  [ <span class="number">25</span> <span class="number">231</span> <span class="number">128</span>]</span><br><span class="line">  [<span class="number">158</span> <span class="number">216</span>  <span class="number">73</span>]</span><br><span class="line">  [<span class="number">220</span> <span class="number">208</span> <span class="number">165</span>]</span><br><span class="line">  [ <span class="number">73</span> <span class="number">119</span> <span class="number">122</span>]]</span><br><span class="line"><span class="comment"># 单元中竖着的行数表示了图片的长，可以看到横着的长是6</span></span><br><span class="line"><span class="comment"># 而有多少个单元就以为着图片的宽， 可以看到竖着的宽是5==&gt; 所以第几个单元意味着第几行</span></span><br><span class="line"><span class="comment"># 所以[0][5][0]=73标志着右上角那一块绿色的第一个通道的值</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可以设置后再绘图看看是不是右上角的图块变成白色的了</span></span><br><span class="line">res[<span class="number">0</span>][<span class="number">5</span>][<span class="number">0</span>] = res[<span class="number">0</span>][<span class="number">5</span>][<span class="number">1</span>] = res[<span class="number">0</span>][<span class="number">5</span>][<span class="number">2</span>] = <span class="number">255</span></span><br><span class="line">print(res[<span class="number">0</span>][<span class="number">5</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>总结： RGB图像的shape：(H, W, C)</p><h3 id="pytorchapi"><a class="markdownIt-Anchor" href="#pytorchapi"></a> pytorchAPI:</h3><p><a href="https://pytorch.org/docs/stable/torch.html#torch.arange" target="_blank" rel="noopener">https://pytorch.org/docs/stable/torch.html#torch.arange</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;😄理解numpy中array和pytorch中tensor的操作是开始科学运算的第一步!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先明白维度的感念：&lt;/p&gt;
&lt;h2 id=&quot;维度&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="ML" scheme="https://nymrli.top/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>Lets learn 设计模式</title>
    <link href="https://nymrli.top/2020/12/03/Lets-learn-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://nymrli.top/2020/12/03/Lets-learn-设计模式/</id>
    <published>2020-12-03T03:36:53.000Z</published>
    <updated>2020-12-11T12:59:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《研磨设计模式》和《设计模式就该这样学：基于经典框架源码和真实业务场景》的读书笔记</p></blockquote><h2 id="设计模式是什么"><a class="markdownIt-Anchor" href="#设计模式是什么"></a> 设计模式是什么？</h2><p>模式：从字面上理解，模，就是<u>模型、模板</u>的意思；式，就是方式、方法的意思。综合起来，所谓模式就是：可以作为模型或模板的方式或方法。再简单点说就是可以用来作为样板的方式或方法，类似于大家所熟悉的范例。</p><p>所以设计模式就是设计方面的模板，具体定义为：是指在软件开发中，<strong>经过验证的</strong>，用于解决在<strong>特定环境</strong>下、<strong>重复出现</strong>的、特定问题的<strong>解决方案</strong>。</p><h3 id="每个设计模式的构成如下"><a class="markdownIt-Anchor" href="#每个设计模式的构成如下"></a> 每个设计模式的构成如下：</h3><p>1、模式名称：模式的一个好记的名字</p><p>2、环境和问题：描述在什么环境下，出现什么特定的问题</p><p>3、解决方案：描述如何解决问题</p><p>4、效果：描述应用模式后的效果，以及可能带来的问题</p><h2 id="设计模式分类"><a class="markdownIt-Anchor" href="#设计模式分类"></a> 设计模式分类：</h2><p>为了缩小范围，我们仅讨论Java设计模式，也就是GoF著作中的23种设计模式，对于这23种设计模式，GoF把它们分为三类。</p><ul><li>创建型模式：抽象了对象实例化过程，用来帮助创建对象的实例。<ul><li>简单工厂模式</li><li>单例模式</li><li>工厂方法模式</li><li>抽象工厂模式</li><li>生成器模式</li><li>原型模式</li></ul></li><li>结构型模式：描述如何组合类和对象以获得更大的结构。<ul><li>外观模式</li><li>适配器模式</li><li>代理模式</li><li>组合模式</li><li>享元模式</li><li>装饰模式</li><li>桥接模式</li></ul></li><li>行为型模式：描述算法和对象间职责的分配。<ul><li>中介模式</li><li>观察者模式</li><li>命令模式</li><li>迭代器模式</li><li>模板模式</li><li>策略模式</li><li>状态模式</li><li>备忘录模式</li><li>解释器模式</li><li>责任链模式</li><li>访问者模式</li></ul></li></ul><p>《<strong>设计模式就该这样学：基于经典框架源码和真实业务场景</strong>》中提到了新的设计模式：</p><ul><li>对象池模式</li><li>规格模式</li><li>空对象模式</li><li>雇工模式</li></ul><h2 id="java中的面向接口编程"><a class="markdownIt-Anchor" href="#java中的面向接口编程"></a> JAVA中的面向接口编程</h2><h3 id="1java中接口的概念"><a class="markdownIt-Anchor" href="#1java中接口的概念"></a> 1.Java中接口的概念</h3><p>在Java中接口是一种特殊的抽象类，跟一般的抽象类相比，接口里面的所有方法都是抽象方法，接口里面的所有属性都是常量。也就是说，接口里面只有方法定义而没有任何方法实现。</p><h3 id="2接口用来干什么"><a class="markdownIt-Anchor" href="#2接口用来干什么"></a> 2.接口用来干什么</h3><p>通常用接口来定义实现类的外观，也就是实现类的行为定义，用来约束实现类的行为。接口就相当于一份契约，根据外部应用需要的功能，约定了实现类应该要实现的功能，但是具体的实现类除了实现接口约定的功能外，还可以根据需要实现其他一些功能，这是允许的，也就是说实现类的功能包含但不仅限于接口约束的功能。<br>通过使用接口，可以实现不相关类的相同行为，而不需考虑这些类之间的层次关系，接口就是实现类对外的外观。</p><h3 id="3接口的思想"><a class="markdownIt-Anchor" href="#3接口的思想"></a> 3.接口的思想</h3><p>根据接口的作用和用途，浓缩下来，<strong>接口的思想就是“封装隔离”</strong>。<br>通常提到的封装是指对数据的封装，但是这里的封装是指“对被隔离体的行为的封装”，或者是“对被隔离体的职责的封装”；而隔离指的是外部调用和内部实现，外部调用只能通过接口进行调用，外部调用是不知道内部具体实现的，也就是说外部调用和内部实现是被接口隔离开的。</p><h3 id="4使用接口的好处"><a class="markdownIt-Anchor" href="#4使用接口的好处"></a> 4.使用接口的好处</h3><p>由于外部调用和内部实现被接口隔离开了，那么只要接口不变，内部实现的变化就不会影响到外部应用，从而使得系统更灵活，具有更好的扩展性和可维护性，这也就是所谓“接口是系统可插拔性的保证”这句话的意思。</p><h3 id="5接口和抽象类的选择"><a class="markdownIt-Anchor" href="#5接口和抽象类的选择"></a> 5.接口和抽象类的选择</h3><p>既然接口是一种特殊的抽象类，那么在开发中，何时选用接口？何时选用抽象类呢？<br>对于它们的选择，在开发中是一个很重要的问题，特别总结两句话给大家：</p><ul><li>优先选用接口</li><li>在既要定义子类的行为，又要为子类提供公共的功能时应选择抽象类。</li></ul><h2 id="设计原则"><a class="markdownIt-Anchor" href="#设计原则"></a> 设计原则</h2><blockquote><p>面向对象的分析设计有很多原则，这些原则大多从<u>思想层面</u>给我们指出了面向对象分析设计的正确<u>方向</u>，是我们进行面向对象分析设计时应该尽力遵守的<u>准则</u>。而设计模式已经是针对某个场景下某些问题的某个解决方案。也就是说这些设计原则是思想上的指导，而<u>设计模式</u>是<u>实现上的手段</u>，因此设计模式也应该遵守这些原则，换句话说，设计模式就是这些设计原则的一些具体体现。</p></blockquote><h3 id="常见的面向对象设计原则solid原则"><a class="markdownIt-Anchor" href="#常见的面向对象设计原则solid原则"></a> 常见的面向对象设计原则——SOLID原则</h3><h4 id="单一职责原则srpsingle-responsibility-principle"><a class="markdownIt-Anchor" href="#单一职责原则srpsingle-responsibility-principle"></a> 单一职责原则SRP（Single Responsibility Principle）</h4><p>所谓单一职责原则，指的是，一个类应该仅有一个引起它变化的原因。总体来说就是一个class、interface、method只负责一项职责。<br>这里变化的原因就是所说的“职责”，如果一个类有多个引起它变化的原因，那么也就意味着这个类有多个职责，再进一步说，就是把多个职责耦合在一起了。<br>这会造成职责的相互影响，可能一个职责的变化，会影响到其他职责的实现，甚至引起其他职责随着变化，这种设计是很脆弱的。<br>这个原则看起来是最简单和最好理解的，但是实际上是很难完全做到的，难点在于如何区分“职责”。这是个没有标准量化的东西，哪些算职责、到底这个职责有多大的粒度、这个职责如何细化等。<em>因此，在实际开发中，这个原则也是最容易违反的</em>。</p><p><strong>▲一句话总结</strong>：一个类只干一件事，从而便于立即额，提高代码可读性</p><h4 id="开放-关闭原则ocpopen-closed-principle"><a class="markdownIt-Anchor" href="#开放-关闭原则ocpopen-closed-principle"></a> 开放-关闭原则OCP（Open-Closed Principle）</h4><blockquote><p>所谓开放-关闭原则，指的是，一个类应该对扩展开放，对修改关闭。一般也被简称为开闭原则，开闭原则是设计中非常核心的一个原则。</p><p>OCP的核心思想是面对抽象编程，强调用抽象构建框架，用实现拓展细节，从而额提高软件系统的可复用性和可维护性。</p></blockquote><p>开闭原则要求的是，类的行为是可以扩展的，而且是在不修改已有代码的情况下进行扩展，也不必改动已有的源代码或者二进制代码。<br>看起来好像是矛盾的，怎么样才能实现呢？<br>实现开闭原则的关键就在于合理地抽象、分离出变化与不变化的部分，为<u>变化的部分预留下可扩展的方式</u>，比如，<u>钩子方法或是动态组合对象</u>等。</p><p>这个原则看起来也很简单。但事实上，一个系统要全部做到遵守开闭原则，几乎是不可能的，也没这个必要。适度的抽象可以提高系统的灵活性，使其可扩展、可维护，但是过度地抽象，会大大增加系统的复杂程度。应该在需要改变的地方应用开闭原则就可以了，而不用到处使用，从而陷入过度设计。</p><p><strong>▲一句话总结</strong>：对扩展开放，对修改关闭，从而降低维护带来的新风险</p><h4 id="里氏替换原则lspliskov-substitution-principle"><a class="markdownIt-Anchor" href="#里氏替换原则lspliskov-substitution-principle"></a> 里氏替换原则LSP（Liskov Substitution Principle）</h4><p>所谓里氏替换原则，指的是，子类型<strong>必须能够</strong>替换掉它们的父类型。这很明显是一种多态的使用情况，它可以避免在多态的应用中，出现某些隐蔽的错误。</p><blockquote><p>这条原则的定义是比较抽象的，可以理解为</p><ol><li>一个软件实体如果使用一个父类，则一定适用于其子类，即要求所有引用父类的地方必须能透明地使用子类对象，子类能够代替父类对象，而程序逻辑不变。</li><li>子类可以拓展父类的功能，但不能改变父类原有的功能，根据这个理解，我们可以将DIP定义总结如下：<ol><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li><li>子类可以增加自己特有的方法</li><li>当子类的方法重载父类的方法时，方法的前置条件（入参）要比父类的更宽松</li><li>当子类的方法实现父类的方法时（重写、重载或实现抽象方法），方法的后置条件（输出、返回值）要比父类的更严格或相等</li></ol></li></ol></blockquote><p><strong>▲一句话总结</strong>：子类重写方法功能改变，不应该影响父类方法的含义，从而防止继承泛滥</p><h4 id="依赖倒置原则dipdependence-inversion-principle"><a class="markdownIt-Anchor" href="#依赖倒置原则dipdependence-inversion-principle"></a> 依赖倒置原则DIP（Dependence Inversion Principle）</h4><p>所谓依赖倒置原则，指的是，要依赖于抽象，不要依赖于具体类。要做到依赖倒置，典型的应该做到：</p><ul><li>高层模块不应该依赖于底层模块，二者都应该依赖于抽象。</li><li>抽象不应该依赖于具体实现，具体实现应该依赖于抽象。</li></ul><p>很多人觉得，层次化调用的时候，应该是高层调用“底层所拥有的接口”，这是一种典型的误解。事实上，一般高层模块包含对业务功能的处理和业务策略选择，应该被重用，是高层模块去影响底层的具体实现。<br>因此，这个底层的接口应该是由高层提出的，然后由底层实现的。也就是说底层的接口的所有权在高层模块，因此是一种所有权的倒置。<br>倒置接口所有权，这就是著名的Hollywood（好莱坞）原则：不要找我们，我们会联系你。</p><p><strong>一句话总结</strong>：高层不应该依赖底层，从而更利用代码结构的省级扩展</p><h4 id="接口隔离原则ispinterface-segregation-principle"><a class="markdownIt-Anchor" href="#接口隔离原则ispinterface-segregation-principle"></a> 接口隔离原则ISP（Interface Segregation Principle）</h4><blockquote><p>指用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口（不需要的接口对客户来说不可见）。</p><p>这个原则告诉我们的注意点为：</p><ul><li>一个雷对另一个类的依赖应该建立在最小接口上</li><li>建立单一接口，不要建立庞大臃肿的接口</li><li>尽量细化接口，接口中的方法越少越好（适量少）</li></ul><p>这些“高聚合、低耦合”要求的设计思想，使得类具有很好的可读性、可扩展性和可维护性。</p></blockquote><p>所谓接口隔离原则，指的是，不应该强迫客户依赖于他们不用的方法。<br>这个原则用来处理那些比较“庞大”的接口，这种接口通常会有较多的操作声明，涉及到很多的职责。客户在使用这样的接口的时候，通常会有很多他不需要的方法，这些方法对于客户来讲，就是一种接口污染，相当于强迫用户在一大堆“垃圾方法”中去寻找他需要的方法。<br>因此，这样的接口应该被分离，应该按照不同的客户需要来分离成为针对客户的接口。<u>这样的接口中，只包含客户需要的操作声明</u>，这样既方便了客户的使用，也可以避免因误用接口而导致的错误。</p><p>分离接口的方式，除了直接进行代码分离之外，还可以使用委托来分离接口，在能够支持多重继承的语言中，还可以采用多重继承的方式进行分离。</p><p><strong>▲一句话总结</strong>：一个接口只干一件事，从而功能解耦，高聚合、低耦合</p><hr><p>demo：针对动物Animal接口，显然需要将飞的、游的隔离开，因此需要针对不同动物的行为来设计不同的接口。</p><p><img src="/2020/12/03/Lets-learn-设计模式/ISP.jpg" alt="ISP"></p><h3 id="其他一些设计原则"><a class="markdownIt-Anchor" href="#其他一些设计原则"></a> 其他一些设计原则</h3><h4 id="最少知道原则lkpleast-knowledge-principle迪米特原则lod"><a class="markdownIt-Anchor" href="#最少知道原则lkpleast-knowledge-principle迪米特原则lod"></a> 最少知道原则LKP（Least Knowledge Principle）——迪米特原则LoD</h4><blockquote><p>指一个对象应该对其他对象保持最少的了解，尽量降低类与类之间的耦合。强调之和朋友交流、不和陌生人说话，出现在成员变量、方法的输入、输出参数中的类可以被称为成员朋友类，出现在方法体内部的类不属于朋友类。</p></blockquote><p>这个原则用来指导我们在设计系统的时候，应该尽量减少对象之间的交互，对象只和自己的朋友谈话，<u>也就是只和自己的朋友交互</u>，从而松散类之间的耦合。通过松散类之间的耦合来降低类之间的相互依赖，这样在修改系统的某一个部分的时候，就不会影响其他的部分，从而使得系统具有更好的可维护性。</p><p>那么究竟哪些对象才能被当作朋友呢？最少知识原则提供了一些指导。</p><ul><li>当前对象本身。</li><li>通过方法的参数传递进来的对象。</li><li>当前对象所创建的对象。——成员变量</li><li>当前对象的实例变量所引用的对象。——成员变量</li><li>方法内所创建或实例化的对象。 —&gt; ???</li></ul><p>请注意！！！1-5条的意思是，<mark>如果某对象是调用其他方法的返回结果，不要调用该对象的方法！</mark>即要求我们只调用以下范围的方法：</p><p>（1）该对象本身；<br>（2）被当作方法的<strong>参数</strong>而传递进来的对象；<br>（3）此方法所<strong>创建或实例化</strong>的任何对象；<br>（4）对象的任何组件；</p><p>总之，最少知识原则要求我们的方法调用必须保持在一定的界限范围之内，尽量减少对象的依赖关系。</p><p><strong>▲一句话总结</strong>：不该知道的不要知道，从而减少代码臃肿</p><h4 id="合成复用原则"><a class="markdownIt-Anchor" href="#合成复用原则"></a> 合成复用原则</h4><blockquote><p>尽量使用对象组合或对象聚合的方式来实现代码复用，而不是继承关系达到代码复用的目的。</p></blockquote><p><strong>▲一句话总结</strong>：尽量使用组合实现代码复用而不是用继承，从而降低代码耦合</p><p>除了上面提到的这些原则，还有一些大家都熟知的原则，比如：</p><ul><li>面向接口编程；</li><li>优先使用组合，而非继承。</li></ul><p>当然也还有很多大家不是很熟悉的原则，比如：</p><ul><li>一个类需要的数据应该隐藏在类的内部；</li><li>类之间应该零耦合，或者只有传导耦合，换句话说，类之间要么没有关系，要么只使用另一个类的接口提供的操作；</li><li>在水平方向上尽可能统一地分布系统功能；</li></ul><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><p>Github图说设计模式: <a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html" target="_blank" rel="noopener">https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html</a></p><p><a href="http://www.cnblogs.com/zishengY/p/8869823.html" target="_blank" rel="noopener">设计模式就该这么学：以微信订阅号来讲观察者模式(第三篇)</a></p><p><a href="http://www.cnblogs.com/zishengY/p/7056948.html" target="_blank" rel="noopener">观察者模式实际应用：监听线程，意外退出线程后自动重启</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;《研磨设计模式》和《设计模式就该这样学：基于经典框架源码和真实业务场景》的读书笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;设计模式是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#设计模式是什么&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>玩玩油猴脚本Tampermonkey</title>
    <link href="https://nymrli.top/2020/12/01/%E7%8E%A9%E7%8E%A9%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/"/>
    <id>https://nymrli.top/2020/12/01/玩玩油猴脚本/</id>
    <published>2020-12-01T07:32:53.000Z</published>
    <updated>2020-12-01T12:19:48.468Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于在研究如何优化网盘直链下载助手**<a href="https://github.com/ziyuanshu/baidupan" target="_blank" rel="noopener">baidupan</a><strong>，如何将直链的结果提取出来供IDM批量下载。由于</strong><a href="https://github.com/ziyuanshu/baidupan" target="_blank" rel="noopener">baidupan</a>**是用油猴脚本写的，因此借机学习一下。</p></blockquote><blockquote></blockquote><h2 id="greasy-fork"><a class="markdownIt-Anchor" href="#greasy-fork"></a> <a href="https://greasyfork.org/zh-CN/" target="_blank" rel="noopener">Greasy Fork</a></h2><blockquote><p>这里是一个提供用户脚本的网站。</p></blockquote><h2 id="tampermonkey"><a class="markdownIt-Anchor" href="#tampermonkey"></a> <a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">Tampermonkey</a></h2><blockquote><p>其为浏览器插件，目前主流浏览器皆支持，油猴叫法来源：「油猴」是从「Greasemonkey」来的。「Greasemonkey」最初是运行在Firefox浏览器中的脚本，「Tampermonkey」在Google Chrome浏览器上实现了几乎相同的功能，所以也被中文用户称之为「油猴」。</p></blockquote><h3 id="新建"><a class="markdownIt-Anchor" href="#新建"></a> 新建：</h3><p><img src="/2020/12/01/玩玩油猴脚本/E:%5Chexo%5Csource_posts%5C%E7%8E%A9%E7%8E%A9%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%5C%E6%96%B0%E5%BB%BA.jpg" alt="新建"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         New Userscript</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  try to take over the world!</span></span><br><span class="line"><span class="comment">// @author       You</span></span><br><span class="line"><span class="comment">// @match        https://www.1949la.com/post/10351.html</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Your code here...</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><h3 id="脚本编写方法"><a class="markdownIt-Anchor" href="#脚本编写方法"></a> 脚本编写方法</h3><h4 id="注释功能注释"><a class="markdownIt-Anchor" href="#注释功能注释"></a> 注释——功能注释</h4><p>首先来看看脚本的内容，上面是一大排注释，这些注释可以非常有用的，它表明了脚本的各个属性。下面来简单介绍一下。</p><table><thead><tr><th>属性名</th><th>作用</th></tr></thead><tbody><tr><td>name</td><td>油猴脚本的名字</td></tr><tr><td>namespace</td><td>命名空间，类似于Java的包名，用来区分相同名称的脚本，一般写成作者名字或者网址就可以了</td></tr><tr><td>version</td><td>脚本版本，油猴脚本的更新会读取这个版本号</td></tr><tr><td>description</td><td>描述，用来告诉用户这个脚本是干什么用的</td></tr><tr><td>author</td><td>作者名字</td></tr><tr><td>match</td><td>只有匹配的网址才会执行对应的脚本，例如<code>*</code>、<code>http://*</code>、<code>http://www.baidu.com/*</code>等，参见<a href="https://developer.chrome.com/extensions/match_patterns" target="_blank" rel="noopener">谷歌开发者文档</a></td></tr><tr><td>grant</td><td><strong>指定脚本运行所需权限</strong>，如果脚本拥有相应的权限，就可以调用油猴扩展提供的API与浏览器进行交互。如果设置为<code>none</code>的话，则不使用沙箱环境，脚本会直接运行在网页的环境中，这时候无法使用大部分油猴扩展的API。如果不指定的话，油猴会默认添加几个最常用的API</td></tr><tr><td>require</td><td>如果脚本依赖其他js库的话，可以使用require指令，在运行脚本之前先加载其他库，常见用法是加载jquery</td></tr><tr><td>connect</td><td>当用户使用<a href="https://www.tampermonkey.net/documentation.php?version=4.9&amp;ext=dhdg&amp;show=dhdg#GM_xmlhttpRequest" target="_blank" rel="noopener">GM_xmlhttpRequest</a>请求远程数据的时候，需要使用connect指定允许访问的域名，支持域名、子域名、IP地址以及<code>*</code>通配符</td></tr><tr><td>updateURL</td><td>脚本更新网址，当油猴扩展检查更新的时候，会尝试从这个网址下载脚本，然后比对版本号确认是否更新</td></tr></tbody></table><p>grant中几个常用的权限：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @grant GM_setValue</span></span><br><span class="line"><span class="comment">// @grant GM_getValue</span></span><br><span class="line"><span class="comment">// @grant GM_setClipboard</span></span><br></pre></td></tr></table></figure><p>注意， match写法由于支持通配符，可以写的通用些:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @match        *://10.10.244.11/a70.htm*</span></span><br><span class="line"><span class="comment">// @match        *://p.njupt.edu.cn/a70.htm*</span></span><br></pre></td></tr></table></figure><h4 id="脚本权限"><a class="markdownIt-Anchor" href="#脚本权限"></a> 脚本权限</h4><p>下面简单介绍一下grant指令那里可以填写的一些权限，详情请查看<a href="https://www.tampermonkey.net/documentation.php" target="_blank" rel="noopener">油猴脚本文档</a>。这里就简单介绍几个常用的，可以调用的函数全部以GM_作为开头。</p><table><thead><tr><th>权限名</th><th>功能</th></tr></thead><tbody><tr><td>unsafeWindow</td><td>允许脚本可以完整访问原始页面，包括原始页面的脚本和变量。</td></tr><tr><td>GM_getValue(name,defaultValue)</td><td>从油猴扩展的存储中访问数据。可以设置默认值，在没成功获取到数据的时候当做初始值。如果保存的是日期等类型的话，取出来的数据会变成文本，需要自己转换一下。</td></tr><tr><td>GM_setValue(name,value)</td><td>将数据保存到存储中</td></tr><tr><td>GM_xmlhttpRequest(details)</td><td><strong>异步访问网页数据</strong>的API，这个方法比较复杂，有大量参数和回调，详情请参考官方文档。</td></tr><tr><td>GM_setClipboard(data, info)</td><td>将数据复制到剪贴板中，第一个参数是要复制的数据，第二个参数是MIME类型，用于指定复制的数据类型。</td></tr><tr><td>GM_log(message)</td><td>将日志打印到控制台中，可以使用F12开发者工具查看。</td></tr><tr><td>GM_addStyle(css)</td><td>像网页中添加自己的样式表。</td></tr><tr><td>GM_notification(details, ondone), GM_notification(text, title, image, onclick)</td><td>设置网页通知，请参考文档获取用法。</td></tr><tr><td>GM_openInTab(url, loadInBackground)</td><td>在浏览器中打开网页，可以设置是否在后台打开等几个选项</td></tr></tbody></table><p>还有一些API没有介绍，请大家直接查看官方文档吧。</p><h5 id="gm_xmlhttprequest-demo"><a class="markdownIt-Anchor" href="#gm_xmlhttprequest-demo"></a> GM_xmlhttpRequest DEMO：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GM_xmlhttpRequest(&#123;</span><br><span class="line">    method: <span class="string">"POST"</span>,</span><br><span class="line">    url: url,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">"Content-Type"</span>: <span class="string">"application/x-www-form-urlencoded;charset=utf-8"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    data: form_data,</span><br><span class="line">    onload: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"请求成功"</span>);</span><br><span class="line">        <span class="keyword">let</span> success = <span class="string">"认证成功页"</span>;</span><br><span class="line">        <span class="keyword">let</span> resp = response.responseText;</span><br><span class="line">        <span class="keyword">let</span> flag = resp.indexOf(success);</span><br><span class="line">        <span class="keyword">if</span> (flag === <span class="number">-1</span>) &#123;</span><br><span class="line">            do_login_old(username, password);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//alert("登录成功");</span></span><br><span class="line">            <span class="built_in">window</span>.location.href = <span class="string">"https://cn.bing.com/"</span>; <span class="comment">//避免重复登录导致瞬间三个设备同时登录的状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    onerror: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        do_login_old(username, password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="mycode"><a class="markdownIt-Anchor" href="#mycode"></a> MyCode</h4><blockquote><p>我的第一个脚本，简简单单打开自己的个人博客吧，修改如下</p><ul><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="comment">// @match        https://www.baidu.com</span></span><br><span class="line">&gt;   <span class="comment">// @grant GM_openInTab</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;       <span class="keyword">const</span> URL = <span class="string">"https://nymrli.top"</span>;</span><br><span class="line">&gt;       GM_openInTab(URL, <span class="literal">true</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>访问百度的时候就会在当前session中打开我的个人博客了，(URL, true)不会切换到URL上</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         New Userscript</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  try to take over the world!</span></span><br><span class="line"><span class="comment">// @author       Mrli</span></span><br><span class="line"><span class="comment">// @match        https://www.baidu.com</span></span><br><span class="line"><span class="comment">// @grant GM_openInTab</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="keyword">const</span> URL = <span class="string">"https://nymrli.top"</span>;</span><br><span class="line">    GM_openInTab(URL, <span class="literal">true</span>);<span class="comment">// 打开URL后当前tab不变; false会切换当前tab为URL页面</span></span><br><span class="line">    <span class="comment">//     GM_openInTab(URL, &#123;incognito :true &#125;);   options中貌似有有限级, 加了incognito后,insert会失效</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Your code here...</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h5 id="bilibili倍速"><a class="markdownIt-Anchor" href="#bilibili倍速"></a> Bilibili倍速</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         BilibiliFast</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  try to take over the world!</span></span><br><span class="line"><span class="comment">// @author       You</span></span><br><span class="line"><span class="comment">// @match        https://www.bilibili.com/video/*</span></span><br><span class="line"><span class="comment">// @require      https://code.jquery.com/jquery-2.1.4.min.js</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="comment">// Your code here...</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"导入成功"</span>);</span><br><span class="line">    $(<span class="string">"body"</span>).append(<span class="string">`&lt;div id='video_set' style="position:fixed; right:10px; top:10px; z-index:9999; background:red"&gt;</span></span><br><span class="line"><span class="string">             &lt;input id="setPlay" value=1 type="number" style="padding:10px;"&gt;</span></span><br><span class="line"><span class="string">       &lt;/div&gt;`</span></span><br><span class="line">       );</span><br><span class="line">    <span class="comment">// $(document).append()会报错Cannot read property 'createDocumentFragment' of undefined</span></span><br><span class="line"></span><br><span class="line">    $(<span class="built_in">document</span>).on(<span class="string">"change"</span>, <span class="string">"#video_set #setPlay"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.value &lt;= <span class="number">16</span>)&#123;</span><br><span class="line">                <span class="built_in">document</span>.querySelector(<span class="string">'video'</span>).playbackRate=<span class="keyword">this</span>.value;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                alert(<span class="string">"最大为16"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="学习baidupan源码"><a class="markdownIt-Anchor" href="#学习baidupan源码"></a> <strong>学习<a href="https://github.com/ziyuanshu/baidupan" target="_blank" rel="noopener">baidupan</a>源码</strong></h3><p>学到新东西：SweetAlert2 漂亮可定制的 JavaScript 弹窗</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @require           https://cdn.jsdelivr.net/npm/sweetalert2@9</span></span><br><span class="line"><span class="comment">// 基础语法：</span></span><br><span class="line">Swal.fire(&#123;</span><br><span class="line">title: <span class="string">"是否删除"</span>,</span><br><span class="line">text: <span class="string">"是否删除？一旦提交，无法恢复！"</span>,</span><br><span class="line">icon: <span class="string">"warning"</span>,</span><br><span class="line">showCancelButton: <span class="literal">true</span>,</span><br><span class="line">confirmButtonColor: <span class="string">"#DD6B55"</span>,</span><br><span class="line">confirmButtonText: <span class="string">"确定"</span>,</span><br><span class="line">cancelButtonText: <span class="string">"取消"</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">isConfirm</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 是否成功在then里面用if判断</span></span><br><span class="line"><span class="keyword">if</span> (isConfirm.value) &#123;</span><br><span class="line">Swal.fire(<span class="string">"删除成功"</span>, <span class="string">"成功"</span>, <span class="string">"success"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Swal.fire(<span class="string">"取消操作"</span>, <span class="string">"点击了取消"</span>, <span class="string">"error"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>来源于checkVersion</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setValue(<span class="string">'up'</span>,<span class="number">0</span>)</span><br><span class="line">    GM_xmlhttpRequest(&#123;</span><br><span class="line">        method: <span class="string">"GET"</span>,</span><br><span class="line">        url: <span class="string">`https://api.baiduyun.wiki/update?ver=<span class="subst">$&#123;version&#125;</span>`</span>,</span><br><span class="line">        responseType: <span class="string">'json'</span>,</span><br><span class="line">        onload: <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> res = r.response</span><br><span class="line">            setValue(<span class="string">'lastest_version'</span>, res.version)</span><br><span class="line">            userAgent = res.ua</span><br><span class="line">            ids = res.ids</span><br><span class="line">            <span class="keyword">if</span> (res.vcode === <span class="number">200</span> &amp;&amp; compareVersion(res.version,version)) &#123;</span><br><span class="line">                setValue(<span class="string">'up'</span>,<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res.scode != getValue(<span class="string">'scode'</span>)) &#123;</span><br><span class="line">                <span class="keyword">let</span> dom = $(<span class="string">'&lt;div&gt;&lt;img style="width: 250px;margin-bottom: 10px;" src="https://img.tool22.com/image/5f365d403c89f.jpg"&gt;&lt;input class="swal2-input" id="scode" type="text" placeholder="请输入暗号，可扫描上方二维码免费获取!"&gt;&lt;/div&gt;'</span>)</span><br><span class="line">                Swal.fire(&#123;</span><br><span class="line">                    title: <span class="string">"初次使用请输入暗号"</span>,</span><br><span class="line">                    html: dom[<span class="number">0</span>],</span><br><span class="line">                    allowOutsideClick: <span class="literal">false</span>,</span><br><span class="line">                    confirmButtonText: <span class="string">'确定'</span></span><br><span class="line">                &#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (res.scode == $(<span class="string">'#scode'</span>).val()) &#123;</span><br><span class="line">                        setValue(<span class="string">'scode'</span>, res.scode)</span><br><span class="line">                        setValue(<span class="string">'init'</span>, <span class="number">1</span>)</span><br><span class="line">                        Toast.fire(&#123;</span><br><span class="line">                            icon: <span class="string">'success'</span>,</span><br><span class="line">                            text: <span class="string">'暗号正确，正在初始化中。。。'</span>,</span><br><span class="line">                        &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                            history.go(<span class="number">0</span>)<span class="comment">// go() 方法可加载历史列表中的某个具体的页面。（-1上一个页面，1前进一个页面, 0就是当前页面)</span></span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        setValue(<span class="string">'init'</span>, <span class="number">0</span>)</span><br><span class="line">                        Swal.fire(&#123;</span><br><span class="line">                            title: <span class="string">"🔺🔺🔺"</span>,</span><br><span class="line">                            text: <span class="string">'暗号不正确，请通过微信扫码免费获取'</span>,</span><br><span class="line">                            imageUrl: <span class="string">'https://img.tool22.com/image/5f365d403c89f.jpg'</span>,</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                loadPanhelper()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将console.log输出分组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clog</span>(<span class="params">c1, c2, c3</span>) </span>&#123;</span><br><span class="line">    c1 = c1 ? c1 : <span class="string">''</span></span><br><span class="line">    c2 = c2 ? c2 : <span class="string">''</span></span><br><span class="line">    c3 = c3 ? c3 : <span class="string">''</span></span><br><span class="line">    <span class="built_in">console</span>.group(<span class="string">'[网盘直链下载助手]'</span>)<span class="comment">// 分组</span></span><br><span class="line">    <span class="built_in">console</span>.log(c1, c2, c3)</span><br><span class="line">    <span class="built_in">console</span>.groupEnd()      <span class="comment">// 要想将其他内容显示在外面得取消分组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="程序的逻辑"><a class="markdownIt-Anchor" href="#程序的逻辑"></a> 程序的逻辑</h4><ul><li><p>开始:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(() =&gt; &#123;</span><br><span class="line">    <span class="comment">//阻止在其他网站运行</span></span><br><span class="line">    <span class="keyword">if</span> (hostname.match(<span class="regexp">/(pan|yun).baidu.com/i</span>)) &#123;</span><br><span class="line">        <span class="keyword">let</span> plugin = <span class="keyword">new</span> PanPlugin()</span><br><span class="line">        plugin.init()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>进行检查更新-&gt;创建菜单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PanPlugin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clog(<span class="string">'RPC：'</span>, ariaRPC)</span><br><span class="line">    <span class="keyword">this</span>.init = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        main()</span><br><span class="line">        addGMStyle()</span><br><span class="line">        checkUpdate()</span><br><span class="line">        <span class="keyword">if</span> (getValue(<span class="string">'SETTING_H'</span>)) createHelp()</span><br><span class="line">        createMenu()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>主要的应用是在checkUpdate中的loadPanhelper完成的，其会根据参数创建PanHelper(网盘页面的下载助手)或PanShareHelper(分享页面的下载助手)对象， 显然PanHelper就是我们最想分析的</li></ul></li></ul><h4 id="panhelper逻辑"><a class="markdownIt-Anchor" href="#panhelper逻辑"></a> PanHelper逻辑</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PanHelper</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> yunData, sign, timestamp, bdstoken, logid, fid_list</span><br><span class="line">    <span class="keyword">let</span> fileList = [], selectFileList = [], batchLinkList = [], batchLinkListAll = [], linkList = []</span><br><span class="line">    <span class="keyword">let</span> dialog, searchKey</span><br><span class="line">    <span class="keyword">let</span> panAPIUrl = location.protocol + <span class="string">"//"</span> + location.host + <span class="string">"/api/"</span></span><br><span class="line">    <span class="keyword">let</span> restAPIUrl = location.protocol + <span class="string">"//pcs.baidu.com/rest/2.0/pcs/"</span></span><br><span class="line">    <span class="keyword">let</span> clientAPIUrl = location.protocol + <span class="string">"//pan.baidu.com/rest/2.0/"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.init = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        yunData = unsafeWindow.yunData</span><br><span class="line">        <span class="keyword">if</span> (yunData === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            clog(<span class="string">'初始化信息:'</span>, yunData)</span><br><span class="line">            clog(<span class="string">'页面未正常加载，或者百度已经更新！'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        initVar()</span><br><span class="line">        registerEventListener()</span><br><span class="line">        addButton()</span><br><span class="line">        createIframe()</span><br><span class="line">        dialog = <span class="keyword">new</span> Dialog(&#123;<span class="attr">addCopy</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">        clog(<span class="string">'下载助手加载成功！当前版本：'</span>, version)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最核心的逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的网盘 - 获取PCS下载地址</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPCSBatchLink</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fsids = []</span><br><span class="line">    $.each(selectFileList, (index, element) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (element.isdir == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        fsids.push(element.fs_id)</span><br><span class="line">    &#125;)</span><br><span class="line">    fsids = <span class="built_in">encodeURIComponent</span>(<span class="built_in">JSON</span>.stringify(fsids))</span><br><span class="line">    <span class="keyword">let</span> link = clientAPIUrl + <span class="string">`xpan/multimedia?method=filemetas&amp;access_token=undefined&amp;fsids=<span class="subst">$&#123;fsids&#125;</span>&amp;dlink=1`</span></span><br><span class="line">    GM_xmlhttpRequest(&#123;</span><br><span class="line">        method: <span class="string">"GET"</span>,</span><br><span class="line">        responseType: <span class="string">'json'</span>,</span><br><span class="line">        headers: &#123;<span class="string">"User-Agent"</span>: userAgent&#125;,</span><br><span class="line">        url: link,</span><br><span class="line">        onload: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> response = res.response</span><br><span class="line">            <span class="keyword">if</span> (response.errno === <span class="number">0</span>) &#123;</span><br><span class="line">                callback(response.list)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h2><h3 id="官方文档"><a class="markdownIt-Anchor" href="#官方文档"></a> <a href="https://www.tampermonkey.net/documentation.php#GM_openInTab" target="_blank" rel="noopener">官方文档</a></h3><h3 id="tampermonkey油猴用户脚本api文档-教程"><a class="markdownIt-Anchor" href="#tampermonkey油猴用户脚本api文档-教程"></a> <a href="https://www.1949la.com/post/10351.html" target="_blank" rel="noopener">Tampermonkey油猴用户脚本API文档-教程</a></h3><h3 id="脚本debug建议"><a class="markdownIt-Anchor" href="#脚本debug建议"></a> 脚本debug建议</h3><h4 id="jquery使用"><a class="markdownIt-Anchor" href="#jquery使用"></a> jquery使用</h4><p>踩了几天坑，最后总结一下编写油猴脚本的一点步骤。首先要思考脚本的实现方式，需要用到什么API和权限，然后填写好脚本的注释信息。</p><p>然后将功能封装成函数的形式，最后在脚本末尾调用实现的函数。写的差不多的时候复制到浏览器中尝试运行。</p><p>遇到困难的时候，可能需要直接在F12开发者工具里进行调试。<u>有些网页不用jQuery，为了方便，我们需要自己将jQuery导入到页面中，可以将下面的代码复制到浏览器控制台中。</u></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jq = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">jq.src = <span class="string">"https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(jq);</span><br></pre></td></tr></table></figure><h4 id="debug方法"><a class="markdownIt-Anchor" href="#debug方法"></a> debug方法：</h4><p>第一种方法就是最原始的打印日志，可以利用<code>console.log</code>和<code>GM_log</code>来将关键信息打印出来，上面的脚本就是我靠打印日志一点点发现各种参数错误的。说实话这种办法有点笨。</p><p>第二种就是利用浏览器的调试功能(推荐)，在脚本需要调试的地方插入<code>debugger;</code>语句，然后在打开F12开发者工具的情况下刷新页面，就会发现网页已经暂停在相应位置上。这样就可以利用F12开发者工具进行单步调试、监视变量等操作了。</p><h3 id="将文章同步复制到csdn和思否编辑器的脚本demo"><a class="markdownIt-Anchor" href="#将文章同步复制到csdn和思否编辑器的脚本demo"></a> 将文章同步复制到Csdn和思否编辑器的脚本demo：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         copy_jianshu_to_csdn_and_segmentfault</span></span><br><span class="line"><span class="comment">// @namespace    https://github.com/techstay/myscripts</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  将简书文章复制到csdn和思否编辑器中</span></span><br><span class="line"><span class="comment">// @author       techstay</span></span><br><span class="line"><span class="comment">// @match        https://editor.csdn.net/md/</span></span><br><span class="line"><span class="comment">// @match https://segmentfault.com/write</span></span><br><span class="line"><span class="comment">// @match https://www.jianshu.com/writer*</span></span><br><span class="line"><span class="comment">// @require      https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js</span></span><br><span class="line"><span class="comment">// @require      https://cdn.bootcss.com/jqueryui/1.12.1/jquery-ui.min.js</span></span><br><span class="line"><span class="comment">// @grant GM_setValue</span></span><br><span class="line"><span class="comment">// @grant GM_getValue</span></span><br><span class="line"><span class="comment">// @grant GM_deleteValue</span></span><br><span class="line"><span class="comment">// @grant unsafeWindow</span></span><br><span class="line"><span class="comment">// @grant GM_setClipboard</span></span><br><span class="line"><span class="comment">// @grant window.close</span></span><br><span class="line"><span class="comment">// @grant window.focus</span></span><br><span class="line"><span class="comment">// @grant GM_openInTab</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> SF_URL = <span class="string">'https://segmentfault.com/write'</span></span><br><span class="line">    <span class="keyword">const</span> CSDN_URL = <span class="string">'https://editor.csdn.net/md/'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> SF_TITLE = <span class="string">'sf_title'</span></span><br><span class="line">    <span class="keyword">const</span> SF_CONTENT = <span class="string">'sf_content'</span></span><br><span class="line">    <span class="keyword">const</span> CSDN_TITLE = <span class="string">'csdn_title'</span></span><br><span class="line">    <span class="keyword">const</span> CSDN_CONTENT = <span class="string">'csdn_content'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">saveArticle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        GM_setValue(CSDN_TITLE, $(<span class="string">'._24i7u'</span>).val())</span><br><span class="line">        GM_setValue(CSDN_CONTENT, $(<span class="string">'#arthur-editor'</span>).val())</span><br><span class="line">        GM_setValue(SF_TITLE, $(<span class="string">'._24i7u'</span>).val())</span><br><span class="line">        GM_setValue(SF_CONTENT, $(<span class="string">'#arthur-editor'</span>).val())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">copyToCsdn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> title = GM_getValue(CSDN_TITLE, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">var</span> content = GM_getValue(CSDN_CONTENT, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">if</span> (title != <span class="string">''</span> &amp;&amp; content != <span class="string">''</span>) &#123;</span><br><span class="line">            $(<span class="string">'.article-bar__title'</span>).delay(<span class="number">2000</span>).queue(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                $(<span class="string">'.article-bar__title'</span>).val(title)</span><br><span class="line">                $(<span class="string">'.editor__inner'</span>).text(content)</span><br><span class="line">                GM_deleteValue(CSDN_TITLE)</span><br><span class="line">                GM_deleteValue(CSDN_CONTENT)</span><br><span class="line">                $(<span class="keyword">this</span>).dequeue()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">copyToSegmentFault</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> title = GM_getValue(SF_TITLE, <span class="string">''</span>)</span><br><span class="line">            <span class="keyword">var</span> content = GM_getValue(SF_CONTENT, <span class="string">''</span>)</span><br><span class="line">            <span class="keyword">if</span> (title != <span class="string">''</span> &amp;&amp; content != <span class="string">''</span>) &#123;</span><br><span class="line">                $(<span class="string">'#title'</span>).delay(<span class="number">2000</span>).queue(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    $(<span class="string">'#title'</span>).val(title)</span><br><span class="line">                    GM_setClipboard(content, <span class="string">'text'</span>)</span><br><span class="line">                    GM_deleteValue(SF_TITLE)</span><br><span class="line">                    GM_deleteValue(SF_CONTENT)</span><br><span class="line">                    $(<span class="keyword">this</span>).dequeue()</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addCopyButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'body'</span>).append(<span class="string">'&lt;div id="copyToCS"&gt;双击复制到CSDN和思否&lt;/div&gt;'</span>)</span><br><span class="line">        $(<span class="string">'#copyToCS'</span>).css(<span class="string">'width'</span>, <span class="string">'200px'</span>)</span><br><span class="line">        $(<span class="string">'#copyToCS'</span>).css(<span class="string">'position'</span>, <span class="string">'absolute'</span>)</span><br><span class="line">        $(<span class="string">'#copyToCS'</span>).css(<span class="string">'top'</span>, <span class="string">'70px'</span>)</span><br><span class="line">        $(<span class="string">'#copyToCS'</span>).css(<span class="string">'left'</span>, <span class="string">'350px'</span>)</span><br><span class="line">        $(<span class="string">'#copyToCS'</span>).css(<span class="string">'background-color'</span>, <span class="string">'#28a745'</span>)</span><br><span class="line">        $(<span class="string">'#copyToCS'</span>).css(<span class="string">'color'</span>, <span class="string">'white'</span>)</span><br><span class="line">        $(<span class="string">'#copyToCS'</span>).css(<span class="string">'font-size'</span>, <span class="string">'large'</span>)</span><br><span class="line">        $(<span class="string">'#copyToCS'</span>).css(<span class="string">'z-index'</span>, <span class="number">100</span>)</span><br><span class="line">        $(<span class="string">'#copyToCS'</span>).css(<span class="string">'border-radius'</span>, <span class="string">'25px'</span>)</span><br><span class="line">        $(<span class="string">'#copyToCS'</span>).css(<span class="string">'text-align'</span>, <span class="string">'center'</span>)</span><br><span class="line">        $(<span class="string">'#copyToCS'</span>).dblclick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            saveArticle()</span><br><span class="line">            GM_openInTab(SF_URL, <span class="literal">true</span>)</span><br><span class="line">            GM_openInTab(CSDN_URL, <span class="literal">true</span>)</span><br><span class="line">            <span class="comment">// GM_openInTab(url, options)在新标签页打开URL。options可选的值：</span></span><br><span class="line">            <span class="comment">// active ：新标签页获得焦点; insert：新标签页在当前页面之后添加; setParent：当新标签页关闭后，焦点给回当前页面 ; incognito: 新标签页在隐身模式或私有模式窗口打开. </span></span><br><span class="line">            <span class="comment">// options可以写成&#123; active: true, insert: true, setParent :true &#125;</span></span><br><span class="line">            <span class="comment">// GM_openInTab(url, loadInBackground)：loadInBackground 可以是 Boolean 类型，如果是 true，则当前 tab 不变，如果是 false，则当前 tab 变为新打开的 tab.  当前tab就是当前标签页(显示的页面)</span></span><br><span class="line">        &#125;)</span><br><span class="line">        $(<span class="string">'#copyToCS'</span>).draggable()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.location.href.startsWith(<span class="string">'https://www.jianshu.com'</span>)) &#123;</span><br><span class="line">            addCopyButton()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.location.href.startsWith(SF_URL)) &#123;</span><br><span class="line">            copyToSegmentFault()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.location.href.startsWith(CSDN_URL)) &#123;</span><br><span class="line">            copyToCsdn()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>▲推荐：<a href="https://blog.csdn.net/u011054333/article/details/104101806" target="_blank" rel="noopener">油猴脚本编写教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;由于在研究如何优化网盘直链下载助手**&lt;a href=&quot;https://github.com/ziyuanshu/baidupan&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;baidupan&lt;/a&gt;&lt;strong&gt;，如何将直链
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浙大2020春夏-人工智能习题3——AIforOthello</title>
    <link href="https://nymrli.top/2020/12/01/%E6%B5%99%E5%A4%A72020%E6%98%A5%E5%A4%8F-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B9%A0%E9%A2%981%E2%80%94%E2%80%94AIforOthello/"/>
    <id>https://nymrli.top/2020/12/01/浙大2020春夏-人工智能习题1——AIforOthello/</id>
    <published>2020-12-01T04:02:33.000Z</published>
    <updated>2020-12-11T03:17:16.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="something-about-othello"><a class="markdownIt-Anchor" href="#something-about-othello"></a> something about Othello</h2><h3 id="黑白棋规则"><a class="markdownIt-Anchor" href="#黑白棋规则"></a> 黑白棋规则</h3><p>传统的黑白棋棋盘由 8 x 8 方格组成。开局时，棋盘中央的4格先置黑白相间的4颗棋子 (详见下图)，并由<strong>黑子先行</strong>。</p><p>首步由黑子先下；下子时；新子必须与棋盘上任一己方棋子形成一条或多条 (横、竖、斜) 直线，并夹着对方棋子；由新子及旧子连成的直线之间，必须存有一颗或以上对方的棋子。如图，黑子开局时之可行棋步有以下4格:</p><p>双方交替下子；倘若任何一方没有棋步可行，则其必须将下子权利相认予对手；另在双方均无子可下的情况下，游戏自动结束。</p><p>游戏结束后，拥子较多一方为胜；倘若双方棋数相同的，则为和局。</p><h3 id="黑白棋基本策略"><a class="markdownIt-Anchor" href="#黑白棋基本策略"></a> 黑白棋基本策略</h3><h4 id="占角子及固定子"><a class="markdownIt-Anchor" href="#占角子及固定子"></a> 占角子及固定子</h4><blockquote><p>按照黑白棋的玩法，其中一子落在佔角处的，该棋子将无法再被翻转。</p></blockquote><h4 id="危险方块"><a class="markdownIt-Anchor" href="#危险方块"></a> 危险方块</h4><p>在棋盘上，棋子下在某些方块中，比起其它下子位置更为安全。档游戏开始，一般建议尽量将棋子下于棋盘 4 x 4格的中心范围内 (下图以半透明白子显示)；且应避免将棋子下于靠近边角的方块内(下图以半透明黑子显示)，棋子落于靠近边角的方块中，会让对手更容易占据边角相邻的位置。</p><p><img src="https://www.eothello.com/images/basic_strategy_othello_2.png" alt="Basic strategy - danger zones"></p><h4 id="行动力"><a class="markdownIt-Anchor" href="#行动力"></a> 行动力</h4><p>初学者的普遍错误一般在开盘后<u>不断占子</u>，但在黑白棋中这并<u>不是一个好的策略</u>。<strong>较好的策略为专注于限制对方的落子选项，而交易进入这种策略的方法为占少子</strong>。在下面的例子中，白子虽然只有一颗棋子，但其可轻而易具的在4步内赢得整盘棋。</p><p>from : <a href="https://www.eothello.com/" target="_blank" rel="noopener">https://www.eothello.com/</a></p><p>较为强悍的othello AI: <a href="https://playpager.com/play-reversi/index.html" target="_blank" rel="noopener">https://playpager.com/play-reversi/index.html</a></p><h2 id="ai-for-othello-coding"><a class="markdownIt-Anchor" href="#ai-for-othello-coding"></a> AI for Othello Coding</h2><h3 id="search-before-coding"><a class="markdownIt-Anchor" href="#search-before-coding"></a> search before Coding：</h3><ul><li><a href="https://github.com/Unispac" target="_blank" rel="noopener">Unispac</a>/<strong><a href="https://github.com/Unispac/Alpha-Othello" target="_blank" rel="noopener">Alpha-Othello</a></strong>——浙大学长的（集成了很多Agent）</li><li><a href="https://github.com/YuMu0" target="_blank" rel="noopener">YuMu0</a>/<strong><a href="https://github.com/YuMu0/ReversiAI" target="_blank" rel="noopener">ReversiAI</a></strong>——博弈树、α-β剪枝（有UI；单文件，结构有点差）</li><li><a href="https://github.com/1011497938" target="_blank" rel="noopener">1011497938</a>/<strong><a href="https://github.com/1011497938/Othello" target="_blank" rel="noopener">Othello</a></strong>——MCTS、Q-learning（在浙大学长的基础上增加了几类agent）</li><li><a href="https://github.com/im0qianqian" target="_blank" rel="noopener">im0qianqian</a>/<strong><a href="https://github.com/im0qianqian/Reversi-based-RL" target="_blank" rel="noopener">Reversi-based-RL</a></strong>——毕设，文档说明：<a href="https://www.dreamwings.cn/reversi/3013.html" target="_blank" rel="noopener">https://www.dreamwings.cn/reversi/3013.html</a></li><li><a href="https://github.com/faded53222" target="_blank" rel="noopener">faded53222</a>/<strong><a href="https://github.com/faded53222/Othello" target="_blank" rel="noopener">Othello</a></strong>——B站用户</li></ul><hr><h2 id="mycode"><a class="markdownIt-Anchor" href="#mycode"></a> MyCode</h2><blockquote><p>部分借鉴了<a href="https://github.com/int8/monte-carlo-tree-search" target="_blank" rel="noopener">tic-tac-toe井字棋MCTS</a>的代码框架</p></blockquote><p>MSCT-target： Start：从可行位置进行树探索 -&gt; End：一个价值比较高的action</p><p><mark>代码中容易忘记的是，所有的board在rollout的时候都应该保存的临时变量，即确保node的self.board是不变的；board设计的时候，不要限定死color（move），这样可选择性更好</mark></p><p>虽然加上了corner，但是对站中级还是赢少输多， 看了下比赛棋盘，发现对corner的限制并不奏效，希望能找到更好的方法吧。</p><p><img src="/2020/12/01/浙大2020春夏-人工智能习题1——AIforOthello/mct-seq.png" alt="mct-seq"></p><h3 id="战力"><a class="markdownIt-Anchor" href="#战力"></a> 战力</h3><h4 id="basic"><a class="markdownIt-Anchor" href="#basic"></a> basic</h4><h5 id="初级win"><a class="markdownIt-Anchor" href="#初级win"></a> 初级WIN</h5><p><img src="/2020/12/01/浙大2020春夏-人工智能习题1——AIforOthello/E:%5Chexo%5Csource_posts%5CAI-for-Othello%5Cbasic_%E5%88%9D%E7%BA%A7win-%E4%B8%AD%E7%BA%A7Lost%5C%E5%88%9D%E7%BA%A7%5C12.png" alt="12"></p><p><img src="/2020/12/01/浙大2020春夏-人工智能习题1——AIforOthello/E:%5Chexo%5Csource_posts%5CAI-for-Othello%5Cbasic_%E5%88%9D%E7%BA%A7win-%E4%B8%AD%E7%BA%A7Lost%5C%E5%88%9D%E7%BA%A7%5C21.png" alt="21"></p><p><img src="/2020/12/01/浙大2020春夏-人工智能习题1——AIforOthello/E:%5Chexo%5Csource_posts%5CAI-for-Othello%5Cbasic_%E5%88%9D%E7%BA%A7win-%E4%B8%AD%E7%BA%A7Lost%5C%E5%88%9D%E7%BA%A7%5C22.png" alt="22"></p><h5 id="中级loss"><a class="markdownIt-Anchor" href="#中级loss"></a> 中级LOSS：</h5><p><img src="/2020/12/01/浙大2020春夏-人工智能习题1——AIforOthello/E:%5Chexo%5Csource_posts%5CAI-for-Othello%5Cbasic_%E5%88%9D%E7%BA%A7win-%E4%B8%AD%E7%BA%A7Lost%5C%E4%B8%AD%E7%BA%A7%5C11.png" alt="11"></p><p><img src="/2020/12/01/浙大2020春夏-人工智能习题1——AIforOthello/E:%5Chexo%5Csource_posts%5CAI-for-Othello%5Cbasic_%E5%88%9D%E7%BA%A7win-%E4%B8%AD%E7%BA%A7Lost%5C%E4%B8%AD%E7%BA%A7%5C12.png" alt="12"></p><p><img src="/2020/12/01/浙大2020春夏-人工智能习题1——AIforOthello/E:%5Chexo%5Csource_posts%5CAI-for-Othello%5Cbasic_%E5%88%9D%E7%BA%A7win-%E4%B8%AD%E7%BA%A7Lost%5C%E4%B8%AD%E7%BA%A7%5C21.png" alt="21"></p><p><img src="/2020/12/01/浙大2020春夏-人工智能习题1——AIforOthello/E:%5Chexo%5Csource_posts%5CAI-for-Othello%5Cbasic_%E5%88%9D%E7%BA%A7win-%E4%B8%AD%E7%BA%A7Lost%5C%E4%B8%AD%E7%BA%A7%5C22.png" alt="22"></p><h4 id="加上corner"><a class="markdownIt-Anchor" href="#加上corner"></a> 加上corner：</h4><h5 id="中级tie"><a class="markdownIt-Anchor" href="#中级tie"></a> 中级tie</h5><p><img src="/2020/12/01/浙大2020春夏-人工智能习题1——AIforOthello/E:%5Chexo%5Csource_posts%5CAI-for-Othello%5C%E5%8A%A0%E4%B8%8Acorner%5C11.png" alt="11"></p><p><img src="/2020/12/01/浙大2020春夏-人工智能习题1——AIforOthello/E:%5Chexo%5Csource_posts%5CAI-for-Othello%5C%E5%8A%A0%E4%B8%8Acorner%5C12.png" alt="12"></p><h5 id="中级win"><a class="markdownIt-Anchor" href="#中级win"></a> 中级WIN</h5><p><img src="/2020/12/01/浙大2020春夏-人工智能习题1——AIforOthello/E:%5Chexo%5Csource_posts%5CAI-for-Othello%5C%E5%8A%A0%E4%B8%8Acorner%5C21.png" alt="21"></p><p><img src="/2020/12/01/浙大2020春夏-人工智能习题1——AIforOthello/E:%5Chexo%5Csource_posts%5CAI-for-Othello%5C%E5%8A%A0%E4%B8%8Acorner%5C22.png" alt="22"></p><h4 id="高级"><a class="markdownIt-Anchor" href="#高级"></a> 高级：</h4><h2 id="时间安排"><a class="markdownIt-Anchor" href="#时间安排"></a> 时间安排</h2><p>2020/12/2 上网冲浪，搜集相关资料，看了<a href="https://github.com/Unispac" target="_blank" rel="noopener">Unispac</a>/**<a href="https://github.com/Unispac/Alpha-Othello" target="_blank" rel="noopener">Alpha-Othello</a>**的设计报告。</p><p>2020/12/4 结合<a href="https://github.com/1011497938/Othello" target="_blank" rel="noopener">代码</a>和[视频](<a href="https://www.bilibili.com/video/BV1JD4y1Q7mV?from=search&amp;seid=6045698802301050730" target="_blank" rel="noopener">AI如何下棋？直观了解蒙特卡洛树搜索MCTS！！！</a>理了遍MCTS的原理， 列出了大致的框架， 明天开始编写逻辑代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;something-about-othello&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#something-about-othello&quot;&gt;&lt;/a&gt; something about Othello&lt;/h2&gt;
&lt;h3 id=&quot;黑白棋规
      
    
    </summary>
    
    
      <category term="ZJU" scheme="https://nymrli.top/tags/ZJU/"/>
    
      <category term="ML" scheme="https://nymrli.top/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>fork curlconverter for Better</title>
    <link href="https://nymrli.top/2020/12/01/fork-curlconverter-for-Better/"/>
    <id>https://nymrli.top/2020/12/01/fork-curlconverter-for-Better/</id>
    <published>2020-12-01T02:43:34.000Z</published>
    <updated>2020-12-01T04:00:56.428Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>终于12月了，又是一个月初，定个flag，pr一个Gitcode</p><p>由于之前写Python爬虫的时候，从<a href="https://github.com/NickCarneiro/curlconverter" target="_blank" rel="noopener">curlconverter</a>受惠很多，并且看到<a href="https://github.com/NickCarneiro/curlconverter/issues/22" target="_blank" rel="noopener">issue #22: Add generator for Java</a>中有Java版本的需求还未完成，所以目标就是完成JAVA for curl</p></blockquote><p>curlconverter提供了一个网页版： <a href="https://curl.trillworks.com/%EF%BC%8C" target="_blank" rel="noopener">https://curl.trillworks.com/，</a> 其实其本质上也是用js完成的，功能如README中所写：</p><h2 id="readme"><a class="markdownIt-Anchor" href="#readme"></a> README</h2><h3 id="install"><a class="markdownIt-Anchor" href="#install"></a> Install</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save curlconverter</span><br></pre></td></tr></table></figure><h3 id="usage"><a class="markdownIt-Anchor" href="#usage"></a> Usage</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> curlconverter = <span class="built_in">require</span>(<span class="string">'curlconverter'</span>);</span><br><span class="line"></span><br><span class="line">curlconverter.toPython(<span class="string">"curl 'http://en.wikipedia.org/' -H 'Accept-Encoding: gzip, deflate, sdch' -H 'Accept-Language: en-US,en;q=0.8' -H 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36' -H 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8' -H 'Referer: http://www.wikipedia.org/' -H 'Cookie: GeoIP=US:Albuquerque:35.1241:-106.7675:v4; uls-previous-languages=%5B%22en%22%5D; mediaWiki.user.sessionId=VaHaeVW3m0ymvx9kacwshZIDkv8zgF9y; centralnotice_buckets_by_campaign=%7B%22C14_enUS_dsk_lw_FR%22%3A%7B%22val%22%3A%220%22%2C%22start%22%3A1412172000%2C%22end%22%3A1422576000%7D%2C%22C14_en5C_dec_dsk_FR%22%3A%7B%22val%22%3A3%2C%22start%22%3A1417514400%2C%22end%22%3A1425290400%7D%2C%22C14_en5C_bkup_dsk_FR%22%3A%7B%22val%22%3A1%2C%22start%22%3A1417428000%2C%22end%22%3A1425290400%7D%7D; centralnotice_bannercount_fr12=22; centralnotice_bannercount_fr12-wait=14' -H 'Connection: keep-alive' --compressed"</span>);</span><br></pre></td></tr></table></figure><p>Returns a string of Python code like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">cookies = &#123;</span><br><span class="line">    <span class="string">'GeoIP'</span>: <span class="string">'US:Albuquerque:35.1241:-106.7675:v4'</span>,</span><br><span class="line">    <span class="string">'uls-previous-languages'</span>: <span class="string">'%5B%22en%22%5D'</span>,</span><br><span class="line">    <span class="string">'mediaWiki.user.sessionId'</span>: <span class="string">'VaHaeVW3m0ymvx9kacwshZIDkv8zgF9y'</span>,</span><br><span class="line">    <span class="string">'centralnotice_buckets_by_campaign'</span>: <span class="string">'%7B%22C14_enUS_dsk_lw_FR%22%3A%7B%22val%22%3A%220%22%2C%22start%22%3A1412172000%2C%22end%22%3A1422576000%7D%2C%22C14_en5C_dec_dsk_FR%22%3A%7B%22val%22%3A3%2C%22start%22%3A1417514400%2C%22end%22%3A1425290400%7D%2C%22C14_en5C_bkup_dsk_FR%22%3A%7B%22val%22%3A1%2C%22start%22%3A1417428000%2C%22end%22%3A1425290400%7D%7D'</span>,</span><br><span class="line">    <span class="string">'centralnotice_bannercount_fr12'</span>: <span class="string">'22'</span>,</span><br><span class="line">    <span class="string">'centralnotice_bannercount_fr12-wait'</span>: <span class="string">'14'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate, sdch'</span>,</span><br><span class="line">    <span class="string">'Accept-Language'</span>: <span class="string">'en-US,en;q=0.8'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36'</span>,</span><br><span class="line">    <span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'</span>,</span><br><span class="line">    <span class="string">'Referer'</span>: <span class="string">'http://www.wikipedia.org/'</span>,</span><br><span class="line">    <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">'http://en.wikipedia.org/'</span>, headers=headers, cookies=cookies)</span><br></pre></td></tr></table></figure><p>想要参加开发，最重要的就是看清master提出的contributing要求：</p><h3 id="contributing"><a class="markdownIt-Anchor" href="#contributing"></a> Contributing</h3><blockquote><p>I’d rather write programs to write programs than write programs.</p><p>Dick Sites, Digital Equipment Corporation, September 1985</p></blockquote><p>Make sure you’re running node 12 or greater. The test suite will fail on older versions of node.</p><p>If you add a new generator, make sure to update the list of supported languages in <a href="https://github.com/NickCarneiro/curlconverter/blob/master/bin/cli.js" target="_blank" rel="noopener">cli.js</a> or else it won’t be accessible from the command line. Further, you’ll want to update test.js and index.js for your new generator to make it part of the testing.</p><p>If you want to add new functionality, start with a test.</p><ul><li>Create a file containing the curl command in <code>fixtures/curl_commands</code> with a descriptive filename like <code>post_with_headers.txt</code></li><li>Create a file containing the output in <code>fixtures/python_output/</code> with a matching filename (but different extension) like <code>post_with_headers.py</code></li><li>Run tests with <code>npm test</code>.</li><li>If your filenames match correctly, you should see one failing test. Fix it by modifying the parser in <code>util.js</code> or the generators in <code>generators/</code></li></ul><p>The parser generates a generic data structure consumed by code generator functions.</p><p>You can run a specific test with this command:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node test.js --test=test_name</span><br></pre></td></tr></table></figure><p>where “test_name” is a file (without extension) in <code>fixtures/curl_commands</code></p><p>You can run a specific test with this command:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node test.js --language=R</span><br></pre></td></tr></table></figure><p>I recommend setting this up with a debugger so you can see exactly what the parser is passing to the generator. Here’s my Intellij run configuration for a single test:</p><p>Before submitting a PR, please check that your JS code conforms to the code style enforced by <a href="https://standardjs.com/" target="_blank" rel="noopener">standardjs</a>. Use the following to fix your code if it doesn’t:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ standard --fix my_file.js</span><br></pre></td></tr></table></figure><p>If you get stuck, please reach out via email. I am always willing to hop on a google hangout and pair program.</p><h4 id="翻译"><a class="markdownIt-Anchor" href="#翻译"></a> 翻译：</h4><blockquote><p>相比写程序，我更愿意写出能写程序的程序。——Dick Sites, Digital Equipment Corporation, September 1985</p></blockquote><p>确保你正在运行node 12或更高版本。测试套件在旧版本的node上会失败。</p><p>如果你添加了一个新的生成器，请确保更新cli.js中的支持语言列表，否则它将无法从命令行访问。此外，你还要为你的新生成器更新test.js和index.js，使其成为测试的一部分。</p><p>如果您想添加新功能，请从测试开始。</p><ul><li>在<code>fixtures/curl_commands</code>中创建一个包含curl命令的文件，文件名为post_with_headers.txt。</li><li>在<code>fixtures/python_output/</code>中创建一个包含输出的文件，并使用一个匹配的文件名（但不同的扩展名），比如<code>post_with_headers.py</code>。</li><li>用<code>npm test</code>运行测试。</li><li>如果您的文件名正确匹配，您应该看到一个失败的测试。通过修改<code>util.js</code>中的解析器或<code>generators/</code>中的生成器来解决。</li></ul><p>解析器需要生成一个通用数据结构给代码生成器函数。</p><p>你可以用这个命令运行一个特定的测试。<code>node test.js --test=test_name</code>， 其中 &quot;test_name &quot;是<code>fixtures/curl_commands</code>中的一个文件（没有扩展名）。</p><p>你可以用这个命令运行一个特定的测试。<code>node test.js --language=R</code>，我建议用调试器来设置，这样你就可以看到解析器传递给生成器的具体内容。这是我的Intellij运行配置，用于单次测试。</p><p><img src="https://github.com/NickCarneiro/curlconverter/raw/master/docs/intellijconfig.png" alt="Screenshot of intellij debug configuration"></p><p>在提交PR之前，请检查您的JS代码是否符合standardjs执行的代码风格。如果不符合的话，请使用下面的方法来修正你的代码。<code>$ standard --fix my_file.js.</code></p><p>如果你遇到困难，请通过电子邮件联系我。我总是愿意跳上google上线、校验程序。</p><hr><h2 id="分析其他contributor的pr"><a class="markdownIt-Anchor" href="#分析其他contributor的pr"></a> 分析其他contributor的PR</h2><h3 id="dainisgorbunovs"><a class="markdownIt-Anchor" href="#dainisgorbunovs"></a> <strong><a href="https://github.com/DainisGorbunovs" target="_blank" rel="noopener">DainisGorbunovs</a></strong></h3><ul><li>PR说明：<a href="https://github.com/NickCarneiro/curlconverter/pull/154" target="_blank" rel="noopener">https://github.com/NickCarneiro/curlconverter/pull/154</a><ul><li>Thanks / what I found helpful：<ul><li>可以使用nc -l 3000，然后在另一个标签页中 curl -X POST <a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a> --data “hello=world” (感谢 @NickCarneiro)</li><li>可以使用Wireshark来检查（抓包）</li><li>可以使用<strong>httpbin</strong>服务（用途：个人感觉是将curl结果跟generate结果对比）</li></ul></li></ul></li><li>commit详情：<a href="https://github.com/DainisGorbunovs/curlconverter/commit/5cfedbf595177aa912b78f0fde05f15da81f11f9" target="_blank" rel="noopener">https://github.com/DainisGorbunovs/curlconverter/commit/5cfedbf595177aa912b78f0fde05f15da81f11f9</a></li></ul><hr><h2 id="java-for-curl"><a class="markdownIt-Anchor" href="#java-for-curl"></a> JAVA for Curl</h2><h3 id="http库选取"><a class="markdownIt-Anchor" href="#http库选取"></a> http库选取</h3><blockquote><p>在2016年的时候**<a href="https://github.com/NickCarneiro" target="_blank" rel="noopener">NickCarneiro</a>**就<a href="https://github.com/NickCarneiro/curlconverter/issues/22" target="_blank" rel="noopener">Add generator for Java #22</a>提出增加JAVA版本， 但无奈JAVA较为繁琐，并且没有像Python的requests一样好用的库，因此现在都还未有JAVA版本</p><blockquote><p>Java is super popular and super verbose, making it a good candidate for curlconverter.<br>We need to find out if there is some modern library for sending http requests. Please advise.</p></blockquote></blockquote><h4 id="1-httpclient"><a class="markdownIt-Anchor" href="#1-httpclient"></a> 1、HttpClient</h4><blockquote><p>HttpClient：代码复杂，还得操心资源回收等。代码很复杂，冗余代码多，不建议直接使用。</p></blockquote><h5 id="httpclient使用介绍"><a class="markdownIt-Anchor" href="#httpclient使用介绍"></a> HttpClient使用介绍</h5><p>使用HttpClient发送请求主要分为以下几步骤：</p><ul><li>创建 CloseableHttpClient对象或CloseableHttpAsyncClient对象，前者同步，后者为异步</li><li>创建Http请求对象</li><li>调用execute方法执行请求，如果是异步请求在执行之前需调用start方法</li></ul><ol><li>java原生HttpURLConnection</li><li>apache HttpClient3.1</li><li>apache httpClient4.5</li></ol><p>上述见：<a href="https://www.cnblogs.com/hhhshct/p/8523697.html" target="_blank" rel="noopener">java实现HTTP请求的三种方式</a>—— 有代码demo</p><h4 id="2-okhttp"><a class="markdownIt-Anchor" href="#2-okhttp"></a> 2、okhttp</h4><blockquote><p>okhttp：OkHttp是一个高效的HTTP客户端，允许所有同一个主机地址的请求共享同一个socket连接；连接池减少请求延时；透明的GZIP压缩减少响应数据的大小；缓存响应内容，避免一些完全重复的请求</p></blockquote><p>OkHttp使用</p><p>使用OkHttp发送请求主要分为以下几步骤：</p><ul><li>创建OkHttpClient对象</li><li>创建Request对象</li><li>将Request 对象封装为Call</li><li>通过Call 来执行同步或异步请求，调用execute方法同步执行，调用enqueue方法异步执行</li></ul><h4 id="3-resttemplate"><a class="markdownIt-Anchor" href="#3-resttemplate"></a> 3、RestTemplate</h4><blockquote><p>RestTemplate： 是 Spring 提供的用于访问Rest服务的客户端， RestTemplate 提供了多种便捷访问远程Http服务的方法,能够大大提高客户端的编写效率。</p></blockquote><p><a href="https://www.cnblogs.com/zk-blog/p/12465951.html" target="_blank" rel="noopener">https://www.cnblogs.com/zk-blog/p/12465951.html</a></p><h4 id="4http-request"><a class="markdownIt-Anchor" href="#4http-request"></a> 4.<strong><a href="https://github.com/kevinsawicki/http-request" target="_blank" rel="noopener">http-request</a></strong></h4><blockquote><p>在我们日常工作中，我们需要经常和第三方接口进行交互通信，很多时候我们都是使用http协议进行交互，java原生自带对http的支持（<code>java.net.*</code>），但是使用起来不太方便，除此之外，用的最多的就是apache httpclient工具包。但是个人使用这么久而言，感觉不管是原生的抑或是httpclient，使用起来都不太顺手，也略显复杂</p></blockquote><p>文章见： <a href="https://www.jianshu.com/p/e955b01e2e16" target="_blank" rel="noopener">JAVA http请求工具类http-request</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;终于12月了，又是一个月初，定个flag，pr一个Gitcode&lt;/p&gt;
&lt;p&gt;由于之前写Python爬虫的时候，从&lt;a href=&quot;https://github.com/NickCarneiro/curlconverter&quot; target=&quot;_b
      
    
    </summary>
    
    
      <category term="GitCode" scheme="https://nymrli.top/tags/GitCode/"/>
    
  </entry>
  
  <entry>
    <title>《漫画机器学习入门》大关真之——读书笔记</title>
    <link href="https://nymrli.top/2020/11/28/%E3%80%8A%E6%BC%AB%E7%94%BB%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8B%E5%A4%A7%E5%85%B3%E7%9C%9F%E4%B9%8B%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2020/11/28/《漫画机器学习入门》大关真之——读书笔记/</id>
    <published>2020-11-28T13:39:01.000Z</published>
    <updated>2020-11-28T13:40:38.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漫画机器学习入门总结"><a class="markdownIt-Anchor" href="#漫画机器学习入门总结"></a> 《漫画机器学习入门》总结</h1><p>机器学习是指计算机通过不断地处理数据并修正算法和参数来学习各种规则， 从而不断改进模型而得到更优化的算法。书中主要讲解了玻尔兹曼机的机器学习</p><h3 id="谁是世界上最美丽的人"><a class="markdownIt-Anchor" href="#谁是世界上最美丽的人"></a> <a href="https://blog.csdn.net/weixin_41513917/article/details/102646458#%E7%9F%A5%E8%AF%86%E7%82%B9" target="_blank" rel="noopener">谁是世界上最美丽的人？</a></h3><ol><li><p>****特征量****就是如每一个人的年龄，眼睛大小； 特征向量就是每个人的特征量放到一起，特征向量是表达特征的一个数组</p></li><li><p>误差函数： 在美丽程度这个问题上， 误差函数就是—— 计算“美丽程度”的实际输出与给定的理想输出之间的差值</p></li><li><p>最优化问题：  最小化误差函数，其实是一个求解最优化问题：我们的任务就是要找到没有误差或者误差小到满足要求的最适合的模型。这就要通过调节模型中的参数，使误差函数值尽量小，这就是求解（参数）最优化问题。</p><ol><li>微分：稍微拉动一点摇杆，确认误差是否变小。这种操作叫做<strong>微分</strong>。</li><li>梯度下降法： 一直拉到误差不再减少，直到误差值保持不变或者反而有所上升时为止。希望不停地调整权重，使得误差一直在朝着减小的方向前进。这种调整误差的方法叫<strong>梯度下降法</strong>。</li><li><img src="https://img-blog.csdnimg.cn/20191021100811994.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTUxMzkxNw==,size_16,color_FFFFFF,t_70" alt=""></li></ol></li><li><p>回归就是：建立模型—拟合—微调</p></li><li><p>机器学习是寻找输入数据与输出数据之间关系(model-&gt;function map)的一门学问。</p></li><li><p>每一个特征量都很重要，但是不同特征量的重要程度是不同的，所以需要寻找特征的权重矩阵</p></li><li><p>训练数据和测试数据： 学习和测试是机器学习的两项基本任务。 (1)好的算法很重要； (2)要将获得的数据分为训练用数据和测试用数据；(3)仅仅匹配训练用数据是不行的——仅仅满足训练用数据叫overfit过拟合，如果连训练数据都不符合叫underfit欠拟合</p></li><li><p>验证的方法：交叉验证：将所有的数据分成4组， 每组中1份数据用于测试，3份用于训练</p></li><li><p>复杂化模型——寻找新的特征值：sigmoid 函数：当发现检测的结果不太好，王后想把模型变得更复杂一些。王后尝试将原始的特征量组合起来获得新的特征量，再加权求输出，却发现因为只有乘法和加法的情况这种<strong>线性特性</strong>，与之前并没有本质区别。因此，引入了sigmoid函数，这个非线性函数。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">sig(x) = \frac{1}{1-e^{-x}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7026642857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p><img src="https://img-blog.csdnimg.cn/2019102111070935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTUxMzkxNw==,size_16,color_FFFFFF,t_70" alt=""></p><p>加权组合，构成新的特征值： 如果我们把将特征量组合，新增加5个特征量的话（如图），摇杆的数量就变成了原来的5倍。</p><p>多层神经网络：在单层神经网络的基础上，增加一层非线性变换，结构上也就多了一个中间的曾，就是多层神经网络。</p></li><li><p>只由输入到输出方向进行信息的传递，被称为正向型神经网络； 而双方向都能够进行信息交换的结构被称为双向型神经网络。双向型神经网络典型代表是Hopfield一处的，玻尔兹曼机也是基于这种神经网络。 双向信息处理模式不同于淡出的正向信息处理， 它可以有多个输出结果， 而且从这些输出结果中它可以回忆起以前记忆过的信息，因此也被叫做联想记忆。</p></li><li><p>模型越复杂，网络就越纠缠，拉动一根线就会对整个网络产生较大的影响。反过来，网络中任何一根线又会连接很多其他的线，拉它的时候也会受到很大限制，甚至拉不动。 距离输出层越近的摇杆越容易搬动，这是有梯度的结果。因为搬动一下离输出很近的摇杆，它的效果能够很方便地传递给输出。离输出越远，梯度越难计算，越难调整。===&gt;BP算法， 以及最好不要使用Sigmod函数， 因为容易梯度消失， 可以换用tanh或者reLU（观察函数的微分结果）</p></li><li><p><strong>dropout</strong>：为了防止过度学习， 需要掌握平衡， 做出取舍：  适当地选取一定比例的特征量，剩下的全部舍弃不用。</p></li><li><p>批量学习与在线学习：</p><p><strong>批量学习（batch learning）</strong>：将全部数据收集齐了之后一起作为训练用数据使用，这叫做批量学习（batch learning）</p><p><strong>在线学习（online learning）</strong>:与此相对的，随着数据不断地获取而逐步进行的学习则称为在线学习（online learning）</p><p>现在批量学习也在改进，有些地方与在线学习差不多， 如使用概率梯度下降法：</p><p><img src="https://img-blog.csdnimg.cn/20191021170700902.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTUxMzkxNw==,size_16,color_FFFFFF,t_70" alt=""></p><p>（采用概率的方式去分组，也叫随机选择，就是不能利用某种故意的特定意图去分组）</p><p>当利用概率分组后，对每一组数据进行训练，动一下摇杆看误差如何变化，然后再向误差变小的方向搬动摇杆，这就是概率梯度下降法。（通过适当地概率计算，让参数或左或右地跳动着变化）</p><p>这种算法考虑的是，与其冲着预先规定好的方向一直走下去，倒不如是不是地左看看，右看看。这样反倒更容易找到隐藏的近路。</p><p>在线学习和随机梯度下降法的优势在于， 可以捕捉灵光霎现的机会， 增加了跳脱鞍点的可能性。</p></li></ol><h3 id="粮食问题"><a class="markdownIt-Anchor" href="#粮食问题"></a> 粮食问题</h3><ol><li><p>感知机perceptron(弗兰克·罗森布拉特)和支持向量机SVM(Vladmir N.Vapnik)</p><p>感知机：移动分割超平面进行数据分类。感知机的缺点：非线性模型处理不好</p><p>支持向量机：使分割超平面处于一种非常“好”的状态，即所有数据点尽量都远离分割超平面，因此能够更好的识别并且<strong>使得安全裕量最大</strong></p></li><li><p><strong>矩阵的秩</strong>：= 模式的种类， 一个模式以一行向量表示。<u>矩阵中两行的规律相似，应该属于同一种模式</u>。假设数据中存在某些模式，那么在矩阵中一定会存在某一行的数值代表该模式，其他的某一行代表另一种模式。</p><p>如果模式能够从可见数据中推演出来，通过对可见数据做有效处理，就能够推测出不可见的那部分数据，这其实是一种无监督学习：希望能够完美地补充矩阵中空白的数据，并能够预测出新的模式。（计算机从大量数据中通过自己的分析来找出规律，叫做无监督学习）</p></li><li><h3 id="预测方面有监督无监督的不同"><a class="markdownIt-Anchor" href="#预测方面有监督无监督的不同"></a> 预测方面有监督/无监督的不同 ：</h3><p>从数据中学到东西，这一点是一致的。之后，在是否进行预测这一点上是不同的。<br>有监督学习是希望计算机越来越聪明并逐渐能够代替人的某些工作。<br>无监督学习，是希望计算机从特征量中选择出我们容易理解的某种模式，将模式分成若干或者某种形式的分类。</p></li><li><p><strong>稀疏化</strong>：有些算法会将不重要的特征量的权重直接设定为0，舍弃一些不重要的东西， 导致矩阵中产生很多0， 这种矩阵将稀疏矩阵。</p></li><li><p><strong>非负矩阵分解（ Nonnegative Matrix Factor ）</strong>： 非负，指在计算的时候不使用负值，也就是只做加法运算。就像用钢笔描绘人脸，先有眼睛，鼻子，再加上嘴等等。这些都是一个一个添加的。（非负好比用钢笔作画不能删除， 而普通作画是用铅笔， 所以可以有负值）</p><p>如果也用减法，就像用铅笔，还可以用橡皮擦去一些地方。</p></li></ol><h3 id="基于玻尔兹曼机器学习的图像处理方法"><a class="markdownIt-Anchor" href="#基于玻尔兹曼机器学习的图像处理方法"></a> 基于玻尔兹曼机器学习的图像处理方法</h3><blockquote><p>首先要明确的一点是， 图片是由像素组成的。每一个像素到底是呈现数模颜色，这是由数据来决定的。</p></blockquote><ol><li><p><strong>玻尔兹曼机器学习</strong>:将图像的颜色数据输入到玻尔兹曼机中，计算机通过分析这些数据，就可以得到实际图像的特征，各像素点显示某种颜色的概率，以及<strong>相邻像素间的关系</strong>。这种过程叫做玻尔兹曼机器学习。</p></li><li><p><strong>似然度</strong>： 相似的程度。 机器学习的目的要么是让误差值最小，要么是让似然度最大</p></li><li><p><strong>采样</strong>：将实际提供的数据输入到玻尔兹曼机后， 模型会输出伪数据（重构数据）， 这个自身不断<strong>产生数据</strong>的过程就叫做采样 sampling</p><p>玻尔兹曼机器学习在进行时，采用马尔科夫蒙特卡罗方法，来逐一考虑相邻像素之间的关系，来完成双向型神经网络的信息流动。这是一种在整个网络结构中的循环，<u>在这一过程中还要不断地采集大量的重构数据。很费时间</u>。==&gt; 替代算法是，单纯考虑由相邻像素传送过来的信息，<strong>平均场近似法</strong></p><p><img src="/2020/11/28/《漫画机器学习入门》大关真之——读书笔记/hexo/source/_posts/%E6%BC%AB%E7%94%BB%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E5%A4%A7%E5%85%B3%E7%9C%9F%E4%B9%8B%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/1.jpg" alt="平均近场法"></p></li><li><p>中间结果包含每一个像素颜色的变化过程，也能够构成中间过程的许多图像。这些中间产生的图像数据就是重构数据， 也可以叫做伪数据。其实核心就是“依据临近像素的数据， 在现有的参数值情况下， 预测中心像素的颜色值”</p></li><li><p>机器学习与统计力学： 我们在研究原子和分子的时候， 位置、运动扽信息是分析研究的对象， 但是统计力学有趣的地方是利用统计学理论去获取事物整体的特征。类比机器学习， 就像我们并不去计较每一个颗粒的位置和速度， 对于机器学习我们也是希望得到大量数据间的整体组合信息， 这种整体组合信息在最优化问题求解时就是推到出函数模型</p></li><li><p>可见变量、隐含变量：在图像中， 每一个像素颜色的数值时可以直接读取的， 这一部分就叫做可见变量。由可见变量之间关联关系构成的新变量称为隐含变量， 从而可以建立出眼睛、鼻子等部件， 从而将利用各个部件就可以将图像分成各个部分了。 利用上述方式就可以以“开关”的形式来操作了，通过像素和开关之间的关系就可以决定在可见变量一侧表示出什么， 这种方法认为可见变量之间没有任何关系， 各个开关之间也没有关联。只考虑开关与像素之间的关系， 叫做受限玻尔兹曼机（RBM）， 有较好的特性， 如一定条件下的独立性</p></li><li><p><strong>变分原理</strong>：物理学中， 指自然界中静止实物的一个普遍适用的数学定律，也称最小作用原理。比如在确定了物体的起点和终点后， 通过动能和势能之差就能计算出最短路径。</p></li><li><p><strong>对比散度算法</strong>：将实际的颜色数据与建立的模型采集到的伪数据进行比较， 我们希望能够从中找到某些有用的东西。</p></li><li><p><img src="https://img-blog.csdnimg.cn/20191022114125126.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTUxMzkxNw==,size_16,color_FFFFFF,t_70" alt=""></p><p>深度玻尔兹曼机将图像数据作为输入， 内部作为隐含变量的各种开关来决定到底输出什么图像， 因此为了能够对应不同的图像， 建立数量巨大的复杂的隐含变量时非常必要的——深度玻尔兹曼机的目的时<strong>学习图像中隐含的特征</strong>， 知道了图像中拥有的特征可以就可以返回来看可见变量中是否有猫和狗了——传统机器学习和深度学习的区别也在于此， 传统机器学习需要自己手动提取特征（特征工程）， 而神经网络可以自己提取特征。</p></li><li><p>受限玻尔兹曼机是两层神经网络。包含输入层，隐藏层，输出层</p></li><li><p>预训练： ①运用在无监督学习中， 不告诉model特征有哪些 ②用预训练网络做微调：一般图片分类的神经网络每一类别的图片量级至少在5000-10000左右，如果没有这么多图片，（使用数据增强的方法后也不够），此时就需要用预训练网络了（在几十万张图片训练集上获得较好效果的图片多分类器）。然后用我们现有的图片在这个预训练网络的基础上继续训练， 利用现有的图片继续训练就是为了让网络重新适应现有的图片训练集， 这种适应过程往往比从头训练一个网络更快更好， 这种方法跟迁移学习的思想很像。</p></li><li><p>自我符号化（在无监督学习中具有代表性）：吧收到的输入信号原原本本地返回来。</p></li></ol><p><img src="/2020/11/28/《漫画机器学习入门》大关真之——读书笔记/hexo/source/_posts/%E6%BC%AB%E7%94%BB%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E5%A4%A7%E5%85%B3%E7%9C%9F%E4%B9%8B%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%87%AA%E6%88%91%E7%AC%A6%E5%8F%B7%E5%8C%96.jpg" alt="自我符号化"></p><p>注意， 左右知识结构上的复制，权值是不一样的。这些权值是需要进行调整后才能满足右边的“输入”等于左边输入的。在这个调整权值的过程中，输入数据所隐含的特征就可以被挖掘出来了。<mark>&gt;从而使得中间层具有能够反映输入数据中特征的能力。</mark>&gt; 中间层的自我符号化训练其实也是提取特征的过程</p><ol start="13"><li><p>卷积神经网络：</p><blockquote><p>在处理图像时已有已知的神经网络可以利用了——卷积神经网络。</p></blockquote><p><strong>卷积</strong>：卷积是利用了，人在看见图像识别图像时并不需要将所有的细小像素全部看清的特征而设计的。卷积就是在某种程度上将临近的像素组合起来形成新的特征量，然后利用卷积结果进行分析</p><p><strong>池化</strong>：在图片中即使模糊我们也能通过模糊的影像大致判断出—&gt;数据即使有些差异也能够得出同样的结果。因此可以利用卷积将特征进行排序，将相近的特征进行比较并选用其中的最大值或平均值，叫做池化</p><p>▲通过卷积和池化操作，神经网络从而可以将图像中的特征量自动地提取出来了。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;漫画机器学习入门总结&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#漫画机器学习入门总结&quot;&gt;&lt;/a&gt; 《漫画机器学习入门》总结&lt;/h1&gt;
&lt;p&gt;机器学习是指计算机通过不断地处理数据并修正算法和参数来学习各种规则， 从而不断改进模型而得到
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://nymrli.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="读书笔记" scheme="https://nymrli.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器同步时钟</title>
    <link href="https://nymrli.top/2020/11/22/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8C%E6%AD%A5%E6%97%B6%E9%92%9F/"/>
    <id>https://nymrli.top/2020/11/22/Linux服务器同步时钟/</id>
    <published>2020-11-22T04:49:35.000Z</published>
    <updated>2020-11-22T04:50:08.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><blockquote><p>因为今天在集群193跑程序的时候发现时间不同步, 因此想想把集群的时间全部同步一下</p></blockquote><ol><li><p>在Linux中设置系统时间，可以用date命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看时间</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> date</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改时间</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> date -s <span class="string">"20140225 20:16:00"</span>  <span class="comment">#yyyymmdd hh:mm:ss</span></span></span><br></pre></td></tr></table></figure></li><li><p>Linux硬件时间的设置</p></li></ol><p>硬件时间的设置，可以用hwclock或者clock命令。两者基本相同，只用一个就行，只不过clock命令除了支持x86硬件体系外，还支持Alpha硬件体系。</p><ol start="3"><li>系统时间和硬件时间的同步</li></ol><p>同步系统时间和硬件时间，可以使用hwclock命令。</p><p><strong>4. 不同机器之间的时间同步</strong></p><p>为了避免主机时间因为长期运行下所导致的时间偏差，进行时间同步（synchronize）的工作是非常必要的。Linux系统下，一般使用ntp服务器来同步不同机器的时间。一台机器，可以同时是ntp服务端和ntp客户端。在生产系统中，推荐使用像DNS服务器一样分层的时间服务器来同步时间。</p><p>不同机器间同步时间，可以使用ntpdate命令，也可以使用ntpd服务。==&gt;▲. 注意两个不能同时使用: 如果使用了ntpd后还是用ntpdate会报错<code>ntpdate[39462]: the NTP socket is in use, exiting</code>, 要查询ntp的状态，用ntpq命令，比如看目前是否和ntp server同步，用<code>ntpq -p</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">     remote           refid      st t when poll reach   delay   offset  jitter</span><br><span class="line">==============================================================================</span><br><span class="line"> 0.ubuntu.pool.n .POOL.          16 p    -   64    0    0.000    0.000   0.000</span><br><span class="line"> 1.ubuntu.pool.n .POOL.          16 p    -   64    0    0.000    0.000   0.000</span><br><span class="line"> 2.ubuntu.pool.n .POOL.          16 p    -   64    0    0.000    0.000   0.000</span><br><span class="line"> 3.ubuntu.pool.n .POOL.          16 p    -   64    0    0.000    0.000   0.000</span><br><span class="line"> ntp.ubuntu.com  .POOL.          16 p    -   64    0    0.000    0.000   0.000</span><br><span class="line"> ntp1.ams1.nl.le 130.133.1.10     2 u    1   64    1  305.632  -43.387   0.146</span><br><span class="line">*120.25.115.20   10.137.53.7      2 u    1   64    1   29.425   -1.059   0.410</span><br><span class="line"> 203.107.6.88    100.107.25.114   2 u    1   64    1   32.056   -2.093   0.257</span><br><span class="line"> ntp.xtom.nl     84.199.11.211    2 u    1   64    1  175.286   -6.179   0.210</span><br><span class="line"> 94.130.49.186 ( 195.13.23.5      3 u    2   64    1  212.348  -17.943   0.561</span><br><span class="line"> tock.ntp.infoma .GPS.            1 u    2   64    1  239.693  -11.135   0.175</span><br><span class="line"> 119.28.206.193  100.122.36.196   2 u    -   64    1   41.525   -4.034   0.002</span><br></pre></td></tr></table></figure><p>可以看到*号标出的就是集群正在同步的时钟服务器: 120.25.115.20是阿里云</p><p>由于不能同时使用， 而ntpdate的稳定性不好， 因此ntpdate用来一次性同步时间（或者ntpdate+cron组合）、或者用ntpdate同步一次时间后，持续用ntpd服务器来同步。</p><p>下面使用ntpdate来同步时间：使用ntpdate前, 先将ntpd关闭: <code>service ntpd stop</code>或<code>sudo systemctl stop ntp</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">  /usr/sbin/ntpdate  time.stdtime.gov.tw</span></span><br><span class="line">Error : Temporary failure in name resolution</span><br><span class="line">29 Oct 14:18:59 ntpdate[25327]: can't find host time.stdtime.gov.tw</span><br><span class="line">29 Oct 14:18:59 ntpdate[25327]: no servers can be used, exiting</span><br></pre></td></tr></table></figure><p>确认防火墙没有问题后，执行域名解析，发现失败</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nslookup  time.stdtime.gov.tw</span></span><br><span class="line">;; connection timed out; no servers could be reached</span><br></pre></td></tr></table></figure><p>尝试ping外网，以确认能正常连到外网，连网正常</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ping 8.8.8.8</span></span><br><span class="line">PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.</span><br><span class="line">64 bytes from 8.8.8.8: icmp_seq=1 ttl=53 time=1.48 ms</span><br><span class="line">64 bytes from 8.8.8.8: icmp_seq=2 ttl=53 time=1.40 ms</span><br><span class="line">--- 8.8.8.8 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1000ms</span><br><span class="line">rtt min/avg/max/mdev = 1.404/1.445/1.487/0.056 ms</span><br></pre></td></tr></table></figure><p>于是修改DNS文件, /etc/resolv.conf, 虽然这边提示不要手动修改, 但是临时改掉是没问题的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Dynamic resolv.conf(5) file <span class="keyword">for</span> glibc resolver(3) generated by resolvconf(8)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN</span></span><br><span class="line"><span class="meta">#</span><span class="bash">nameserver 127.0.1.1</span></span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>修改后，再次执行时间同步，ok鸟！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apollo3d@apollo15:~/cl/Python_project/cplm/Min38$ sudo ntpdate ntp1.aliyun.com</span><br><span class="line">21 Nov 23:04:25 ntpdate[40285]: adjust time server 120.25.115.20 offset 0.002194 se</span><br></pre></td></tr></table></figure><p>除了阿里云的还有pool.ntp.org可以用来同步。</p><p>▲但是同步之后时间还是不太对， 于是观察时区， 发现集群两台电脑上其实只是时区是不同的， 同步的服务器都是一样的阿里云的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apollo3d@apollo2:~$ date</span><br><span class="line">2020年 11月 22日 星期日 12:14:11 CST</span><br><span class="line"></span><br><span class="line">apollo3d@apollo15:~/cl/Python_project/cplm/Min38$ date</span><br><span class="line">Sat Nov 21 23:14:01 EST 2020</span><br></pre></td></tr></table></figure><p>发现一个是EST和CST。网上查询得知 EST代表英国时间, CST代表北京时间, EDT：指美国东部夏令时间</p><p>那么现在只要改成北京时间的时区CST就可以了，修改如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mv /etc/localtime /etc/localtime.bak</span><br><span class="line">[root@localhost ~]# ln -s /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime</span><br><span class="line">[root@localhost ~]# date</span><br></pre></td></tr></table></figure><p>但是发现两台语言不一样, 一个是中文, 一个是英文, 猜测是操作系统中英版导致的: 输出环境变量:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apollo3d@apollo2:~$ date</span><br><span class="line">2020年 11月 22日 星期日 12:14:11 CST</span><br><span class="line"><span class="meta">$</span><span class="bash"> env</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到时区是中国</span></span><br><span class="line">HOME=/home/apollo3d</span><br><span class="line">LOGNAME=apollo3d</span><br><span class="line">LESSCLOSE=/usr/bin/lesspipe %s %s</span><br><span class="line">LC_TIME=zh_CN.UTF-8</span><br><span class="line">LC_NAME=zh_CN.UTF-8</span><br><span class="line">_=/usr/bin/env</span><br><span class="line"></span><br><span class="line">apollo3d@apollo15:~/cl/Python_project/cplm/Min38$ date</span><br><span class="line">Sat Nov 21 23:14:01 EST 2020</span><br><span class="line"><span class="meta">$</span><span class="bash"> env</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到语言是en_US, 但是没设置时区</span></span><br><span class="line">MAIL=/var/mail/apollo3d</span><br><span class="line">PWD=/home/apollo3d/cl/Python_project/cplm/Min38</span><br><span class="line">JAVA_HOME=/home/apollo3d/Apollo_Rescue/jdk1.8.0_161</span><br><span class="line">LANG=en_US.UTF-8</span><br><span class="line">HOME=/home/apollo3d</span><br><span class="line">SUDO_COMMAND=/bin/su</span><br></pre></td></tr></table></figure><p>因此可以修改LANG:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/sysconfig/i18n</span></span><br><span class="line">LANG="en_US.UTF-8"改为LANG="zh_CN.GB2312"</span><br></pre></td></tr></table></figure><p>再运行我的Python脚本的时候发现竟然报错了: ValueError: Timezone offset does not match system offset: -18000 != 28800. Please, check your config files.</p><p>因为系统时区和代码运行时区不一样导致。解决办法：在创建BlockingScheduler对象时指定上海的时区<code>scheduler = BlockingScheduler(timezone=&quot;Asia/Shanghai&quot;)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#&quot;&gt;&lt;/a&gt; &lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;因为今天在集群193跑程序的时候发现时间不同步, 因此想想把集群的时间全部同步一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;

      
    
    </summary>
    
    
      <category term="Linux" scheme="https://nymrli.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>JupyterHub搭建</title>
    <link href="https://nymrli.top/2020/11/15/JupyterHub%E6%90%AD%E5%BB%BA/"/>
    <id>https://nymrli.top/2020/11/15/JupyterHub搭建/</id>
    <published>2020-11-15T14:08:52.000Z</published>
    <updated>2020-11-20T05:59:09.392Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前搭建的JupyterLab逐渐被使用起来了, 单用户的模式还是不太方便, 因此准备用JupyterHub来做下用户隔离</p></blockquote><h2 id="1-安装nodejs和npm"><a class="markdownIt-Anchor" href="#1-安装nodejs和npm"></a> 1. 安装nodejs和npm</h2><p>按照<a href="https://gitee.com/mirrors/JupyterHub#installation" target="_blank" rel="noopener">JupyterLab官方教程</a>, 先是安装最新的nodejs和npm, 但是由于16.04的apt源安装的nodejs版本比较久, 因此在后面的安装中会有坑, 这边根据网上的教程手动安装最新的nodejs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install -y nodejs</span></span><br></pre></td></tr></table></figure><p>安装成功后输入<code>node --version</code>看到有版本返回输出证明安装成功, 同时这种方式会同时安装npm, 同样<code>npm --version</code>测试npm安装成功</p><h2 id="2-安装"><a class="markdownIt-Anchor" href="#2-安装"></a> 2. 安装</h2><h3 id="21-安装虚拟环境"><a class="markdownIt-Anchor" href="#21-安装虚拟环境"></a> 2.1 安装虚拟环境</h3><p>由于我个人喜欢自己配置虚拟环境, 因此, 我先安装虚拟环境。但阿里云上的virtualenv太久不用，版本太老了， 出现了<code>使用virtualenv创建虚拟环境报错 error code 2</code>现象，因此通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install setuptools #安装setuptools</span><br><span class="line">sudo pip install --upgrade setuptools #更新setuptools到最新版本</span><br><span class="line">sudo pip install virtualenv #安装virtualenv</span><br><span class="line">sudo pip install --upgrade virtualenv   #更新virtualenv到最新版本</span><br></pre></td></tr></table></figure><p>来更新setuptools和virtualenv到最新的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> virtualenv mlEnv</span></span><br></pre></td></tr></table></figure><h3 id="22-安装jupyterhub"><a class="markdownIt-Anchor" href="#22-安装jupyterhub"></a> 2.2 安装jupyterhub</h3><p>根据官方教程，有两种方式安装：pip 安装 ; conda安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pip安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python3 -m pip install jupyterhub</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo npm install -g configurable-http-proxy</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python3 -m pip install notebook  <span class="comment"># needed if running the notebook servers locally</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> conda安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda install -c conda-forge jupyterhub  <span class="comment"># installs jupyterhub and proxy</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda install notebook  <span class="comment"># needed if running the notebook servers locally</span></span></span><br></pre></td></tr></table></figure><h4 id="221-问题1_虚拟环境"><a class="markdownIt-Anchor" href="#221-问题1_虚拟环境"></a> 2.2.1 问题1_虚拟环境</h4><p>但在安装过程中出现了以下报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Could not install packages due to an EnvironmentError: [Errno 13] Permission denied: '/home/mrli/MLproject/mlEnv/lib/python3.5/site-packages/idna'</span><br><span class="line">Consider using the `--user` option or check the permissions.</span><br></pre></td></tr></table></figure><p>通过<code>which pip</code>可以看到我使用的pip正是虚拟环境下的pip, 同时提示中的site-packages文件夹也是存在的。便按照提示加上了–user， 但是出现了如下新报错<code>ERROR: Can not perform a '--user' install. User site-packages are not visible in this virtualenv.</code> (注意, 不用加sudo来保证权限, 应为加上sudo pip吧库安装到的路径是在root下的)</p><p>经过查询发现, 是因为整个虚拟环境下的权限不够, 因此需要加权<code>sudo chmod 777 -R mlEnv</code>=&gt;遂问题解决</p><p><a href="https://www.cnblogs.com/duaimili/p/10279067.html" target="_blank" rel="noopener">永久更改pip源和创建虚拟环境</a></p><h4 id="222-问题2_npm安装报错"><a class="markdownIt-Anchor" href="#222-问题2_npm安装报错"></a> 2.2.2 问题2_npm安装报错</h4><p>执行<code>sudo npm install -g configurable-http-proxy</code>时有如下报错<code>Error: EACCES: permission denied, access '/usr/lib/node_modules'</code>已经加上了sudo也无济于事。</p><p>==&gt; 通过node的npm无法安装（无法过墙），也可以用阿里的自己的cnpm进行安装<code>sudo npm install -g cnpm --registry=https://registry.npm.taobao.org</code>,然后再输入<code>sudo cnpm install -g configurable-http-proxy</code>–&gt;解决!</p><h2 id="3-测试安装成功"><a class="markdownIt-Anchor" href="#3-测试安装成功"></a> 3. 测试安装成功</h2><ol><li><code>jupyterhub -h</code>、 <code>configurable-http-proxy -h</code>查看是否有输出,</li><li><code>jupyterhub</code>然后在https://localhost:8000中查看</li></ol><h2 id="4-配置"><a class="markdownIt-Anchor" href="#4-配置"></a> 4. 配置</h2><h4 id="生成配置文件"><a class="markdownIt-Anchor" href="#生成配置文件"></a> 生成配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jupyterhub --generate-config -f /etc/jupyterhub/jupyterhub_config.py</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jupyterhub --generate-config <span class="comment"># 会在你的当前目录下生成一个jupyterhub_config.py文件, 我们在其中配置我们的网络和用户管理</span></span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c.JupyterHub.ip = <span class="string">'192.168.2.4'</span><span class="comment"># 本机局域网的ip，记得是局域网</span></span><br><span class="line">c.JupyterHub.port = <span class="number">12443</span><span class="comment"># 指定服务端口</span></span><br><span class="line">c.Spawner.ip = <span class="string">'127.0.0.1'</span></span><br><span class="line">c.PAMAuthenticator.encoding = <span class="string">'utf8'</span></span><br><span class="line">c.Authenticator.whitelist = &#123;<span class="string">'root'</span>,<span class="string">'admin'</span>, <span class="string">'tv'</span>, <span class="string">'aiker'</span>&#125;  <span class="comment">#默认不能使用root登录，需要修改配置. 这里面需要将linux的用户名添加进入，这样该用户就可以通过浏览器利用linux的用户名和密码登录自己的账户，jupyterhub采用和linux系统相同的认证方式，所以我们不需要另外建立用户，只需要登录linux的用户和密码即可 ==&gt; 用户白名单的用户会自动添加，但无密. 需要修改密需要创建linux用户才能登录；</span></span><br><span class="line">c.LocalAuthenticator.create_system_users = <span class="keyword">True</span></span><br><span class="line">c.Authenticator.admin_users = &#123;<span class="string">'root'</span>, <span class="string">'admin'</span>&#125;<span class="comment"># 指定admin用户</span></span><br><span class="line">c.JupyterHub.authenticator_class = <span class="string">'dummyauthenticator.DummyAuthenticator'</span></span><br><span class="line">c.JupyterHub.statsd_prefix = <span class="string">'jupyterhub</span></span><br><span class="line"><span class="string">c.Spawner.notebook_dir = '</span>/volume1/study/<span class="string">' #jupyterhub自定义目录</span></span><br><span class="line"><span class="string">c.JupyterHub.statsd_prefix = '</span>jupyterhu<span class="string">b'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">c.JupyterHub.ssl_cert = '</span>/usr/syno/etc/certificate/_archive/xYa1nX/fullchain.pem<span class="string">'</span></span><br><span class="line"><span class="string">c.JupyterHub.ssl_key = '</span>/usr/syno/etc/certificate/_archive/xYa1nX/privkey.pem<span class="string">'</span></span><br></pre></td></tr></table></figure><p>默认情况下，要真正的实现分配用户账号，需要满足以下两点要求：</p><ol><li>c.Authenticator.whitelist 指定了用户名</li><li>在系统中创建了该用户（adduser / useradd）</li></ol><p>tips: 默认情况下，密码为系统中该用户对应的密码</p><p>用户管理<br>用户白名单的用户会自动添加，但无密码，需要修改密码才能登录；<br>新添加用户：useradd crxis -d /home/user/crxis -m<br>用户添加组：adduser crxis group1<br>修改用户密码：echo crxis:crxis|chpasswd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c.JupyterHub.admin_users = &#123;&apos;root&apos;, &apos;admin&apos;&#125;</span><br><span class="line">c.JupyterHub.bind_url = &apos;http://127.0.0.1:22223&apos;</span><br><span class="line">c.JupyterHub.hub_bind_url = &apos;http://127.0.0.1:22224&apos;</span><br><span class="line">c.JupyterHub.hub_port = 22225</span><br><span class="line">c.Authenticator.whitelist = &#123;&apos;root&apos;, &apos;mrli&apos;&#125;</span><br><span class="line">c.JupyterHub.hub_port = 22226</span><br></pre></td></tr></table></figure><h2 id="5-运行"><a class="markdownIt-Anchor" href="#5-运行"></a> 5. 运行</h2><p>在存放<code>jupyterhub_config.py</code>的文件夹下执行<code>jupyterhub</code>启动服务</p><p>配置查看: <a href="https://blog.51cto.com/m51cto/2370679%E2%80%94%E2%80%94GPU%E5%9D%91" target="_blank" rel="noopener">https://blog.51cto.com/m51cto/2370679——GPU坑</a>, 配置github登入</p><h2 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录:</h2><h3 id="修改pip默认源"><a class="markdownIt-Anchor" href="#修改pip默认源"></a> 修改pip默认源:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim ~/.pip/pip.conf <span class="comment"># 如果当前用户没有.pip文件夹, 则创建一个</span></span></span><br></pre></td></tr></table></figure><p>添加下列内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = http://pypi.douban.com/simple</span><br><span class="line">[install]</span><br><span class="line">use-mirrors =true</span><br><span class="line">mirrors =http://pypi.douban.com/simple/</span><br><span class="line">trusted-host =pypi.douban.com</span><br></pre></td></tr></table></figure><h3 id="linux上安装最新版的python"><a class="markdownIt-Anchor" href="#linux上安装最新版的python"></a> Linux上安装最新版的Python</h3><ol><li><p>查看 Python 的版本号：<code>python2 -V</code>, <code>python3 -V</code></p></li><li><p>下载3.x新版本</p><p>可以访问python的官方网站查看最新的python版本以及下载链接：<a href="https://www.python.org/downloads/%EF%BC%8C%E5%B0%86%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%88%B0%E6%83%B3%E8%A6%81%E5%AE%98%E7%BD%91%E4%B8%8A%E6%83%B3%E8%A6%81%E4%B8%8B%E8%BD%BD%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7%E4%B8%8A%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%BE%8B%E5%A6%82%E6%88%91%E9%9C%80%E8%A6%81%E5%9C%A8Linux%E4%B8%8B%E5%AE%89%E8%A3%85%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz%EF%BC%88%E5%A6%82%E6%9E%9C%E6%83%B3%E8%A6%81%E4%B8%8B%E8%BD%BD%E5%85%B6%E4%BB%96%E7%89%88%E6%9C%AC%EF%BC%8C%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E7%89%88%E6%9C%AC%E5%8F%B7%E5%8D%B3%E5%8F%AF%EF%BC%89%E3%80%82%E6%89%BE%E5%88%B0%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E5%90%8E%EF%BC%8C%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%85%A5%EF%BC%9A" target="_blank" rel="noopener">https://www.python.org/downloads/，将鼠标移到想要官网上想要下载的版本号上就可以看到下载地址，例如我需要在Linux下安装，可以使用这个链接：https://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz（如果想要下载其他版本，直接修改版本号即可）。找到下载地址后，在命令行输入：</a><code>wget https://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz</code></p></li><li><p>下载完成后解压缩<code>tar -zxvf Python-3.8.5.tgz</code></p></li><li><p>下载完成后解压缩<code>cd Python-3.8.5/; ./configure</code>,</p></li></ol><p>由于使用3.8出现了virtualenv无法使用的情况, 因此需要对配置文件进行修改: 修改<code>Python-3.8.5/Modules</code>路径的<code>Setup</code>文件: <code>sudo vim Setup</code>:</p><p><img src="https://img-blog.csdnimg.cn/20190916154900762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzODg5MDA5,size_16,color_FFFFFF,t_70" alt=""></p><ol start="5"><li>编译<code>sudo make; sudo make install</code></li></ol><p>但是发现修改后报错缺少xxssl.h的头文件,</p><ul><li><code>wget https://www.openssl.org/source/openssl-1.0.2h.tar.gz</code></li><li><code>tar zxf openssl-1.0.2h.tar.gz; cd openssl-1.0.2h</code></li><li><code>./config shared zlib; make depend</code></li><li><code>sudo make; sudo make install</code></li><li>检测是否安装成功: <code>openssl version -a</code></li></ul><p>▲.再次到python中make install, 报错: subprocess.CalledProcessError: Command ‘(‘lsb_release’, ‘-a’)’ returned non-zero exit status 1.</p><p>解决方法<br>find /usr/bin -name lsb_release<br>sudo rm -rf /usr/bin/lsb_release</p><p>此时再到Python/中make install即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;之前搭建的JupyterLab逐渐被使用起来了, 单用户的模式还是不太方便, 因此准备用JupyterHub来做下用户隔离&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-安装nodejs和npm&quot;&gt;&lt;a class=&quot;markdownIt
      
    
    </summary>
    
    
      <category term="环境配置" scheme="https://nymrli.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>南邮校园网CSDN等部分网站图片无法加载解决方案</title>
    <link href="https://nymrli.top/2020/11/10/%E5%8D%97%E9%82%AE%E6%A0%A1%E5%9B%AD%E7%BD%91CSDN%E7%AD%89%E9%83%A8%E5%88%86%E7%BD%91%E7%AB%99%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://nymrli.top/2020/11/10/南邮校园网CSDN等部分网站图片无法加载解决方案/</id>
    <published>2020-11-10T10:14:56.000Z</published>
    <updated>2020-11-10T10:28:28.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题定位"><a class="markdownIt-Anchor" href="#问题定位"></a> 问题定位</h2><p>转自： <a href="https://blog.csdn.net/pamzerbhu/article/details/108549279" target="_blank" rel="noopener">https://blog.csdn.net/pamzerbhu/article/details/108549279</a></p><ul><li>用语言描述如下：<br>打开页面后页面加载正常，但是图片完全没有加载。但是挂全局代理是可以看到图片的。挂代理后如下所示：</li></ul><p><img src="/2020/11/10/南邮校园网CSDN等部分网站图片无法加载解决方案/%E5%9B%BE%E7%89%87.jpg" alt="图片"></p><ul><li>开始定位问题：</li><li>点击审查元素，接着找到我这张图的链接，直接用浏览器打开，报错<code>**NET::ERR_CERT_COMMON_NAME_INVALID**</code></li></ul><p><img src="https://img-blog.csdnimg.cn/20200912143542354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbXplcmJodQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>然后点击 高级–继续访问 <a href="http://img-blog.csdn.net" target="_blank" rel="noopener">img-blog.csdn.net</a> (不安全)</li><li>图片成功加载：<br><img src="https://img-blog.csdnimg.cn/20200912144157460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbXplcmJodQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul><p>好了，找到了问题。接下来就是面向搜索引擎的找方法时间。</p><p>经过查询发现是DNS的问题（或者可以打开cmd，然后输入ipconfig/all看DNS地址）：</p><p><img src="/2020/11/10/南邮校园网CSDN等部分网站图片无法加载解决方案/%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E5%B1%9E%E6%80%A7.jpg" alt="查看网络属性"></p><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><p>我们尝试修改dns，并刷新。 <a href="https://jingyan.baidu.com/article/b87fe19e4e1faf5218356839.html" target="_blank" rel="noopener">修改教程点我</a>.</p><p><img src="/2020/11/10/南邮校园网CSDN等部分网站图片无法加载解决方案/%E4%BF%AE%E6%94%B9DNS.jpg" alt="修改DNS"></p><p>再次查看确认已经不再是坑爹的南邮DNS了。访问csdn发现一切正常。OK结束。</p><h2 id="err_cert_common_name_invalid"><a class="markdownIt-Anchor" href="#err_cert_common_name_invalid"></a> ERR_CERT_COMMON_NAME_INVALID</h2><p>实际上，可以认为，ERR_CERT_COMMON_NAME_INVALID就是用一个错误的域名访问了某个节点的https资源。导致这个错误的原因，基本是</p><ol><li>dns污染</li><li>host设置错误</li><li>官方更新了dns，但是dns缓存没有被更新，导致错误解析。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题定位&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题定位&quot;&gt;&lt;/a&gt; 问题定位&lt;/h2&gt;
&lt;p&gt;转自： &lt;a href=&quot;https://blog.csdn.net/pamzerbhu/article/details/10854
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>scrcpy+AutoJS</title>
    <link href="https://nymrli.top/2020/11/09/scrcpy-AutoJS/"/>
    <id>https://nymrli.top/2020/11/09/scrcpy-AutoJS/</id>
    <published>2020-11-09T03:26:19.000Z</published>
    <updated>2020-11-14T07:17:12.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="scrcpy简介"><a class="markdownIt-Anchor" href="#scrcpy简介"></a> scrcpy简介</h2><blockquote><p><strong>特点:</strong><br>利用电脑的键盘和鼠标可以控制手机。把 APK 文件拖拽到电脑窗口即可安装应用到手机，把普通文件拖拽到窗口即可复制到手机。<br>不需要在手机上安装任何应用。</p></blockquote><p>简单地来说，scrcpy就是通过adb调试的方式来将手机屏幕投到电脑上，并可以通过电脑控制您的Android设备。它可以通过USB连接，也可以通过Wifi连接（类似于隔空投屏），而且不需要任何root权限，不需要在手机里安装任何程序。scrcpy同时适用于GNU / Linux，Windows和macOS。</p><p>它的一些特性：</p><ul><li>亮度（原生，仅显示设备屏幕）</li><li>性能（30~60fps）</li><li>质量（1920×1080或以上）</li><li>低延迟（35~70ms）</li><li>启动时间短（显示第一张图像约1秒）</li><li>非侵入性（设备上没有安装任何东西）</li></ul><p>此项目为开源项目，Github地址：<a href="https://github.com/Genymobile/scrcpy" target="_blank" rel="noopener">Genymobile/scrcpy: Display and control your Android device</a></p><h3 id="使用scrcpy的要求"><a class="markdownIt-Anchor" href="#使用scrcpy的要求"></a> 使用scrcpy的要求</h3><ol><li>Android设备至少需要API 21（Android 5.0以上版本）;</li><li>确保在您的设备上启用了<a href="https://developer.android.com/studio/command-line/adb.html#Enabling" target="_blank" rel="noopener">adb调试</a>;</li><li>在某些设备上，您还需要启用<a href="https://github.com/Genymobile/scrcpy/issues/70#issuecomment-373286323" target="_blank" rel="noopener">其他选项</a>以使用键盘和鼠标控制它。</li></ol><p>adb调试的开启一般是多次点击手机系统版本，如我用的是MIUI10，开启方法是 “设置”-&gt;“我的设备”-&gt;“全部参数”-&gt;点击7下MIUI版本，开启“开发者选项”。然后在 “设置”-&gt;“更多设置”-&gt;“开发者选项” 中同时开启 <code>USB调试</code> 和 <code>USB调试(安全设置)</code>。</p><h3 id="使用说明"><a class="markdownIt-Anchor" href="#使用说明"></a> 使用说明</h3><blockquote><p>程序使用了Java语言，我们需要在电脑中搭建Java运行环境，参考：<a href="https://blog.csdn.net/sigmarising/article/details/80139287" target="_blank" rel="noopener">Windows10 配置 Java 开发环境</a></p></blockquote><h4 id="使用usb进行连接"><a class="markdownIt-Anchor" href="#使用usb进行连接"></a> 使用USB进行连接</h4><p>此方式推荐使用，相对更加流畅。</p><ol><li>手机通过USB连接到PC上，首次连接会弹出是否信任该电脑，点击始终信任即可。</li><li>运行<code>adb usb</code>查看是否连接成功</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\Github_Run\scrcpy-win64-v1.10&gt;adb usb</span><br><span class="line">restarting in USB mode</span><br></pre></td></tr></table></figure><ol start="3"><li>运行<code>scrcpy</code>即可。</li></ol><h4 id="使用无线连接"><a class="markdownIt-Anchor" href="#使用无线连接"></a> 使用无线连接</h4><blockquote><p>可参考官方文档：<a href="https://www.genymotion.com/blog/open-source-project-scrcpy-now-works-wirelessly/" target="_blank" rel="noopener">Open Source Project - Scrcpy now works wirelessly</a></p></blockquote><p>此连接方式更加方便快捷，若宽带速率高，使用效果更佳，使用方法也非常简单。</p><ol><li>确保PC和手机在同一Wifi中</li><li>手机先通过USB与PC相连</li><li>在PC上运行 adb tcpip 服务端口，如端口为5555</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\Github_Run\scrcpy-win64-v1.10&gt;adb tcpip 5555</span><br><span class="line">restarting in TCP mode port: 5555</span><br></pre></td></tr></table></figure><ol><li>拔下你的设备，断开USB连接</li><li>在PC上运行 adb connect 手机IP:服务端口（手机IP可通过手机的<code>状态信息</code>查看，或者登录路由器查看，一般以192.168开头）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\Github_Run\scrcpy-win64-v1.10&gt;adb connect 192.168.0.4:5555</span><br><span class="line">connected to 192.168.0.4:5555</span><br></pre></td></tr></table></figure><ol start="3"><li>运行scrcpy，在cmd中输入<code>scrcpy.exe</code>即可</li></ol><p>注: 若要切换回USB模式：<code>adb usb</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 附调节比特率和分辨率</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scrcpy --bit-rate 2M --max-size 800</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者简写</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scrcpy -b2M -m800</span></span><br></pre></td></tr></table></figure><h2 id="autojs"><a class="markdownIt-Anchor" href="#autojs"></a> AutoJS</h2><blockquote><p>一个支持无障碍服务的Android平台上的JavaScript IDE，其发展目标是JsBox和Workflow。<br>Auto.js使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">JavaScript</a>作为脚本语言，目前使用<a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Projects/Rhino" target="_blank" rel="noopener">Rhino 1.7.7.2</a>作为脚本引擎，支持ES5与部分ES6特性。</p><p>官方教程: <a href="https://hyb1996.github.io/AutoJs-Docs/#/?id=autojs" target="_blank" rel="noopener">https://hyb1996.github.io/AutoJs-Docs/#/?id=autojs</a><br>使用教程视频: <a href="https://space.bilibili.com/21486893/video" target="_blank" rel="noopener"><strong>笔青居</strong></a></p></blockquote><h3 id="如何连接"><a class="markdownIt-Anchor" href="#如何连接"></a> 如何连接?</h3><p><strong>手机安装使用步骤：</strong></p><p>① 开启无障碍服务<br>② 音量上键停止脚本：当脚本处于无法停止的状态时，使用音量上键强制停止脚本。<br>③ 开启悬浮窗：<br>④ 连接手机(如果不习惯在手机上coding, 可以安装作者提供的VsCode插件, 在Vscode上编码: <a href="https://github.com/hyb1996/Auto.js-VSCode-Extension" target="_blank" rel="noopener">Auto.js-VSCodeExt</a>——插件的使用教程也非常简洁易懂， 在此就不重复了。</p><p><img src="/2020/11/09/scrcpy-AutoJS/%E8%BF%9E%E6%8E%A5Autojs.jpg" alt="连接Autojs"></p><p><img src="/2020/11/09/scrcpy-AutoJS/%E5%81%9C%E6%AD%A2%E8%84%9A%E6%9C%AC.jpg" alt="停止脚本"></p><h3 id="微信朋友圈点赞demo"><a class="markdownIt-Anchor" href="#微信朋友圈点赞demo"></a> 微信朋友圈点赞demo</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">comment = desc(<span class="string">"评论"</span>).findOne();</span><br><span class="line">log(comment);</span><br><span class="line">comment.click();</span><br><span class="line">sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于"赞"控件的Clickable是false, 所以点击它的父控件</span></span><br><span class="line">praise = text(<span class="string">"赞"</span>).findOne();</span><br><span class="line">praiseParent = praise.parent();</span><br><span class="line">praiseParent.click();</span><br></pre></td></tr></table></figure><h2 id="js知识补充"><a class="markdownIt-Anchor" href="#js知识补充"></a> Js知识补充</h2><p><strong>作用域:</strong></p><blockquote><p>JS只有函数作用域和全局作用域</p></blockquote><ul><li><p>全局作用域: 如果是显性的写在全局的, 则变量的作用域为全局</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; /*</span><br><span class="line">&gt; * 作用域</span><br><span class="line">&gt; *     - 作用域指一个变量的作用的范围</span><br><span class="line">&gt; *     - 在JS中一共有两种作用域：</span><br><span class="line">&gt; *         1.全局作用域</span><br><span class="line">&gt; *             - 直接编写在script标签中的JS代码，都在全局作用域</span><br><span class="line">&gt; *             - 全局作用域在页面打开时创建，在页面关闭时销毁</span><br><span class="line">&gt; *             - 在全局作用域中有一个全局对象window，</span><br><span class="line">&gt; *                 它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用</span><br><span class="line">&gt; *             - 在全局作用域中：</span><br><span class="line">&gt; *                 创建的变量都会作为window对象的属性保存</span><br><span class="line">&gt; *                 创建的函数都会作为window对象的方法保存</span><br><span class="line">&gt; * 一切皆对象</span><br><span class="line">&gt; *             - 全局作用域中的变量都是全局变量，</span><br><span class="line">&gt; *                 在页面的任意的部分都可以访问的到</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote></li><li><p>块级作用域: {}为块, {}内即为块级作用域。但是注意<strong>JS没有块级作用域</strong>， 即块里声明的变量, 作用域实际为全局。—&gt;ES6 新增了<code>let</code>命令，用来声明局部变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效，而且有暂时性死区的约束。==&gt;ES6用新增的<code>let</code>，来声明块级作用域的变量。(let另一个特性: let变量不能重复声明–var可以, 以最后的为准, 效果跟python声明变量类似)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;&#125;</span><br><span class="line">log(i);<span class="comment">// 输出为10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;&#125;</span><br><span class="line">log(i);<span class="comment">// ReferenceError: "i" is not defined. ([remote]test.js#14)ReferenceError: "i" is not defined.</span></span><br></pre></td></tr></table></figure></li><li><p>函数作用域: 在函数内即为函数作用域， 如果不用var表明， 则声明的是全局变量。用var表明是局部变量</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; /*</span><br><span class="line">&gt; * 函数作用域</span><br><span class="line">&gt; *     - 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁</span><br><span class="line">&gt; *     - 每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的</span><br><span class="line">&gt; *     - 在函数作用域中可以访问到全局作用域的变量</span><br><span class="line">&gt; *         在全局作用域中无法访问到函数作用域的变量</span><br><span class="line">&gt; *     - 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用</span><br><span class="line">&gt; *         如果没有则向上一级作用域中寻找，直到找到全局作用域，</span><br><span class="line">&gt; *         如果全局作用域中依然没有找到，则会报错ReferenceError</span><br><span class="line">&gt; *     - 在函数中要访问全局变量可以使用window对象</span><br><span class="line">&gt; */</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line">log(a);<span class="comment">// 输出1</span></span><br><span class="line">log(b);<span class="comment">// ReferenceError: "b" is not defined. ([remote]test.js#19)ReferenceError: "b" is not defined.</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>数组</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]<span class="comment">// 第一种声明数组的方式</span></span><br><span class="line">a.push(<span class="number">4</span>)<span class="comment">// 往数组最后添加元素</span></span><br><span class="line">log(a);</span><br><span class="line">log(a.indexOf(<span class="number">2</span>));<span class="comment">// 找出某元素在数组中的索引</span></span><br><span class="line">a.pop();<span class="comment">// 弹出最后一个元素</span></span><br><span class="line">log(a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b = <span class="built_in">Array</span>();<span class="comment">// 第二种声明数组的方式</span></span><br><span class="line">log(b);</span><br></pre></td></tr></table></figure><p><strong>数据类型:</strong></p><ul><li>string、number、boolean、nullundefined</li><li>Object：Function、Array、Date</li></ul><p>可以使用typeof来查看对象的类型</p><p><strong>变量函数提前声明</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* 变量的声明提前</span><br><span class="line">*     - 使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值），</span><br><span class="line">*         但是如果声明变量时不使用var关键字，则变量不会被声明提前</span><br><span class="line">*</span><br><span class="line">* 函数的声明提前</span><br><span class="line">*     - 使用函数声明形式创建的函数 function 函数()&#123;&#125;</span><br><span class="line">*         它会在所有的代码执行之前就被创建，所以我们可以在函数声明前来调用函数</span><br><span class="line">*        使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用</span><br><span class="line">*/</span><br><span class="line">/*console.log(&quot;a = &quot;+a);</span><br><span class="line">情况1：使用 var a = 123; a是undefined，声明变量在此句之后，但var a 会使变量提前声明，</span><br><span class="line">情况2： 使用  a = 123;  a未找到，会报错，因为a未提前声明</span><br><span class="line">a = 123； 等价于  window.a = 123;</span><br><span class="line">var a = 123;*/   到了此句才赋值，等价于在所有代码之前 声明a  var a;  执行到此句再赋值 a=123;</span><br><span class="line"></span><br><span class="line">//fun();</span><br><span class="line">//函数声明，会被提前创建</span><br><span class="line">function fun()&#123;</span><br><span class="line">console.log(&quot;我是一个fun函数&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数表达式，不会被提前创建，此句只是提前声明了fun2，不知道是不是函数，可能是变量， undefined而在此次才开始赋值一个函数表达式</span><br><span class="line">var fun2 = function()&#123;</span><br><span class="line">console.log(&quot;我是fun2函数&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">fun2();</span><br></pre></td></tr></table></figure><p><strong>Andriod开发知识：</strong></p><ul><li>packageName： 应用包名</li><li>applicationName: 应用名</li><li>currenetActivity: 当前页面</li></ul><hr><p>Js是单线程的, 在任务调度上，同步任务优先级最高， 微任务其次(new Promise)， 宏任务最后(setInterval, setTimeOut): <a href="https://www.bilibili.com/video/BV1NJ411W7wh?p=336" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1NJ411W7wh?p=336</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</span><br><span class="line">    resolve();<span class="comment">// 调用resolve表示成功, 调用reject表示失败</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"yes"</span>)<span class="comment">// 第一个大括号里的都是同步任务, 优先级很高</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span>&#123;<span class="comment">// 成功执行这个. 这个是微任务</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功"</span>)</span><br><span class="line">&#125;, reason =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败"</span>)<span class="comment">// 失败执行这个. 这个是微任务</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输出结果: yes =&gt; 成功</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;scrcpy简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#scrcpy简介&quot;&gt;&lt;/a&gt; scrcpy简介&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;特点:&lt;/strong&gt;&lt;br&gt;
利用电脑的键盘和鼠标可以控制手机
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>粒子滤波Matlab代码解读</title>
    <link href="https://nymrli.top/2020/10/27/%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2Matlab%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://nymrli.top/2020/10/27/粒子滤波Matlab代码解读/</id>
    <published>2020-10-27T09:39:23.000Z</published>
    <updated>2020-10-31T02:12:39.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="粒子滤波概念"><a class="markdownIt-Anchor" href="#粒子滤波概念"></a> 粒子滤波概念</h2><p><a href="https://blog.csdn.net/KYJL888/article/details/105360005/" target="_blank" rel="noopener">理解粒子滤波(particle filter)</a></p><p><a href="http://blog.sina.com.cn/s/blog_400d94220101bkc1.html" target="_blank" rel="noopener">粒子滤波的Matlab仿真算法实现</a></p><h3 id="11-机器人定位问题"><a class="markdownIt-Anchor" href="#11-机器人定位问题"></a> 1.1 机器人定位问题</h3><p>关于机器人定位，有三大问题，它们分别是：</p><p>(1)“全局定位”：指初始位置未知，机器人靠自身运动确定自己在地图中的位姿。</p><p>(2)“位姿跟踪”：指已知自身位姿或者已经通过“全局定位”得到了一个较好的位姿估计，在后续运动时补偿精度较差的运动控制误差；</p><p>(3)“绑架劫持”：指机器人在已知自身位姿的情况下，得到了一个错误的位姿信息或者外界将其放到另外一个位姿，而里程计信息给出了错误的信息甚至没有给出控制信息。</p><h3 id="12-粒子滤波步骤可结合2中例题"><a class="markdownIt-Anchor" href="#12-粒子滤波步骤可结合2中例题"></a> 1.2 粒子滤波步骤(可结合2中例题)</h3><p>(1)初始状态：用大量粒子模拟运动状态，使粒子在空间内均匀分布；</p><p>(2)预测阶段：根据状态转移方程，将每一个粒子带入，得到一个预测粒子；</p><p>(3)校正阶段：对预测粒子进行评价（计算权重），越接近于真实状态的粒子，其权重越大；</p><p>(4)重采样：根据粒子权重对粒子进行筛选，筛选过程中，既要大量保留权重大的粒子，又要有一小部分权重小的粒子；</p><p>(5)滤波：将重采样后的粒子带入状态转移方程得到新的预测粒子，即步骤(2)。</p><h2 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析"></a> 代码分析</h2><blockquote><p>虽然选修课选修了Matlab， 但是自己Matlab工程代码到底写了太少， 特别是涉及维度转换以及数学相关的玩的都不是很好， 因此这次看这份代码学到了很多基础入门的写法， 记录一下：</p></blockquote><ul><li>变量关系：<ul><li>X为对象的真实位置， Z是观测到对象的观测位置（在真实的坐标上加上了噪声），P是粒子群，Pcenter是所有粒子的几何中心</li></ul></li><li>变量维度的确定： 行为一维，列为二维。其中X(1, :)表示X坐标， X(2, :)表示Y坐标。其中列的T表示多少测量数量，测量时间。</li><li>err大小也是(2, T)， 但是(第一行为粒子与真实路径误差  第二行为测量与真实路径误差)</li><li>权重更新方式： 权重 (权重与距离的关系 为 均值是0,方差是sqrt®的高斯分布曲线)</li><li>代码组成部分：<ol><li>参数设置</li><li>初始化粒子群</li><li>开始运动</li><li>绘制轨迹</li><li>绘制误差图</li></ol></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%粒子滤波(定位运动轨迹)</span></span><br><span class="line"><span class="comment">%在二维空间,假设运动物体的一组(非线性)运动位置、速度、加速度数据,用粒子滤波方法进行处理</span></span><br><span class="line">clc,clear,close all</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 参数设置</span></span><br><span class="line">N = <span class="number">200</span>; <span class="comment">%粒子总数</span></span><br><span class="line">Q = <span class="number">5</span>; <span class="comment">%过程噪声(控制误差)  状态转移方程中使用</span></span><br><span class="line">R = <span class="number">5</span>; <span class="comment">%测量噪声  由真实位置叠加测量噪声得到测量位置</span></span><br><span class="line">T = <span class="number">10</span>; <span class="comment">%测量时间(总步数)</span></span><br><span class="line">theta = <span class="built_in">pi</span>/T; <span class="comment">%旋转角度</span></span><br><span class="line">distance = <span class="number">80</span>/T; <span class="comment">%每次走的距离(步长)</span></span><br><span class="line">WorldSize = <span class="number">100</span>; <span class="comment">%世界大小</span></span><br><span class="line"><span class="comment">% 设定变量维度</span></span><br><span class="line">X = <span class="built_in">zeros</span>(<span class="number">2</span>, T); <span class="comment">%存储系统状态(每列存储二维位置坐标(x,y),共T个位置)</span></span><br><span class="line">Z = <span class="built_in">zeros</span>(<span class="number">2</span>, T); <span class="comment">%存储系统的观测状态(每列存储二维位置坐标(x,y),共T次测量)</span></span><br><span class="line">P = <span class="built_in">zeros</span>(<span class="number">2</span>, N); <span class="comment">%建立粒子群(每列存储当前粒子的二维位置坐标,共N个粒子)</span></span><br><span class="line">PCenter = <span class="built_in">zeros</span>(<span class="number">2</span>, T); <span class="comment">%所有粒子的中心位置</span></span><br><span class="line">w = <span class="built_in">zeros</span>(N, <span class="number">1</span>); <span class="comment">%每个粒子的权重</span></span><br><span class="line">err = <span class="built_in">zeros</span>(<span class="number">2</span>,T); <span class="comment">%误差(第一行为粒子与真实路径误差  第二行为测量与真实路径误差)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X(:, <span class="number">1</span>) = [<span class="number">50</span>; <span class="number">20</span>]; <span class="comment">%初始系统状态 即初始位置在坐标(50,20)</span></span><br><span class="line">Z(:, <span class="number">1</span>) = X(:,<span class="number">1</span>) + wgn(<span class="number">2</span>,<span class="number">1</span>,<span class="number">10</span>*<span class="built_in">log10</span>(R)); <span class="comment">%初始系统的观测状态(为真实位姿叠加高斯噪声)</span></span><br><span class="line">                                         <span class="comment">%y = wgn(m,n,p) 产生一个m行n列的高斯白噪声的矩阵，p以dBW为单位指定输出噪声的强度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 初始化粒子群</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : N</span><br><span class="line">    P(:, <span class="built_in">i</span>) = [WorldSize*rand; WorldSize*rand];  <span class="comment">%随机产生第i个粒子的坐标(rand为产生[0,1]之间均匀分布)</span></span><br><span class="line">    dist = norm(P(:, <span class="built_in">i</span>)-Z(:, <span class="number">1</span>)); <span class="comment">%与测量位置相差的距离</span></span><br><span class="line">    <span class="comment">%求权重 (权重与距离的关系 为 均值是0,方差是sqrt(R)的高斯分布曲线)  </span></span><br><span class="line">    <span class="comment">%   因为均值为0且距离大于0 因此权重随着距离增加沿高斯曲线右侧递减</span></span><br><span class="line">    w(<span class="built_in">i</span>) = (<span class="number">1</span> / <span class="built_in">sqrt</span>(R) / <span class="built_in">sqrt</span>(<span class="number">2</span> * <span class="built_in">pi</span>)) * <span class="built_in">exp</span>(-(dist)^<span class="number">2</span> / <span class="number">2</span> / R); </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">PCenter(:, <span class="number">1</span>) = sum(P, <span class="number">2</span>) / N;<span class="comment">%t=1时刻(初始时刻)所有粒子的几何中心位置</span></span><br><span class="line"><span class="comment">% 初始状态(t=1)画图</span></span><br><span class="line">err(<span class="number">1</span>,<span class="number">1</span>) = norm(X(:, <span class="number">1</span>) - PCenter(:, <span class="number">1</span>));<span class="comment">%粒子群几何中心与系统真实状态的误差</span></span><br><span class="line">err(<span class="number">2</span>,<span class="number">1</span>) = wgn(<span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>*<span class="built_in">log10</span>(R));</span><br><span class="line">figure(<span class="number">1</span>);</span><br><span class="line">hold on</span><br><span class="line">set(<span class="number">0</span>,<span class="string">'defaultfigurecolor'</span>,<span class="string">'w'</span>)</span><br><span class="line">plot(X(<span class="number">1</span>, <span class="number">1</span>), X(<span class="number">2</span>, <span class="number">1</span>), <span class="string">'r.'</span>, <span class="string">'markersize'</span>,<span class="number">30</span>) <span class="comment">%真实的初始状态位置(红点表示)</span></span><br><span class="line"><span class="comment">%grid on</span></span><br><span class="line">axis([<span class="number">0</span> <span class="number">100</span> <span class="number">0</span> <span class="number">100</span>]);</span><br><span class="line">set(gca,<span class="string">'XTick'</span>,<span class="number">0</span>:<span class="number">10</span>:<span class="number">100</span>) <span class="comment">%改变x轴坐标间隔显示 这里间隔为10</span></span><br><span class="line">set(gca,<span class="string">'YTick'</span>,<span class="number">0</span>:<span class="number">10</span>:<span class="number">100</span>) <span class="comment">%改变y轴坐标间隔显示 这里间隔为10</span></span><br><span class="line">plot(P(<span class="number">1</span>, :), P(<span class="number">2</span>, :), <span class="string">'k.'</span>, <span class="string">'markersize'</span>,<span class="number">5</span>); <span class="comment">%各个粒子位置(N个黑点)</span></span><br><span class="line">plot(PCenter(<span class="number">1</span>, <span class="number">1</span>), PCenter(<span class="number">2</span>, <span class="number">1</span>), <span class="string">'b.'</span>, <span class="string">'markersize'</span>,<span class="number">25</span>); <span class="comment">%所有粒子的中心位置(蓝点表示)</span></span><br><span class="line">legend(<span class="string">'真实位置'</span>, <span class="string">'粒子群'</span>, <span class="string">'粒子群的几何中心'</span>);</span><br><span class="line">title(<span class="string">'初始状态'</span>);</span><br><span class="line">hold off</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 开始运动</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">2</span> : T <span class="comment">%从t=2到T</span></span><br><span class="line">    <span class="comment">%模拟一个弧线运动的状态</span></span><br><span class="line">    X(:, k) = X(:, k<span class="number">-1</span>) + distance * [(-cos(k * theta)); sin(k * theta)] + wgn(<span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span>*<span class="built_in">log10</span>(Q)); <span class="comment">%状态方程</span></span><br><span class="line">    Z(:, k) = X(:, k) + wgn(<span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span>*<span class="built_in">log10</span>(R)); <span class="comment">%观测方程(状态上叠加测量的高斯噪声) </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%粒子滤波</span></span><br><span class="line">    <span class="comment">% 1.预测</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : N</span><br><span class="line">        P(:, <span class="built_in">i</span>) = P(:, <span class="built_in">i</span>) + distance * [-cos(k * theta); sin(k * theta)] + wgn(<span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span>*<span class="built_in">log10</span>(Q));<span class="comment">%粒子群带入状态方程</span></span><br><span class="line">        dist = norm(P(:, <span class="built_in">i</span>)-Z(:, k)); <span class="comment">%粒子群中各粒子 与 测量位置 的距离</span></span><br><span class="line">        w(<span class="built_in">i</span>) = (<span class="number">1</span> / <span class="built_in">sqrt</span>(R) / <span class="built_in">sqrt</span>(<span class="number">2</span> * <span class="built_in">pi</span>)) * <span class="built_in">exp</span>(-(dist)^<span class="number">2</span> / <span class="number">2</span> / R); <span class="comment">%求权重(距离近权重大)</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 2.归一化权重</span></span><br><span class="line">    wsum = sum(w);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : N</span><br><span class="line">        w(<span class="built_in">i</span>) = w(<span class="built_in">i</span>) / wsum;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 3.重采样（更新）——可以理解为转转盘</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : N</span><br><span class="line">        wmax = <span class="number">2</span> * max(w) * <span class="built_in">rand</span>; <span class="comment">%另一种重采样规则</span></span><br><span class="line">        index = randi(N, <span class="number">1</span>);<span class="comment">%生成一个在[1(默认值),N]之间均匀分布的伪随机整数</span></span><br><span class="line">        <span class="keyword">while</span>(wmax &gt; w(index))<span class="comment">% 找到具体落在哪个区间上</span></span><br><span class="line">            wmax = wmax - w(index);</span><br><span class="line">            index = index + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> index &gt; N</span><br><span class="line">                index = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        Pnext(:, <span class="built_in">i</span>) = P(:, index); <span class="comment">%得到新粒子放入临时集Pnext</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    P=Pnext;<span class="comment">%用临时集Pnext更新粒子集P</span></span><br><span class="line">    PCenter(:, k) = sum(P, <span class="number">2</span>) / N; <span class="comment">%重采样后所有粒子的中心位置</span></span><br><span class="line">    <span class="comment">%计算误差</span></span><br><span class="line">    err(<span class="number">1</span>,k) = norm(X(:, k) - PCenter(:, k)); <span class="comment">%粒子几何中心与系统真实状态的误差</span></span><br><span class="line">    err(<span class="number">2</span>,k) = norm(X(:, k) - Z(:, k));</span><br><span class="line">    <span class="comment">%画图</span></span><br><span class="line">    figure(<span class="number">2</span>);</span><br><span class="line">    set(<span class="number">0</span>,<span class="string">'defaultfigurecolor'</span>,<span class="string">'w'</span>)</span><br><span class="line">    clf;<span class="comment">%清空figure(2)中的图像 以便循环重新画</span></span><br><span class="line">    hold on</span><br><span class="line">    plot(X(<span class="number">1</span>, k), X(<span class="number">2</span>, k), <span class="string">'r.'</span>, <span class="string">'markersize'</span>,<span class="number">30</span>); <span class="comment">%系统状态位置</span></span><br><span class="line">    plot(P(<span class="number">1</span>, :), P(<span class="number">2</span>, :), <span class="string">'k.'</span>, <span class="string">'markersize'</span>,<span class="number">5</span>); <span class="comment">%各个粒子位置</span></span><br><span class="line">    plot(PCenter(<span class="number">1</span>, k), PCenter(<span class="number">2</span>, k), <span class="string">'b.'</span>, <span class="string">'markersize'</span>,<span class="number">25</span>); <span class="comment">%所有粒子的中心位置</span></span><br><span class="line">    axis([<span class="number">0</span> <span class="number">100</span> <span class="number">0</span> <span class="number">100</span>]);</span><br><span class="line">    title(<span class="string">'运动过程'</span>);</span><br><span class="line">    legend(<span class="string">'真实状态'</span>, <span class="string">'粒子群'</span>, <span class="string">'粒子群的几何中心'</span>);</span><br><span class="line">    hold off</span><br><span class="line">    pause(<span class="number">0.1</span>);<span class="comment">%停0.1s开始下次迭代</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 绘制轨迹</span></span><br><span class="line">figure(<span class="number">3</span>);</span><br><span class="line">set(<span class="number">0</span>,<span class="string">'defaultfigurecolor'</span>,<span class="string">'w'</span>)</span><br><span class="line">plot(X(<span class="number">1</span>,:), X(<span class="number">2</span>,:), <span class="string">'r.-'</span>, Z(<span class="number">1</span>,:), Z(<span class="number">2</span>,:), <span class="string">'g.-'</span>, PCenter(<span class="number">1</span>,:), PCenter(<span class="number">2</span>,:), <span class="string">'b.-'</span>);</span><br><span class="line">axis([<span class="number">0</span> <span class="number">100</span> <span class="number">0</span> <span class="number">100</span>]);</span><br><span class="line">set(gca,<span class="string">'XTick'</span>,<span class="number">0</span>:<span class="number">10</span>:<span class="number">100</span>) <span class="comment">%改变x轴坐标间隔显示 这里间隔为10</span></span><br><span class="line">set(gca,<span class="string">'YTick'</span>,<span class="number">0</span>:<span class="number">10</span>:<span class="number">100</span>) <span class="comment">%改变y轴坐标间隔显示 这里间隔为10</span></span><br><span class="line">legend(<span class="string">'真实轨迹'</span>, <span class="string">'测量轨迹'</span>, <span class="string">'粒子群几何中心轨迹'</span>);</span><br><span class="line">xlabel(<span class="string">'横坐标 x'</span>); ylabel(<span class="string">'纵坐标 y'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 绘制误差</span></span><br><span class="line">figure(<span class="number">4</span>);</span><br><span class="line">set(<span class="number">0</span>,<span class="string">'defaultfigurecolor'</span>,<span class="string">'w'</span>)</span><br><span class="line"><span class="comment">%set(gca,'FontSize',12);%设置图标字体大小</span></span><br><span class="line">plot(err(<span class="number">1</span>,:),<span class="string">'b.-'</span>);<span class="comment">%err1为各时刻 真实位置与粒子群中心的几何距离</span></span><br><span class="line">hold on</span><br><span class="line">plot(err(<span class="number">2</span>,:),<span class="string">'r.-'</span>);<span class="comment">%err2为各时刻 真实位置与测量位置的几何距离</span></span><br><span class="line">hold off</span><br><span class="line">xlabel(<span class="string">'步数 t'</span>);</span><br><span class="line">legend(<span class="string">'粒子群误差'</span>, <span class="string">'测量误差'</span>);</span><br><span class="line">title(<span class="string">'真实位置与粒子群中心的集合距离'</span>);</span><br></pre></td></tr></table></figure><h2 id="用到的函数记录"><a class="markdownIt-Anchor" href="#用到的函数记录"></a> 用到的函数记录</h2><h3 id="matlab中的norm"><a class="markdownIt-Anchor" href="#matlab中的norm"></a> Matlab中的norm</h3><p>demo代码中有关norm的运用如下,</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 初始化粒子群</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : N</span><br><span class="line">    P(:, <span class="built_in">i</span>) = [WorldSize*rand; WorldSize*rand];  <span class="comment">%随机产生第i个粒子的坐标(rand为产生[0,1]之间均匀分布)</span></span><br><span class="line">    dist = norm(P(:, <span class="built_in">i</span>)-Z(:, <span class="number">1</span>)); <span class="comment">%与测量位置相差的距离</span></span><br><span class="line">    <span class="comment">%求权重 (权重与距离的关系 为 均值是0,方差是sqrt(R)的高斯分布曲线)  </span></span><br><span class="line">    <span class="comment">%   因为均值为0且距离大于0 因此权重随着距离增加沿高斯曲线右侧递减</span></span><br><span class="line">    w(<span class="built_in">i</span>) = (<span class="number">1</span> / <span class="built_in">sqrt</span>(R) / <span class="built_in">sqrt</span>(<span class="number">2</span> * <span class="built_in">pi</span>)) * <span class="built_in">exp</span>(-(dist)^<span class="number">2</span> / <span class="number">2</span> / R); </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其中没有特别指出是啥范数, 因此可以通过<code>help norm</code>来查看一下关于norm的使用介绍.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; help norm</span><br><span class="line"> norm   Matrix or vector norm.</span><br><span class="line">      norm(X,2) returns the 2-norm of X.</span><br><span class="line"> </span><br><span class="line">      norm(X) is the same as norm(X,2).</span><br><span class="line"> </span><br><span class="line">      norm(X,1) returns the 1-norm of X.</span><br></pre></td></tr></table></figure><p>可以得到, norm(X)的效果默认是取2-范数的。</p><p>同时， norm函数既可以取向量范数又可以取矩阵范数：</p><h4 id="1-如果a为矩阵"><a class="markdownIt-Anchor" href="#1-如果a为矩阵"></a> 1、如果A为矩阵</h4><ul><li><p>n=norm(A) 《Simulink与信号处理》</p><p>返回A的最大奇异值，即max(svd(A))</p></li><li><p>n=norm(A,p)</p><p>根据p的不同，返回不同的值</p></li></ul><table><thead><tr><th>p</th><th>返回值</th></tr></thead><tbody><tr><td>1</td><td>返回A中最大<strong>一列和</strong>，即max(sum(abs(A)))</td></tr><tr><td>2</td><td>返回A的最大奇异值，和n=norm(A)用法一样</td></tr><tr><td>inf</td><td>返回A中最大<strong>一行和</strong>，即max(sum(abs(A’)))</td></tr><tr><td>‘fro’</td><td>A和A‘的积的对角线和的平方根，即sqrt(sum(diag(A’*A)))</td></tr></tbody></table><h4 id="2-如果a为向量"><a class="markdownIt-Anchor" href="#2-如果a为向量"></a> 2、如果A为向量</h4><ul><li><p>norm(A,p)</p><p>返回向量A的p范数。即返回 sum(abs(A).<sup>p)</sup>(1/p),对任意 1&lt;p&lt;+∞.</p></li><li><p>norm(A)</p><p>返回向量A的2范数，即等价于norm(A,2)。</p></li><li><p>norm(A,inf)</p><p>返回max(abs(A))</p></li><li><p>norm(A,-inf)</p><p>返回min(abs(A))</p></li></ul><h3 id="matlab中的sum"><a class="markdownIt-Anchor" href="#matlab中的sum"></a> Matlab中的sum</h3><ul><li><code>sum(A, 1)</code>： 对一维求和， 如果A为二维数组， 则按列求和</li><li><code>sum(A, 2)</code>: 对二维求和， 如果A为二维数组， 则按行求和</li></ul><h3 id="matlab中的wgn"><a class="markdownIt-Anchor" href="#matlab中的wgn"></a> Matlab中的wgn</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; help wgn</span><br><span class="line"> wgn Generate white Gaussian noise.</span><br><span class="line">    Y = wgn(M,N,P) generates an M-by-N matrix of white Gaussian noise. P</span><br><span class="line">    specifies the power of the output noise in dBW. The unit of measure for</span><br><span class="line">    the output of the wgn function is Volts. For power calculations, it is</span><br><span class="line">    assumed that there is a load of 1 Ohm. </span><br><span class="line"> </span><br><span class="line">    Y = wgn(M,N,P,IMP) specifies the load impedance in Ohms.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;粒子滤波概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#粒子滤波概念&quot;&gt;&lt;/a&gt; 粒子滤波概念&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/KYJL888/article/details/10536
      
    
    </summary>
    
    
      <category term="Matlab" scheme="https://nymrli.top/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>范数的概念_MATLAB使用</title>
    <link href="https://nymrli.top/2020/10/27/%E8%8C%83%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5-MATLAB%E4%BD%BF%E7%94%A8/"/>
    <id>https://nymrli.top/2020/10/27/范数的概念-MATLAB使用/</id>
    <published>2020-10-27T08:13:30.000Z</published>
    <updated>2020-10-27T10:26:44.365Z</updated>
    
    <content type="html"><![CDATA[<h1 id="范数"><a class="markdownIt-Anchor" href="#范数"></a> 范数</h1><blockquote><p>之前大二在看机器学习的时候一直看到&quot;范数&quot;这个名词, 但是一直没有去详细了解过, 就只知道2-范数相当于两个点在二维平面的距离。这次在看粒子滤波matlab实现代码的时候看到了<code>norm</code>函数, 正好补一下关于范数的概念。</p></blockquote><h2 id="向量的范数"><a class="markdownIt-Anchor" href="#向量的范数"></a> 向量的范数</h2><h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3><p><img src="/2020/10/27/范数的概念-MATLAB使用/%E5%90%91%E9%87%8F%E8%8C%83%E6%95%B0.jpg" alt="向量范数"></p><p>注: 简言之: ①向量的范数是定义在线性空间上的非负实数.②实内积空间和酉空间中向量的长度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mi mathvariant="normal">∣</mi><mo>=</mo><msqrt><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msqrt></mrow><annotation encoding="application/x-tex">|x|=\sqrt{(x,x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.30499999999999994em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span><span style="top:-2.8950000000000005em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width="400em" height="1.28em" viewbox="0 0 400000 1296" preserveaspectratio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30499999999999994em;"><span></span></span></span></span></span></span></span></span>都是向量的范数③酉空间向量范数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">||x||</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mord">∣</span></span></span></span>用向量长度|x|来定义时,记作<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mi mathvariant="normal">∣</mi><msub><mi mathvariant="normal">∣</mi><mn>2</mn></msub><mo>=</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mi mathvariant="normal">∣</mi><mo>=</mo><msqrt><mrow><mi>x</mi><msup><mi>x</mi><mi>H</mi></msup></mrow></msqrt><mo>=</mo><msqrt><mrow><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mrow><mi>ξ</mi><mover accent="true"><mi>ξ</mi><mo>ˉ</mo></mover></mrow></mrow></msqrt></mrow><annotation encoding="application/x-tex">||x||_2 = |x| = \sqrt{xx^H} = \sqrt{sum^{n}_{i=1}{ξ\bar{ξ}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.07133449999999997em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9686655000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">x</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.767331em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span></span></span></span></span></span></span><span style="top:-2.9286655em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.07133449999999997em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.277822em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.962178em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6461920000000001em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0448000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04601em;">ξ</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8312199999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04601em;">ξ</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.13889em;">ˉ</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.922178em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width="400em" height="1.28em" viewbox="0 0 400000 1296" preserveaspectratio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.277822em;"><span></span></span></span></span></span></span></span></span></p><p><img src="/2020/10/27/范数的概念-MATLAB使用/%E5%90%91%E9%87%8F%E8%8C%83%E6%95%B0.jpg" alt="向量范数"></p><p>通式——P-范数</p><p><img src="/2020/10/27/范数的概念-MATLAB使用/p%E8%8C%83%E6%95%B0.jpg" alt="p范数"></p><p>注: 当P-&gt;∞时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>ξ</mi></mrow><annotation encoding="application/x-tex">||X|| = max{\xi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04601em;">ξ</span></span></span></span></span></p><p><img src="/2020/10/27/范数的概念-MATLAB使用/%E8%8C%83%E6%95%B0%E7%9A%84%E6%84%8F%E4%B9%89.jpg" alt="范数的意义"></p><h2 id="矩阵的范数"><a class="markdownIt-Anchor" href="#矩阵的范数"></a> 矩阵的范数</h2><p><img src="/2020/10/27/范数的概念-MATLAB使用/E:%5Chexo%5Csource_posts%5C%E8%8C%83%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5-MATLAB%E4%BD%BF%E7%94%A8%5C%E7%9F%A9%E9%98%B5%E8%8C%83%E6%95%B0.jpg" alt="矩阵范数"></p><p><img src="/2020/10/27/范数的概念-MATLAB使用/E:%5Chexo%5Csource_posts%5C%E8%8C%83%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5-MATLAB%E4%BD%BF%E7%94%A8%5C%E7%9F%A9%E9%98%B5%E8%8C%83%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8.jpg" alt="矩阵范数的性质"></p><p>▲以上概念来自于B站视频: <a href="https://www.bilibili.com/video/BV1hT4y1g7Rp?from=search&amp;seid=11751236706633684482" target="_blank" rel="noopener">向量范数矩阵范数</a></p><h3 id="matlab中的norm"><a class="markdownIt-Anchor" href="#matlab中的norm"></a> Matlab中的norm</h3><p>demo代码中有关norm的运用如下,</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 初始化粒子群</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : N</span><br><span class="line">    P(:, <span class="built_in">i</span>) = [WorldSize*rand; WorldSize*rand];  <span class="comment">%随机产生第i个粒子的坐标(rand为产生[0,1]之间均匀分布)</span></span><br><span class="line">    dist = norm(P(:, <span class="built_in">i</span>)-Z(:, <span class="number">1</span>)); <span class="comment">%与测量位置相差的距离</span></span><br><span class="line">    <span class="comment">%求权重 (权重与距离的关系 为 均值是0,方差是sqrt(R)的高斯分布曲线)  </span></span><br><span class="line">    <span class="comment">%   因为均值为0且距离大于0 因此权重随着距离增加沿高斯曲线右侧递减</span></span><br><span class="line">    w(<span class="built_in">i</span>) = (<span class="number">1</span> / <span class="built_in">sqrt</span>(R) / <span class="built_in">sqrt</span>(<span class="number">2</span> * <span class="built_in">pi</span>)) * <span class="built_in">exp</span>(-(dist)^<span class="number">2</span> / <span class="number">2</span> / R); </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其中没有特别指出是啥范数, 因此可以通过<code>help norm</code>来查看一下关于norm的使用介绍.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; help norm</span><br><span class="line"> norm   Matrix or vector norm.</span><br><span class="line">      norm(X,2) returns the 2-norm of X.</span><br><span class="line"> </span><br><span class="line">      norm(X) is the same as norm(X,2).</span><br><span class="line"> </span><br><span class="line">      norm(X,1) returns the 1-norm of X.</span><br></pre></td></tr></table></figure><p>可以得到, norm(X)的效果默认是取2-范数的。</p><p>同时， norm函数既可以取向量范数又可以取矩阵范数：</p><h4 id="1-如果a为矩阵"><a class="markdownIt-Anchor" href="#1-如果a为矩阵"></a> 1、如果A为矩阵</h4><ul><li><p>n=norm(A) 《Simulink与信号处理》</p><p>返回A的最大奇异值，即max(svd(A))</p></li><li><p>n=norm(A,p)</p><p>根据p的不同，返回不同的值</p></li></ul><table><thead><tr><th>p</th><th>返回值</th></tr></thead><tbody><tr><td>1</td><td>返回A中最大<strong>一列和</strong>，即max(sum(abs(A)))</td></tr><tr><td>2</td><td>返回A的最大奇异值，和n=norm(A)用法一样</td></tr><tr><td>inf</td><td>返回A中最大<strong>一行和</strong>，即max(sum(abs(A’)))</td></tr><tr><td>‘fro’</td><td>A和A‘的积的对角线和的平方根，即sqrt(sum(diag(A’*A)))</td></tr></tbody></table><h4 id="2-如果a为向量"><a class="markdownIt-Anchor" href="#2-如果a为向量"></a> 2、如果A为向量</h4><ul><li><p>norm(A,p)</p><p>返回向量A的p范数。即返回 sum(abs(A).<sup>p)</sup>(1/p),对任意 1&lt;p&lt;+∞.</p></li><li><p>norm(A)</p><p>返回向量A的2范数，即等价于norm(A,2)。</p></li><li><p>norm(A,inf)</p><p>返回max(abs(A))</p></li><li><p>norm(A,-inf)</p><p>返回min(abs(A))</p></li></ul><h3 id="matlab中的sum"><a class="markdownIt-Anchor" href="#matlab中的sum"></a> Matlab中的sum</h3><ul><li><code>sum(A, 1)</code>： 对一维求和， 如果A为二维数组， 则按列求和</li><li><code>sum(A, 2)</code>: 对二维求和， 如果A为二维数组， 则按行求和</li></ul><h3 id="matlab中的wgn"><a class="markdownIt-Anchor" href="#matlab中的wgn"></a> Matlab中的wgn</h3><blockquote><p>white Gaussian noise</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; help wgn</span><br><span class="line"> wgn Generate white Gaussian noise.</span><br><span class="line">    Y = wgn(M,N,P) generates an M-by-N matrix of white Gaussian noise. P</span><br><span class="line">    specifies the power of the output noise in dBW. The unit of measure for</span><br><span class="line">    the output of the wgn function is Volts. For power calculations, it is</span><br><span class="line">    assumed that there is a load of 1 Ohm. </span><br><span class="line"> </span><br><span class="line">    Y = wgn(M,N,P,IMP) specifies the load impedance in Ohms.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;范数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#范数&quot;&gt;&lt;/a&gt; 范数&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;之前大二在看机器学习的时候一直看到&amp;quot;范数&amp;quot;这个名词, 但是一直没有去详细了解过, 就只知道2-范数
      
    
    </summary>
    
    
      <category term="Math" scheme="https://nymrli.top/tags/Math/"/>
    
      <category term="MATLAB" scheme="https://nymrli.top/tags/MATLAB/"/>
    
  </entry>
  
  <entry>
    <title>Python中import的细节</title>
    <link href="https://nymrli.top/2020/10/23/Python%E4%B8%ADimport%E7%9A%84%E7%BB%86%E8%8A%82/"/>
    <id>https://nymrli.top/2020/10/23/Python中import的细节/</id>
    <published>2020-10-23T13:01:21.000Z</published>
    <updated>2020-12-08T14:21:18.357Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>防忘系列…</p></blockquote><p>Pycharm并没有IDEA一样可以设置<strong>对import进行排序</strong>以及<strong>自动消除没用到的库</strong>（要用快捷键Ctrl + Alt + O）， 并且如果导入方式不正确会 1.找不到自定义包 2.Pycharm对指定内容报错（下划线或红线）</p><h2 id="python中模块包库概念"><a class="markdownIt-Anchor" href="#python中模块包库概念"></a> <a href="https://www.cnblogs.com/mlgjb/p/7875494.html" target="_blank" rel="noopener">Python中模块，包，库概念</a></h2><p><strong>模块</strong>：就是<u>.py文件</u>，里面定义了一些函数和变量，需要的时候就可以导入这些模块。</p><p><strong>包</strong>：在模块之上的概念，为了方便管理而将文件进行打包。包目录下第一个文件便是<code>__init__.py</code>，然后是一些模块文件和子目录，假如子目录中也有<code>__init__.py</code>，那么它就是这个包的<strong>子包</strong>了。</p><p><strong>库</strong>：具有相关功能模块、包的集合。这也是Python的一大特色之一，即具有强大的标准库、第三方库以及自定义模块。</p><p><strong>标准库</strong>：就是下载安装的python里那些自带的模块，要注意的是，里面有一些模块是看不到的比如像sys模块，这与linux下的cd命令看不到是一样的情况。</p><p><strong>第三方库</strong>：就是由其他的第三方机构，发布的具有特定功能的模块。</p><p><strong>自定义模块</strong>：用户自己可以自行编写模块，然后使用。</p><p>总结: 我们<code>pip install &lt;package&gt;</code>安装的是库，库下有很多包，我们在自己的项目文件中import有以下几种用法:</p><ul><li>import numpy as np</li><li>import urllib.parse import urlencode</li><li>from lxml import HTML</li></ul><p>之前大家应该碰到过，命名自己<code>pip install xx</code>安装的是叫xx的库，但是在用的时候写的却是<code>from yy import zz</code>，明显不对应嘛。因此，其实库和包的区别还可以通过<code>setup.py</code>打包成库来看。——<a href="https://blog.csdn.net/zyf_2014/article/details/83059874" target="_blank" rel="noopener">使用setup.py打包python文件</a>； <a href="https://www.jb51.net/article/190659.htm" target="_blank" rel="noopener">Python实现打包成库供别的模块调用</a></p><p>其中比较重要的就是<strong>5.编写:setup.py</strong>，</p><blockquote><p>注意：setup.py与要打包的test_package包同在bricewulib根目录下。</p></blockquote><p>其中比较重要的几项是:name,version,packages</p><ul><li>name:描述的是你打包的文件夹名。</li><li>version描述的是文件的版本号。</li><li>packages是所有要打包的包（package），这里需要打包的是test_package包以及test_package包下的test_package。输入<code>python setup.py sdist</code>然后就能创建bricewulib库，使用test_package包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setup(</span><br><span class="line">name = &quot;bricewulib&quot;,</span><br><span class="line">version = &quot;1.0&quot;,</span><br><span class="line">packages=[&quot;test_package&quot;,&quot;test_package.test_package2&quot;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="import推荐顺序"><a class="markdownIt-Anchor" href="#import推荐顺序"></a> import推荐顺序</h2><p>我们推荐所有的模块在 Python 模块的开头部分导入。 而且最好按照这样的顺序:</p><ol><li>Python 标准库模块</li><li>Python 第三方模块</li><li>应用程序自定义模块</li></ol><p>通过空行来分割——<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/background/" target="_blank" rel="noopener">(Python’s Style Guide)</a>, PEP8 。</p><h2 id="import的搜索顺序"><a class="markdownIt-Anchor" href="#import的搜索顺序"></a> import的搜索顺序：</h2><ol><li>首先判断这个module是不是built-in即内建模块，如果是则引入内建模块，如果不是则在一个称为sys.path的list中寻找</li><li>sys.path在python脚本执行时动态生成，包括以下3个部分：</li></ol><ul><li>脚本执行的位置，即当前路径</li><li>环境变量中的PYTHONPATH, 即.bash_profilec.</li><li>安装python时的依赖位置</li></ul><h2 id="python的import机制"><a class="markdownIt-Anchor" href="#python的import机制"></a> Python的import机制</h2><p>运行、编写Python代码时，一定要注意的是脚本路径和脚本执行路径，以及相对路径和绝对路径</p><p><strong>如果在项目中运用了相对路径,则一定要注意脚本执行路径</strong></p><p>假设A是B的父目录, 如我们想在A目录调用B中模块, 而B中模板是又import了A下模板, 如login: <code>from login import ftSession</code>。<strong>命令行</strong>在A路径下输入<code>python B/main.py</code>时, 会报错。因为import其实就是在搜索目录下按相对路径找的。</p><h3 id="pycharm的坑"><a class="markdownIt-Anchor" href="#pycharm的坑"></a> <strong>Pycharm的坑:</strong></h3><p>借鉴: <a href="https://zhuanlan.zhihu.com/p/109036573" target="_blank" rel="noopener">Python的import机制坑在哪？</a></p><blockquote><p><strong>pycharm里打出来的路径是更多的，它把项目根目录加进去了。</strong>(也可以设置: 进入设置，找到Console下的Python Console，勾选选项**“Add source roots to PYTHONPAT”** )</p></blockquote><p>查看搜索路径:<code>print(sys.path)</code></p><p><img src="/2020/10/23/Python中import的细节/Python%E4%B8%ADimport%E7%9A%84%E7%BB%86%E8%8A%82%5Csettings.jpg" alt="settings"></p><p>What’s resource root?</p><p><img src="https://pic4.zhimg.com/80/v2-99d4cf12cb731bf457b3ee503dfd5d42_720w.jpg?source=1940ef5c" alt="img"></p><p>以上导致的问题就是:</p><p><strong>pycharm中，project folder是默认的source root</strong>，当你使用import语句导入模块时，Pycharm默认在project folder中寻找；所以当你在project folder下的某个subfolder导入某个同样定义在这个subfolder中的模块时，会出现导入错误。</p><blockquote><p><strong>pycharm中的第一个文件夹，即代表项目</strong>, 当在其中再次建立文件夹时，<strong>是按package处理的</strong></p><p>如果要在这些文件夹内<strong>import其他文件，需要将完整路径导入进来</strong></p></blockquote><p>所以最终在Pycharm中导入的方式有两种: <a href="https://www.zhihu.com/question/63028700" target="_blank" rel="noopener">burning回答</a></p><ul><li>从project folder开始相对导入</li><li>将module文件夹直接定义为source root</li></ul><p><strong>pycharm在同目录下import划红线但实际可以运行</strong></p><blockquote><p>解决方法: 右键将model所在的文件夹设置为source root</p></blockquote><h3 id="总结python该如何import"><a class="markdownIt-Anchor" href="#总结python该如何import"></a> 总结：python该如何import</h3><p>需要明确的一点是：在运行Python脚本的时候，Python解释器会把脚本执行的位置，即当前路径加入到搜索路径中，而绝大多数情况main函数就在工程根目录，因此对于一个工程而言，最好的是从从project folder(工程根目录，即运行main函数的那个入口文件)开始<strong>相对导入</strong></p><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">G:.</span><br><span class="line">AI-for-Othello</span><br><span class="line">│  .gitignore</span><br><span class="line">│  board.py</span><br><span class="line">│  config.py</span><br><span class="line">│  game.py</span><br><span class="line">│  main.ipynb</span><br><span class="line">│  main.py</span><br><span class="line">│  README.md</span><br><span class="line">│  __init__.py</span><br><span class="line">│</span><br><span class="line">├─ai</span><br><span class="line">│  │  mcts.py</span><br><span class="line">│  │  randm.py</span><br><span class="line">│  │  __init__.py</span><br><span class="line">│  │</span><br><span class="line">│  ├─utils</span><br><span class="line">│  │  │  mct.py</span><br><span class="line">│  │  │  __init__.py</span><br></pre></td></tr></table></figure><p>在这里ai/utils中mct.py需要import board.py中的Board对象等，mct.py中import具体写法为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> board <span class="keyword">import</span> Board</span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> C</span><br><span class="line"><span class="comment"># 解释一下这边为什么是直接from board， 因为我们的main函数入口是main.py文件(在工程根目录)，所以他会把AI-for-Othello这个路径给加入到包的搜索路径中，所以此时我们import就是以这个路径(工程根目录)开始相对导入</span></span><br></pre></td></tr></table></figure><p>▲需要注意的是，对于main函数如果不在根目录，而是在工程目录的子目录中的情况，需要在main.py中自己手动添加<code>sys.path.append(&quot;..&quot;)</code>，即想办法把工程根目录加到搜索目录中，这样以后就可以又开始从工程根目录开始import了。</p><p>还有一个对于初学者可能会产生自我怀疑的点，我也顺便提一下好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> *</span><br><span class="line">// 等价于</span><br><span class="line"><span class="keyword">from</span> .config <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><hr><h2 id="__init__文件作用"><a class="markdownIt-Anchor" href="#__init__文件作用"></a> <code>__init__</code>文件作用</h2><p>在Python工程里，当python检测到一个目录下存在<code>__init__.py</code>文件时，python就会把这个目录当成一个包(package)。Module跟C＋＋的命名空间和Java的Package的概念很像，都是为了科学地组织化工程，管理命名空间。</p><h3 id="__init__py的设计原则"><a class="markdownIt-Anchor" href="#__init__py的设计原则"></a> <strong><code>__init__.py</code>的设计原则</strong></h3><p><code>__init__.py</code>的原始使命是声明一个模块，所以它可以是一个空文件。</p><p>A、不要污染现有的<strong>命名空间</strong>。模块一个目的，是为了避免命名冲突，如果你在种用__init__.py时违背这个原则，是反其道而为之，就没有必要使用模块了。</p><p>B、利用<code>__init__.py</code>对<strong>外提供类型、变量和接口，对用户隐藏各个子模块的实现</strong>。一个模块的实现可能非常复杂，你需要用很多个文件，甚至很多子模块来实现，但用户可能只需要知道一个类型和接口。就像我们的arithmetic例子中，用户只需要知道四则运算有add、sub、mul、dev四个接口，却并不需要知道它们是怎么实现的，也不想去了解arithmetic中是如何组织各个子模块的。由于各个子模块的实现有可能非常复杂，而对外提供的类型和接口有可能非常的简单，我们就可以通过这个方式来对用户隐藏实现，同时提供非常方便的使用。</p><p>C、只在__init__.py中导入有必要的内容，不要做没必要的运算。像我们的例子，<strong>import</strong> arithmetic语句会<strong>执行</strong><code>__ini__.py</code>中的所有<strong>代码</strong>。如果我们在<code>__init__.py</code>中做太多事情，每次import都会有额外的运算，会造成没有必要的开销。一句话，<strong>init</strong>.py只是为了达到B中所表述的目的，其它事情就不要做啦。</p><p>上述来自: <a href="https://zhuanlan.zhihu.com/p/115350758" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/115350758</a></p><h3 id="__all__变量"><a class="markdownIt-Anchor" href="#__all__变量"></a> <code>__all__</code>变量</h3><p><code>__all__</code>是一个字符串list；</p><p>约束作用：用来定义模块中对于<code>from XXX import *</code>时要对外导出的符号，即要暴露的借口，但它只对<code>import *</code>起作用(即如果在使用脚本中对当前包使用import *，那么可以管理当前包下模块的导入情况)，对<code>from XXX import XXX</code>不起作用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;防忘系列…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Pycharm并没有IDEA一样可以设置&lt;strong&gt;对import进行排序&lt;/strong&gt;以及&lt;strong&gt;自动消除没用到的库&lt;/strong&gt;（要用快捷键Ctrl + Alt + O）
      
    
    </summary>
    
    
      <category term="防忘系列" scheme="https://nymrli.top/tags/%E9%98%B2%E5%BF%98%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>emplace_back与push_back</title>
    <link href="https://nymrli.top/2020/10/18/emplace-back%E4%B8%8Epush-back/"/>
    <id>https://nymrli.top/2020/10/18/emplace-back与push-back/</id>
    <published>2020-10-18T15:14:49.000Z</published>
    <updated>2020-10-25T07:08:58.265Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前看<a href="https://leetcode-cn.com/problems/find-common-characters/" target="_blank" rel="noopener">1002. 查找常用字符</a>题解的时候，发现有人用了emplace_back，将char转型成了string塞进了<code>vector&lt;string&gt;</code>，感觉是个骚操作。<br>之前也看过emplace_back和push_back的区别， 只不过又忘记了， 因此本次也算个防忘系列把…</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; minFreq[i]; j++) &#123;</span><br><span class="line">       <span class="comment">// emplace_back 骚操作</span></span><br><span class="line">      ans.emplace_back(<span class="number">1</span>, <span class="string">'a'</span> + i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>在STL中，进行插入元素的时候，有insert和push两种选择方式，而在有了<u>右值引用</u>和移动语义的时候，在C++11中就提出了更高效的插入方法：emplace_back</p><p>目前的趋势是希望：使用emplace_back()取代push_back()</p><p>据统计，emplace_back()函数要比push_back()函数要快一倍。</p></blockquote><p><img src="/2020/10/18/emplace-back与push-back/emplace_back.jpg" alt="emplace_back"></p><h2 id="empalce与push的区别"><a class="markdownIt-Anchor" href="#empalce与push的区别"></a> empalce与push的区别：</h2><ul><li>push_back()函数向容器中加入一个临时对象（右值元素）时， 首先会<u>调用构造函数</u>生成这个对象，然后调用<u>拷贝构造函数</u>将这个<strong>对象的拷贝</strong>放入容器中， 最后释放临时对象，这样造成的问题是临时变量申请的资源就浪费。但是emplace_back()函数向容器中中加入<strong>临时对象</strong>， 临时对象原地构造，只有转移的过程，没有赋值或拷贝的操作（不需要触发拷贝构造）。</li></ul><h2 id="emplace_back中调用构造函数"><a class="markdownIt-Anchor" href="#emplace_back中调用构造函数"></a> emplace_back中调用构造函数</h2><p><a href="https://en.cppreference.com/w/cpp/container/vector/emplace_back" target="_blank" rel="noopener">官网demo Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">President</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> country;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    President(<span class="built_in">std</span>::<span class="built_in">string</span> p_name, <span class="built_in">std</span>::<span class="built_in">string</span> p_country, <span class="keyword">int</span> p_year)</span><br><span class="line">        : name(<span class="built_in">std</span>::move(p_name)), country(<span class="built_in">std</span>::move(p_country)), year(p_year)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am being constructed.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转移构造函数</span></span><br><span class="line">    President(President&amp;&amp; other)</span><br><span class="line">        : name(<span class="built_in">std</span>::move(other.name)), country(<span class="built_in">std</span>::move(other.country)), year(other.year)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am being moved.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拷贝赋值操作符</span></span><br><span class="line">    President&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> President&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;President&gt; elections;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace_back:\n"</span>;</span><br><span class="line">    <span class="comment">// noted: 这边并没有写成President("Nelson Mandela", "South Africa", 1994)</span></span><br><span class="line">    elections.emplace_back(<span class="string">"Nelson Mandela"</span>, <span class="string">"South Africa"</span>, <span class="number">1994</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;President&gt; reElections;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\npush_back:\n"</span>;</span><br><span class="line">    reElections.push_back(President(<span class="string">"Franklin Delano Roosevelt"</span>, <span class="string">"the USA"</span>, <span class="number">1936</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nContents:\n"</span>;</span><br><span class="line">    <span class="keyword">for</span> (President <span class="keyword">const</span>&amp; president: elections) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; president.name &lt;&lt; <span class="string">" was elected president of "</span></span><br><span class="line">                  &lt;&lt; president.country &lt;&lt; <span class="string">" in "</span> &lt;&lt; president.year &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (President <span class="keyword">const</span>&amp; president: reElections) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; president.name &lt;&lt; <span class="string">" was re-elected president of "</span></span><br><span class="line">                  &lt;&lt; president.country &lt;&lt; <span class="string">" in "</span> &lt;&lt; president.year &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>▲看到noted标出来的地方后, 就能知道Leetcode题解中的骚操作其实就是根据T类型判断出了调用构造函数。按如下代码得证</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="string">'a'</span>+ <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// &gt;&gt;&gt; b</span></span><br></pre></td></tr></table></figure><hr><h3 id="引申什么是stdmove"><a class="markdownIt-Anchor" href="#引申什么是stdmove"></a> 引申：什么是std::move?</h3><p>借鉴:</p><p><a href="https://blog.csdn.net/p942005405/article/details/84644069/" target="_blank" rel="noopener">c++ 之 std::move 原理实现与用法总结</a></p><blockquote><p>在C++11中，标准库在<code>&lt;utility&gt;</code>中提供了一个有用的函数std::move，std::move并不能移动任何东西，它唯一的功能是将一个<u>左值强制转化为右值引用</u>，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue);</p></blockquote><p><a href="https://blog.csdn.net/p942005405/article/details/84644101" target="_blank" rel="noopener">左值、左值引用、右值、右值引用概念</a></p><ul><li>左值的声明符号为”&amp;”， 为了和左值区分，右值的声明符号为”&amp;&amp;”。</li><li>临时对象是作为右值处理的</li></ul><h3 id="右值引用的意义"><a class="markdownIt-Anchor" href="#右值引用的意义"></a> 右值引用的意义</h3><p>直观意义：为临时变量续命，也就是为右值续命，<u>因为右值在表达式结束后就消亡了</u>，如果想继续使用右值，那就会动用昂贵的拷贝构造函数。（关于这部分，推荐一本书《深入理解C<ins>11》）<br>右值引用是用来支持转移语义的。<u>转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C</u></ins> 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。<br>转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。<br>通过转移语义，临时对象中的资源能够转移其它的对象里。<br>在现有的 C++ 机制中，我们可以定义拷贝构造函数和赋值函数。要实现转移语义，需要定义转移构造函数，还可以定义转移赋值操作符。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。<br>普通的函数和操作符也可以利用右值引用操作符实现转移语义。</p><p><strong>extra：</strong></p><ol><li>std::move执行一个无条件的转化到右值。它本身并不移动任何东西；</li><li>std::forward把其参数转换为右值，仅仅在那个参数被绑定到一个右值时；</li><li>std::move和std::forward在运行时（runtime）都不做任何事。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;之前看&lt;a href=&quot;https://leetcode-cn.com/problems/find-common-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1002. 查找常用字符&lt;/a&gt;题解的时候，发
      
    
    </summary>
    
    
      <category term="C++" scheme="https://nymrli.top/tags/C/"/>
    
      <category term="防忘系列" scheme="https://nymrli.top/tags/%E9%98%B2%E5%BF%98%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>AutoLianliankan笔记</title>
    <link href="https://nymrli.top/2020/10/13/AutoLianliankan%E7%AC%94%E8%AE%B0/"/>
    <id>https://nymrli.top/2020/10/13/AutoLianliankan笔记/</id>
    <published>2020-10-13T10:58:47.000Z</published>
    <updated>2020-10-14T04:35:38.806Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>近来无事，又研究其了之前看到过的<a href="https://github.com/TheThreeDog/Auto-Lianliankan" target="_blank" rel="noopener">自动连连看的代码</a>，碰到了一些问题， 因此做下笔记</p></blockquote><p><strong>pywin32</strong></p><ul><li>win32gui：定位窗体，操作窗体</li><li>win32api：提供API，操作鼠标、键盘</li><li>win32con：具体API事件</li></ul><p>==&gt;对于窗体的操作使用win32gui；而对键盘、鼠标操作可以用更高级封装的库pymouse、pykeyboard；剪切板使用win32clipboard</p><h2 id="程序的设计"><a class="markdownIt-Anchor" href="#程序的设计"></a> 程序的设计：</h2><ol><li><code>getWindowPosition</code>=&gt;先确定游戏窗口位置pos，并置顶</li><li><code>getScreenImage()</code>==&gt;在窗口置顶后再截图</li><li><code>getAllSquare()</code>=&gt;找到游戏边界，<code>pos[0]+100</code>, <code>pos[1]+100</code>,即中间所有图块部分。切割出所有图案；<code>getAllSquareTypes()</code>将所有图案进行比较分类，归纳出所有不同的种类</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ndarray的切片方法，[纵坐标起始位置：纵坐标结束为止，横坐标起始位置：横坐标结束位置]</span></span><br><span class="line">square = screen_image[game_y + y * SQUARE_HEIGHT :game_y + (y+<span class="number">1</span>) * SQUARE_HEIGHT,</span><br><span class="line">                      game_x + x * SQUARE_WIDTH:game_x + (x+<span class="number">1</span>) * SQUARE_WIDTH]</span><br><span class="line"><span class="comment"># np.shape(square) == (65, 65, 3)</span></span><br><span class="line"><span class="comment"># 因为有些图片的边缘不一致造成干扰（主要是空白区域的切图），所以把每张小方块向内缩小一部分再</span></span><br><span class="line"><span class="comment"># 对所有的方块进行处理屏蔽掉外边缘 然后返回</span></span><br><span class="line"><span class="keyword">return</span> [square[SUB_LT_Y:SUB_RB_Y, SUB_LT_X:SUB_RB_X] <span class="keyword">for</span> square <span class="keyword">in</span> all_square]</span><br></pre></td></tr></table></figure><ol start="4"><li><code>getAllSquareRecord()</code>==&gt;将不同种类的图案做映射，转换成相对应的数字矩阵。</li><li><code>autoRemove(result, board_pos)</code>==&gt;执行自动消除</li><li><code>Matcher类</code>==&gt;实现游戏规则: 横消，纵消， 单拐点消除，双拐点消除。需要注意跟QQ连连看不同的是没有实现更高阶的拐点消除。</li></ol><h2 id="附录-遇到的问题"><a class="markdownIt-Anchor" href="#附录-遇到的问题"></a> 附录: 遇到的问题</h2><h3 id="列表的清空"><a class="markdownIt-Anchor" href="#列表的清空"></a> <a href="https://www.cnblogs.com/BackingStar/p/10986775.html" target="_blank" rel="noopener">列表的清空</a></h3><p>代码中有一段，在line满了后，会将line清空，再添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> len(line) == V_NUM:</span><br><span class="line">    result.append(line)</span><br><span class="line">    line = []</span><br></pre></td></tr></table></figure><p>注意： 这边的写法<code>line = []</code>是可行的。而<code>line.clear()</code>是不行的。原因是涉及<strong>内存空间引用问题</strong></p><p>原因在于: <code>list.clear()</code>会清除当前变量指向的内存地址内容，而<code>line = []</code>其实是指向了另一块地址。因此导致了最终的结果是<code>line = []</code>的result为<code>[[1,2,3...], [2, 3, 4...]]</code>；而<code>list.clear()</code>的result全为空<code>[[],[],[]]]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a= [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(id(a))</span><br><span class="line"><span class="comment"># 1785191184200</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">print(id(a))</span><br><span class="line"><span class="comment"># 1785191276296</span></span><br><span class="line">a.clear()</span><br><span class="line">print(id(a))</span><br><span class="line"><span class="comment"># 1785191276296</span></span><br></pre></td></tr></table></figure><h3 id="图片的维度问题"><a class="markdownIt-Anchor" href="#图片的维度问题"></a> 图片的维度问题:</h3><p>开源代码提供的empty.png图片规格为: 25*21像素。而25对应的为y， 21对应的为x。而需要注意的是在代码中，表达为<code>img[0: 25, 0: 21]</code></p><h3 id="getwindowrect窗口大小有误"><a class="markdownIt-Anchor" href="#getwindowrect窗口大小有误"></a> GetWindowRect窗口大小有误</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取窗体坐标位置(左上)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getGameWindowPosition</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># FindWindow(lpClassName=None, lpWindowName=None)  窗口类名 窗口标题名</span></span><br><span class="line">    window = win32gui.FindWindow(<span class="keyword">None</span>,WINDOW_TITLE)</span><br><span class="line">    <span class="comment"># 没有定位到游戏窗体</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> window:</span><br><span class="line">        print(<span class="string">'定位游戏窗体失败，5秒后重试...'</span>)</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        window = win32gui.FindWindow(<span class="keyword">None</span>,WINDOW_TITLE)</span><br><span class="line">    <span class="comment"># 定位到游戏窗体</span></span><br><span class="line">    win32gui.SetForegroundWindow(window) <span class="comment"># 将窗体顶置</span></span><br><span class="line">    pos = win32gui.GetWindowRect(window)</span><br><span class="line">    print(<span class="string">"定位到游戏窗体："</span> + str(pos))</span><br><span class="line">    <span class="keyword">return</span> (pos[<span class="number">0</span>],pos[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>如图操作下来, 发现返回的pos为(408, 172)，但用spy++抓到的窗口左上角坐标为(510, 215)，研究发现横、纵都是1.25倍， 以为是分辨率的问题，所以打开了“显示设置”，结果正好看到了缩放布局是125%，因此问题可能出现在这个设置上，果然修改为100%后，程序能够正常运行。</p><p>额外，百度也找到了这个问题——<a href="https://blog.csdn.net/snfdess/article/details/104169771?utm_medium=distribute.pc_relevant.none-task-blog-title-2&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">win32gui.GetWindowRect在win10上获取窗口宽高不正确的另一种可能</a>; <a href="https://blog.csdn.net/See_Star/article/details/103940462" target="_blank" rel="noopener">win32gui.GetWindowRect() 取值不准的解决方案</a>——亲测这个无效</p><h2 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录:</h2><p>config.py中需要注意的设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方块宽度(算上了边界)</span></span><br><span class="line">SQUARE_WIDTH = <span class="number">65</span></span><br><span class="line"><span class="comment"># 方块高度(算上了边界)</span></span><br><span class="line">SQUARE_HEIGHT = <span class="number">65</span></span><br><span class="line"><span class="comment"># ==&gt; 所以每块的大小为(65, 65, 3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片处理时候的左上、右下坐标：</span></span><br><span class="line"><span class="comment"># 注意  这里要么保证是21*25(因为开源代码里的empty.png提供的是21*25像素的)。如果不是（比如四个数据是10,10,50,50；也就是40*40像素），那么就把empty.png图片替换成对应大小的一张图片（比如40*40）。图片可以没用，但程序中不能</span></span><br><span class="line">SUB_LT_X = <span class="number">5</span></span><br><span class="line">SUB_LT_Y = <span class="number">5</span></span><br><span class="line"><span class="comment"># 下面两个值得小于60, 因此还有5是边界</span></span><br><span class="line">SUB_RB_X = <span class="number">26</span></span><br><span class="line">SUB_RB_Y = <span class="number">30</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;近来无事，又研究其了之前看到过的&lt;a href=&quot;https://github.com/TheThreeDog/Auto-Lianliankan&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;自动连连看的代码&lt;/a&gt;，碰到了一些问
      
    
    </summary>
    
    
      <category term="GitCode" scheme="https://nymrli.top/tags/GitCode/"/>
    
  </entry>
  
  <entry>
    <title>docsify使用记录</title>
    <link href="https://nymrli.top/2020/09/15/docsify%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://nymrli.top/2020/09/15/docsify使用记录/</id>
    <published>2020-09-15T02:30:43.000Z</published>
    <updated>2020-09-15T07:45:46.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docsify-是什么"><a class="markdownIt-Anchor" href="#docsify-是什么"></a> <em>Docsify</em> 是什么？</h2><p><em>Docsify</em> 一个神奇的<strong>动态生成文档网站的工具</strong>。<br>不同于 GitBook、Hexo 的地方是它不会生成将 <code>.md</code> 转成 <code>.html</code> 文件，所有转换工作都是<u>在运行时进行</u>。</p><p>较多使用的场景是GitHub中对某一开源程序的文档介绍，由于docsify的主题较为好看， 且轻量、易使用，因此使用也较为广泛。同时它也支持很多插件来丰富功能。但跟Hexo相比，个人感官上Hexo更适合做个人博客， 而docsify更适合专门来写程序的介绍文档</p><hr><blockquote><p>春招的时候背了很多的面经， 只不过秋招回头来看基本上又都记不太清了，于是想自己整理些面经笔记啥的。 之前也试过在个人博客上发表， 只不过感觉还是不适合阅读，因此正好想起来之前了解过Docsify，因此这次打算在写面经的时候顺便也练习、熟练下Docsify。</p></blockquote><p><a href="https://docsify.js.org/#/zh-cn/quickstart" target="_blank" rel="noopener">官方文档快速使用</a>介绍的很全了，先贴个官方文档。</p><h2 id="start-to-run-it"><a class="markdownIt-Anchor" href="#start-to-run-it"></a> Start to Run it</h2><p>1.安装docsify工具:<code>npm i docsify-cli -g</code><br>2.初始化项目: <code>docsify init [./docs]</code> , []中内容为指定生成目录, 不填默认为当前目录<br>初始化成功后，可以看到生成 目录下创建的几个文件</p><ul><li><code>index.html</code> 入口文件、插件等配置都写在这</li><li><code>README.md</code> 会做为<u>主页内容</u>渲染，编辑即可更新文档内容</li><li><code>.nojekyll</code> 用于阻止 GitHub Pages 忽略掉下划线开头的文件</li></ul><p>3.预览效果： <code>docsify serve [docs]</code>， 通过运行 <code>docsify serve</code> 启动一个本地服务器，可以方便地实时预览效果。默认访问地址 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000</a> 。</p><hr><h2 id="多页文档"><a class="markdownIt-Anchor" href="#多页文档"></a> <a href="https://docsify.js.org/#/zh-cn/more-pages?id=%E5%A4%9A%E9%A1%B5%E6%96%87%E6%A1%A3" target="_blank" rel="noopener">多页文档</a></h2><h2 id="定制化"><a class="markdownIt-Anchor" href="#定制化"></a> <a href="https://docsify.js.org/#/zh-cn/configuration" target="_blank" rel="noopener">定制化</a></h2><ul><li><p>自定义导航栏: 设置为 <code>true</code> 后会加载 <code>_navbar.md</code> 文件，也可以自定义文件名。</p></li><li><p>自定义侧边栏: 设置为 <code>true</code> 后会加载 <code>_sidebar.md</code> 文件，也可以自定义文件名。</p></li><li><p>启用<a href="https://docsify.js.org/#/zh-cn/cover" target="_blank" rel="noopener">封面页</a>: 开启后是加载 <code>_coverpage.md</code> 文件，也可以自定义文件名。</p></li><li><h3 id="markdown"><a class="markdownIt-Anchor" href="#markdown"></a> <a href="https://docsify.js.org/#/zh-cn/configuration?id=markdown" target="_blank" rel="noopener">markdown</a>配置</h3></li></ul><h2 id="插件"><a class="markdownIt-Anchor" href="#插件"></a> 插件</h2><p>index.html</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">window</span>.$docsify = &#123;</span><br><span class="line">        name: <span class="string">'Java工程师成神之路'</span>,</span><br><span class="line">        repo: <span class="string">'https://github.com/hollischuang/toBeTopJavaer'</span>,</span><br><span class="line">          loadSidebar: <span class="literal">true</span>,</span><br><span class="line">        subMaxLevel: <span class="number">3</span>,</span><br><span class="line">        autoHeader: <span class="literal">true</span>,</span><br><span class="line">        search: &#123;</span><br><span class="line">            paths: <span class="string">'auto'</span>,</span><br><span class="line">            placeholder: <span class="string">'🔍 搜索 '</span>,</span><br><span class="line">            noData: <span class="string">'哎呀，没有找到呀！ '</span>,</span><br><span class="line">            <span class="comment">// Headline depth, 1 - 6</span></span><br><span class="line">            depth: <span class="number">3</span></span><br><span class="line">        &#125;,</span><br><span class="line">        copyCode: &#123;</span><br><span class="line">            buttonText : <span class="string">'复制'</span>,</span><br><span class="line">            errorText  : <span class="string">'Error'</span>,</span><br><span class="line">            successText: <span class="string">'OK!'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        pagination: &#123;</span><br><span class="line">            previousText: <span class="string">'上一章'</span>,</span><br><span class="line">            nextText: <span class="string">'下一章'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        coverpage: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="/</span><span class="regexp">/unpkg.com/</span>docsify/lib/docsify.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;!--代码块复制插件--&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span><span class="comment">//unpkg.com/docsify-copy-code"&gt;&lt;/script&gt;</span></span><br><span class="line">&lt;!-- 图片缩放插件 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://cyc-1256109796.cos.ap-guangzhou.myqcloud.com/zoom-image.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;!--搜索插件--&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/docsify/4.5.9/plugins/search.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;!--语法高亮插件--&gt;</span><br><span class="line">&lt;script src=<span class="string">"//unpkg.com/prismjs/components/prism-java.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">"//unpkg.com/prismjs/components/prism-bash.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;!--分页插件--&gt;</span><br><span class="line">&lt;script src=<span class="string">"//unpkg.com/docsify-pagination/dist/docsify-pagination.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;!--统计访问量插件--&gt;</span><br><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录：</h2><p><a href="https://github.com/hollischuang/toBeTopJavaer" target="_blank" rel="noopener">To Be Top Javaer - Java工程师成神之路</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;docsify-是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docsify-是什么&quot;&gt;&lt;/a&gt; &lt;em&gt;Docsify&lt;/em&gt; 是什么？&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Docsify&lt;/em&gt; 一个神奇的&lt;strong&gt;动态生成文
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>扇区、块/簇</title>
    <link href="https://nymrli.top/2020/09/06/%E6%89%87%E5%8C%BA%E3%80%81%E5%9D%97-%E7%B0%87/"/>
    <id>https://nymrli.top/2020/09/06/扇区、块-簇/</id>
    <published>2020-09-06T06:29:31.000Z</published>
    <updated>2020-09-06T07:04:38.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扇区"><a class="markdownIt-Anchor" href="#扇区"></a> 扇区</h2><p><strong>概念：</strong> 扇区，顾名思义，每个磁盘有多条同心圆似的磁道，磁道被分割成多个部分。每部分的弧长加上到圆心的两个半径，恰好形成一个扇形，所以叫做扇区。<strong>扇区是磁盘中最小的物理存储单位。</strong></p><h3 id="扇区大小-512b-4kb"><a class="markdownIt-Anchor" href="#扇区大小-512b-4kb"></a> 扇区大小: 512B -&gt; 4KB</h3><p>扇区(Sector)大小是固定的，默认情况下，每个扇区（Sector）为512字节，2009年后，硬盘厂商开始发布4KB字节扇区的硬盘了，4KB扇区硬盘已经在消费级市场广泛应用。但是<strong>同一块硬盘上的扇区大小一定是一致的</strong>。不可能存在多种不同大小的扇区。</p><h3 id="逻辑扇区-物理扇区"><a class="markdownIt-Anchor" href="#逻辑扇区-物理扇区"></a> 逻辑扇区、物理扇区</h3><p>物理扇区是磁盘上真实存在对应的扇区；</p><p>逻辑扇区是由于扇区大小由512B变成4KB后， 为了与老系统兼容，操作系统层面上提出来的一个概念，是为了方便操作系统读取写入硬盘数据而设置的， 给系统进行识别后，可以通过一定的公式与物理地址对应再找到到指定的物理扇区上去。</p><h4 id="由来"><a class="markdownIt-Anchor" href="#由来"></a> 由来</h4><p>关于物理扇区（physical setctor）与逻辑扇区，这个还得扯上<strong>扇区大小</strong>，由于近年来，随着对硬盘容量的要求不断增加，为了提高数据记录密度，硬盘厂商往往采用增大扇区大小的方法，于是出现了扇区大小为4096字节的硬盘。我们将这样的扇区称之为“物理扇区”。但是这样的<strong>大扇区会有兼容性问题</strong>，有的系统或软件无法适应。为了解决这个问题，硬盘内部将物理扇区在逻辑上划分为多个扇区片段并将其作为普通的扇区（一般为512字节大小）报告给操作系统及应用软件。这样的扇区片段我们称之为“逻辑扇区”。实际读写时由硬盘内的程序（固件）负责在逻辑扇区与物理扇区之间进行转换，<strong>上层程序“感觉”不到物理扇区的存在</strong>。</p><p><u>逻辑扇区是硬盘可以接受读写指令的最小操作单元，是操作系统及应用程序可以访问的扇区</u>，多数情况下其大小为512字节。<u>我们通常所说的扇区一般就是指的逻辑扇区。物理扇区是硬盘底层硬件意义上的扇区</u>，是实际执行读写操作的最小单元。是只能由硬盘直接访问的扇区，操作系统及应用程序一般无法直接访问物理扇区。一个物理扇区可以包含一个或多个逻辑扇区（比如多数硬盘的物理扇区包含了8个逻辑扇区）。当要读写某个逻辑扇区时，硬盘底层在实际操作时都会读写逻辑扇区所在的整个物理扇区。</p><p>参考： <a href="https://www.cnblogs.com/kerrycode/p/12701772.html" target="_blank" rel="noopener">存储基础知识：扇区与块/簇</a>——带物理结构图</p><h2 id="块簇"><a class="markdownIt-Anchor" href="#块簇"></a> 块/簇</h2><p>**概念：**块（Block）/簇（Cluster）是逻辑上的概念，或者说是虚拟出来的概念（逻辑概念）。 分别对应Linux与Windows操作系统中的概念。</p><p>通俗的来讲，在Windows下如NTFS等文件系统中叫做簇；在Linux下如Ext4等文件系统中叫做块（block）。每个簇或者块可以包括2、4、8、16、32、64…2048、4096等2的n次方个扇区。</p><h3 id="为什么要用磁盘块簇"><a class="markdownIt-Anchor" href="#为什么要用磁盘块簇"></a> <strong>为什么要用磁盘块/簇？</strong></h3><p>A：</p><ul><li>读取方便：由于扇区的Size比较小，数目众多时寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。(操作系统通过操作块， 来间接操作底层磁盘对扇区的读取，先找街道再找门户)</li><li>分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为块是最小的单位。</li></ul><h2 id="扇区与块簇的区别"><a class="markdownIt-Anchor" href="#扇区与块簇的区别"></a> 扇区与块/簇的区别</h2><p><strong>磁盘的读写基本单位</strong>是扇区。</p><ul><li><strong>磁盘</strong>的原理，物理实现，磁盘控制器是<strong>按照扇区这个单位读取等操作数据</strong>的。</li></ul><p>文件系统就是操作系统的一部分，所以**文件系统读写(操作文件)**的最小单位是块。</p><ul><li><strong>操作系统</strong>是通过<strong>块/簇来做为单位读取等操作数据</strong>的。</li></ul><p>and</p><p>从磁盘的物理结构来看存取信息的最小单位是扇区，一个扇区是512字节；</p><p>从操作系统对硬盘的存取管理来看，存取信息的最小单位是簇，簇是一个<strong>逻辑概念</strong>，一个簇可以是2、4、8、16、32或64个连续的扇区。</p><p><strong>一个簇只能被一个文件占用</strong>，哪怕是只有1个字节的文件，在磁盘上存储时也要占用一个簇，这个簇里剩下的扇区是无用的。例如用NTFS文件系统格式化的时候默认是<strong>8个扇区组成一个簇</strong>，即4096字节。所以你如果保存了一个只有1字节的文件（例如字母N），它在磁盘上实际也要占用4096字节（4K），所以“簇”也可以理解为操作系统存取信息的最小单位。</p><h3 id="qa"><a class="markdownIt-Anchor" href="#qa"></a> QA:</h3><h4 id="q-为什么磁盘块大小必须是扇区大小的整数倍呢"><a class="markdownIt-Anchor" href="#q-为什么磁盘块大小必须是扇区大小的整数倍呢"></a> <strong>Q、为什么磁盘块大小必须是扇区大小的整数倍呢？</strong></h4><p>A: 磁盘读取数据的基本单位就是一个扇区的大小，一个块的大小对于磁盘来说就是一次获取数据读取的扇区数*扇区大小，如果是整数倍的扇区数对于磁盘的IO更好，速度更快，也会更合理的利用资源。否则会对扇区进行分割。</p><h4 id="q-那么分成大簇和小簇有什么区别呢"><a class="markdownIt-Anchor" href="#q-那么分成大簇和小簇有什么区别呢"></a> Q、那么分成“大簇”和“小簇”有什么区别呢？</h4><p>A：我如果硬盘下很多小文件，那么每一个小文件，都会占用一个“簇”。虽然这些小文件都小于一个“簇”。<br>“大簇”和“小簇”当然有很多区别，但是最大的区别是：“小簇”会节省空间，而“大簇”则反之。“大簇”的优势在于有益于文件的读取存取，简单而不严谨的说就是提升硬盘性能。<br>“大簇”——读取存取速度快，占用空间大<br>“小簇”——读取存取速度慢，占用空间小<br>而现在TB时代，即便是“大簇”大家完全也HOLD住，即便你全部是几KB、几字节的小文件。“大簇”盘也不会“小簇”盘多占出太多空间，但是性能的提升确是最少几倍的，特别是面对大型程序或者游戏的时候。</p><h2 id="4k"><a class="markdownIt-Anchor" href="#4k"></a> 4K</h2><blockquote><p><strong>4K对齐</strong>的意思是对齐到磁盘开头的4K这个数值。和<strong>按4K来格式化</strong>不是一回事。</p></blockquote><p>Ans1: 4K对齐</p><p>随着时代发展，硬盘容量不断扩展，使得之前定义的每个扇区512字节不再是那么的合理，于是将每个扇区512字节改为每个扇区4096 个字节，也就是现在常说的“4K扇区”。随着<strong>NTFS</strong>成为了标准的硬盘文件系统，其文件系统的默认分配单元大小（簇）也是<strong>4096字节</strong>，为了使簇与扇区相对应，即使物理硬盘分区与计算机使用的逻辑分区对齐，保证硬盘读写效率，所以就有了“4K对齐”的概念。</p><p>新标准的”4K扇区”的硬盘在厂商为了保证与操作系统兼容的前提下，也将<strong>扇区模拟成512B</strong>（逻辑扇区），会<u>默认</u>定义为4096字节大小为一个簇，但因为其引导区占用了一个磁道共63个扇区，真正的文件系统在63号扇区之后。<br>我们通过计算得出前63个扇区大小为：512Bx63=32256B。并按照默认簇大小得出63扇区为：32256B÷4096B=7.875簇<br>即<strong>从第63个扇区结束，往后的每一个簇都会跨越两个物理单元，占据前一个单元的一小部分和后一个单元的一大部分</strong>。</p><p>而“4K对齐”主要是将硬盘的模拟扇区(512B)对齐到8的整数倍个“实际”4K扇区，即4096B*8=32768B，其正好跨过了63扇区的特性，从第64个扇区对齐。</p><p>Ans2: 4K格式化</p><p>4k对齐是硬盘分区中的一个专业术语，4K对齐就是符合<strong>4K扇区定义格式化</strong>过的硬盘，并且按照<strong>4K扇区的规则写入数据</strong>。一般来说，在给固态硬盘进行分区的时候，一定要勾选上4K对齐，否则会影响到SSD固态硬盘的性能与寿命。通俗的说，<u>如果SSD不进行4K对齐，写入数据的写入点正好会介于两个4K扇区的之间</u>，也就是说即使是写入最小量的数据，也会使用到两个4K扇区，这样会造成跨区读写，读写次数放大，从而影响磁盘性能。</p><p>SSD中的4K对齐的4K指4096字节，其中<strong>1个扇区为512字节</strong>。固态硬盘4K对齐中的<strong>2048是指2048个扇区</strong>，即<br>512B*2048=1048576B=1024KB，即<strong>1M对齐</strong>（4096就是2MB对齐），并满足4K对齐，该值只要是<strong>4096B的倍数</strong>就是4K对齐，理论上4K对齐只要是4096整数倍就可以，不过标准的一般都是选择4096。从实测来看，固态硬盘4K对齐选2048还是4096，性能区别并不大，小容量固态硬盘4K对齐，选择2048扇区对齐是可以的。而在<u>Win10</u>或者<u>大容量SSD</u>场景下，建议还是选默认的4096扇区对齐。</p><h2 id="分区操作"><a class="markdownIt-Anchor" href="#分区操作"></a> 分区操作</h2><p><img src="/2020/09/06/扇区、块-簇/1.png" alt="1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;扇区&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#扇区&quot;&gt;&lt;/a&gt; 扇区&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;概念：&lt;/strong&gt; 扇区，顾名思义，每个磁盘有多条同心圆似的磁道，磁道被分割成多个部分。每部分的弧长加上到圆心的两个半径，
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://nymrli.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>SQL练习</title>
    <link href="https://nymrli.top/2020/09/04/SQL%E7%BB%83%E4%B9%A0/"/>
    <id>https://nymrli.top/2020/09/04/SQL练习/</id>
    <published>2020-09-04T07:54:57.000Z</published>
    <updated>2020-11-08T05:12:45.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sql练习"><a class="markdownIt-Anchor" href="#sql练习"></a> SQL练习</h1><blockquote><p>鉴于同学被字节狂问SQL题，因此也激发了我的危机感。 作为非科班的， 写SQL还是比较慌的， 因此做下专题训练。</p></blockquote><h2 id="理论知识"><a class="markdownIt-Anchor" href="#理论知识"></a> 理论知识:</h2><p>SQL语句执行顺序</p><h3 id="1sql执行顺序"><a class="markdownIt-Anchor" href="#1sql执行顺序"></a> 1.<a href="https://www.cnblogs.com/yyjie/p/7788428.html" target="_blank" rel="noopener">sql执行顺序 </a></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(1) from </span><br><span class="line">(3) join </span><br><span class="line">(2) on </span><br><span class="line">(4) where </span><br><span class="line">(5) group by(开始使用<span class="keyword">select</span>中的别名，后面的语句中都可以使用)</span><br><span class="line">(<span class="number">6</span>) <span class="keyword">avg</span>,sum.... </span><br><span class="line">(<span class="number">7</span>) <span class="keyword">having</span> </span><br><span class="line">(<span class="number">8</span>) <span class="keyword">select</span> </span><br><span class="line">(<span class="number">9</span>) <span class="keyword">distinct</span> </span><br><span class="line">(<span class="number">10</span>) <span class="keyword">order</span> <span class="keyword">by</span></span><br></pre></td></tr></table></figure><p>2.<a href="https://blog.csdn.net/u013887008/article/details/93377939" target="_blank" rel="noopener">sql语句执行顺序</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(8) <span class="keyword">SELECT</span> (<span class="number">9</span>)<span class="keyword">DISTINCT</span>&lt;select_list&gt;</span><br><span class="line">(<span class="number">1</span>) <span class="keyword">FROM</span> &lt;left_table&gt;</span><br><span class="line">(<span class="number">3</span>) &lt;join_type&gt; <span class="keyword">JOIN</span> &lt;right_table&gt;</span><br><span class="line">(<span class="number">2</span>)         <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line">(<span class="number">4</span>) <span class="keyword">WHERE</span> &lt;where_condition&gt;</span><br><span class="line">(<span class="number">5</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;group_by_list&gt;</span><br><span class="line">(<span class="number">6</span>) <span class="keyword">WITH</span> &#123;<span class="keyword">CUBE</span>|<span class="keyword">ROLLUP</span>&#125;</span><br><span class="line">(<span class="number">7</span>) <span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line">(<span class="number">10</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_list&gt;</span><br><span class="line">(<span class="number">11</span>) <span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure><h3 id="用group-by需要注意的"><a class="markdownIt-Anchor" href="#用group-by需要注意的"></a> 用<code>group by</code>需要注意的:</h3><ul><li>在select<strong>指定的字段</strong><ul><li>要么就是<strong>包含在Group By语句</strong>的后面，为作为分组的依据的字段；</li><li>要么就要<strong>被包含在聚合函数</strong>中, e…g: <code>sum, avg, count</code>。</li></ul></li></ul><h3 id="sql查询语句中的-limit-与-offset-的区别"><a class="markdownIt-Anchor" href="#sql查询语句中的-limit-与-offset-的区别"></a> SQL查询语句中的 limit 与 offset 的区别：</h3><ul><li><code>limit y</code> 分句表示: 读取 y 条数据</li><li><code>limit x, y</code> 分句表示: 跳过 x 条数据，读取 y 条数据</li><li><code>limit y offset x</code> 分句表示: 跳过 x 条数据，读取 y 条数据</li></ul><h4 id="分页操作"><a class="markdownIt-Anchor" href="#分页操作"></a> 分页操作</h4><p>语法：limit开始索引，每页查询的记录数<br>注：索引从0开始<br><code>公式：开始索引=（当前页码-1）*每页查询的记录数</code>即 <code>index = (nowPageNum - 1) * pageSize</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> </span><br><span class="line"><span class="keyword">WHERE</span> 查询条件 </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序条件 </span><br><span class="line"><span class="keyword">LIMIT</span> ((页码<span class="number">-1</span>)*页大小),页大小;</span><br><span class="line"><span class="comment">-- LIMIT (pageNum-1)*pageSize, pageSize</span></span><br><span class="line"><span class="comment">-- 第一个参数是偏移量， 第二个是所取数据数</span></span><br></pre></td></tr></table></figure><h3 id="引号区别"><a class="markdownIt-Anchor" href="#引号区别"></a> 引号区别</h3><blockquote><p>在标准 SQL 中，字符串使用的是<strong>单引号</strong>。<br>如果字符串本身也包括单引号，则使用两个单引号（注意，不是双引号，字符串中的双引号不需要另外转义）。<br>但在其它的数据库中可能存在对 SQL 的扩展，比如在 MySQL 中允许使用单引号和双引号两种。</p></blockquote><p>MySQL 参考手册：</p><blockquote><p>字符串指用单引号<code>'</code>或双引号<code>&quot;</code>引起来的字符序列。例如：<br>‘a string’<br>“another string”<br>如果SQL服务器模式启用了NSI_QUOTES，可以只用单引号引用字符串。用双引号引用的字符串被解释为一个识别符。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">使用双字符:</span><br><span class="line">插入时          库中</span><br><span class="line">'aa''b''cc'     aa'b'cc</span><br><span class="line">"aa"b""cc"      aa"b"cc</span><br><span class="line"></span><br><span class="line">使用转义字符(\):</span><br><span class="line">插入时          库中</span><br><span class="line">'aa\'b\'cc'     aa'b'cc</span><br><span class="line">"aa\"b\"cc"     aa"b"cc</span><br><span class="line"></span><br><span class="line">在单引号包裹的字符串中使用双引号、在双引号包裹的字符串中使用单引号 不需要使用双引号或转义字符。</span><br><span class="line">插入时          库中</span><br><span class="line">"aa'b'cc"       aa'b'cc</span><br><span class="line">'aa"b"cc'       aa"b"cc</span><br></pre></td></tr></table></figure><p>反引号（`）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">保留字不能用于表名，比如desc，此时需要加入反引号来区别，但使用表名时可忽略反引号。</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">desc</span>报错</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`desc`</span>成功</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`test`</span>成功</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">test</span>成功</span><br><span class="line"> </span><br><span class="line">保留字不能用于字段名，比如<span class="keyword">desc</span>，此时也需要加入反引号，并且<span class="keyword">insert</span>等使用时也要加上反引号。</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`test`</span>（<span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">255</span>)）成功</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">desc</span>) <span class="keyword">values</span>(<span class="string">'fxf'</span>)失败</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="string">`desc`</span>) <span class="keyword">values</span>(<span class="string">'fxf'</span>)成功</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/ZHUYUEHE/article/details/50377636?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.pc_relevant_is_cache&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.pc_relevant_is_cache" target="_blank" rel="noopener">+号</a></p><p><u>字符串数据</u>是用单引号包在外面的，而<u>+号</u>只是用来连接这些字符串的. 数据库里的字段是整型的时候不要加单引号，是字符串的时候要加，其它类型根据实际情况来,双引号就是用来拼接字符串的，单引号是sql文的固有写法，因为你要动态的来拼接，涉及到变量，所以要用“+”来组合各个字符串片段。最终结果无非就是得出能在数据库查询分析器中执行的sql文。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String sql = "<span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span> ( <span class="string">" + student.getId() + "</span> ,<span class="string">' "</span></span><br><span class="line"><span class="string">        + student.getUsername() + " '</span>,  <span class="string">" + student.getAge() + "</span> ,<span class="string">' "</span></span><br><span class="line"><span class="string">        + student.getClassnumber()+" '</span>)<span class="string">";</span></span><br></pre></td></tr></table></figure><p>因为id和age是int型的所以不用加单引号，你的Username在数据库中定义的是一个varchar型的,而对字符型进行条件查询的时候是要加 ’ '号的：<code>select count(*) from student where username= 'aaa '</code><br>因此在后台写查询字符串的时候就必须这样写: <code>string sql = &quot;select count(*) from student where username= ' &quot;+userName+ &quot; ' &quot;</code>，这样映射成的查询语句就是: <code>select count(*) from student where student= 'aaa '</code> 了.</p><hr><p>题目</p><h2 id="1-查找最晚入职员工的所有信息入门题"><a class="markdownIt-Anchor" href="#1-查找最晚入职员工的所有信息入门题"></a> 1<a href="https://www.nowcoder.com/practice/218ae58dfdcd4af195fff264e062138f?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 查找最晚入职员工的所有信息</a>(入门题)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">order</span> <span class="keyword">by</span> hire_date <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="2查找入职员工时间排名倒数第三的员工所有信息"><a class="markdownIt-Anchor" href="#2查找入职员工时间排名倒数第三的员工所有信息"></a> 2<a href="https://www.nowcoder.com/practice/ec1ca44c62c14ceb990c3c40def1ec6c?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">查找入职员工时间排名倒数第三的员工所有信息</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> hire_date <span class="keyword">desc</span> <span class="comment">-- 递减排序</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">2</span>,<span class="number">1</span> ;<span class="comment">-- offset 2， 取1</span></span><br></pre></td></tr></table></figure><h3 id="sql查询语句中的-limit-与-offset-的区别-2"><a class="markdownIt-Anchor" href="#sql查询语句中的-limit-与-offset-的区别-2"></a> SQL查询语句中的 limit 与 offset 的区别：</h3><ul><li><code>limit y</code> 分句表示: 读取 y 条数据</li><li><code>limit x, y</code> 分句表示: 跳过 x 条数据，读取 y 条数据</li><li><code>limit y offset x</code> 分句表示: 跳过 x 条数据，读取 y 条数据</li></ul><h2 id="3-查找各个部门当前领导当前薪水详情以及其对应部门编号dept_no"><a class="markdownIt-Anchor" href="#3-查找各个部门当前领导当前薪水详情以及其对应部门编号dept_no"></a> 3<a href="https://www.nowcoder.com/practice/c63c5b54d86e4c6d880e4834bfd70c3b?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 查找各个部门当前领导当前薪水详情以及其对应部门编号dept_no</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.*, d.dept_no </span><br><span class="line"><span class="keyword">from</span> salaries <span class="keyword">as</span> s</span><br><span class="line">    <span class="keyword">join</span> dept_manager <span class="keyword">as</span> d</span><br><span class="line">    <span class="keyword">on</span> s.emp_no = d.emp_no</span><br><span class="line"><span class="keyword">where</span> d.to_date=<span class="string">'9999-01-01'</span> <span class="keyword">and</span> s.to_date=<span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> s.emp_no;</span><br></pre></td></tr></table></figure><h2 id="4-查找所有已经分配部门的员工的last_name和first_name"><a class="markdownIt-Anchor" href="#4-查找所有已经分配部门的员工的last_name和first_name"></a> 4<a href="https://www.nowcoder.com/practice/6d35b1cd593545ab985a68cd86f28671?tpId=82&amp;rp=1&amp;ru=%2Fta%2Fsql&amp;qru=%2Fta%2Fsql%2Fquestion-ranking" target="_blank" rel="noopener"> 查找所有已经分配部门的员工的last_name和first_name</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.last_name, e.first_name, d.dept_no </span><br><span class="line"><span class="keyword">from</span> employees e </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> dept_emp d </span><br><span class="line"><span class="keyword">on</span> e.emp_no = d.emp_no;</span><br></pre></td></tr></table></figure><h2 id="5查找所有员工的last_name和first_name以及对应部门编号dept_no"><a class="markdownIt-Anchor" href="#5查找所有员工的last_name和first_name以及对应部门编号dept_no"></a> 5<a href="https://www.nowcoder.com/practice/dbfafafb2ee2482aa390645abd4463bf?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">查找所有员工的last_name和first_name以及对应部门编号dept_no</a></h2><blockquote><p>暂时没有分配具体部门的员工==&gt; employees有信息, 而dept_emp表中可能还没有信息；两表联合查询时以employees为准， 匹配不到dept_emp的数据用null填充—&gt;所以用外部联结的左联结</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.last_name, e.first_name, d.dept_no </span><br><span class="line"><span class="keyword">from</span> employees e</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> dept_emp d</span><br><span class="line"><span class="keyword">on</span> e.emp_no = d.emp_no</span><br></pre></td></tr></table></figure><h3 id="join"><a class="markdownIt-Anchor" href="#join"></a> join</h3><h4 id="内联结inner-join"><a class="markdownIt-Anchor" href="#内联结inner-join"></a> 内联结(Inner join)</h4><p>联接仅返回<u>两个联接表中都具有匹配项的行</u>。例如，您可以将employees和<em>departments</em>表联接在一起，以创建一个显示每个雇员的部门名称的结果集。在内部联接中，<u>没有部门信息的雇员不包括在结果集中，没有雇员的部门也不会包括在结果集中</u>。</p><h4 id="外联结outer-join"><a class="markdownIt-Anchor" href="#外联结outer-join"></a> 外联结(Outer join)</h4><p>外联接是内部联接的扩展。 即使外联接在联接表中没有相关行，外联接也会返回这些行。 外联接共有三种类型：左联接（<a href="https://www.nhooo.com/sql/sql-left-join-operation.html" target="_blank" rel="noopener">left join</a>），右联接（<a href="https://www.nhooo.com/sql/sql-right-join-operation.html" target="_blank" rel="noopener">right join</a>）和完全联接（<a href="https://www.nhooo.com/sql/sql-full-join-operation.html" target="_blank" rel="noopener">full join</a>）。</p><p>left join(左联接) 返回包括<strong>左表中的所有记录</strong>和右表中<u>联结字段相等</u>（有匹配项）的记录 ，否则用NULL<br>right join(右联接) 返回包括<strong>右表中的所有记录</strong>和左表中<u>联结字段相等</u>的记录<br>inner join(等值连接) 只返回两个表中<u>联结字段相等</u>的行</p><p><img src="https://images0.cnblogs.com/i/407365/201405/241947220904425.jpg" alt=""></p><p>总结:</p><ul><li>inner join是两集合取交集</li><li><strong>FULL [OUTER] JOIN</strong>: 两集合取并集</li><li>left [outer] join: 产生表A的完全集, B中有匹配则有值, 没匹配则为null<ul><li>left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的.换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为: A.aID = B.bID).<br>B表记录不足的地方均为NULL填充.</li></ul></li></ul><p>Q: 最上层的两张图分别是全A和全B，那么left join和right join的作用是什么呢?</p><p>A: 联表查询, 拓展字段</p><h2 id="6-查找所有员工入职时候的薪水情况"><a class="markdownIt-Anchor" href="#6-查找所有员工入职时候的薪水情况"></a> 6<a href="https://www.nowcoder.com/practice/23142e7a23e4480781a3b978b5e0f33a?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 查找所有员工入职时候的薪水情况</a></h2><blockquote><p>两表并列查找，题目重点在于: <em>有多条薪水信息中找出入职时候的薪水情况</em></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.emp_no, s.salary </span><br><span class="line"><span class="keyword">from</span> employees e, salaries s</span><br><span class="line"><span class="keyword">where</span> e.emp_no = s.emp_no <span class="keyword">and</span> e.hire_date = s.from_date</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> e.emp_no <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><blockquote><p>联表查询</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.emp_no,s.salary </span><br><span class="line"><span class="keyword">from</span> employees e</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> salaries s</span><br><span class="line"><span class="keyword">where</span> e.emp_no= s.emp_no <span class="keyword">and</span> e.hire_date = s.from_date </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> e.emp_no <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><h2 id="7查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t"><a class="markdownIt-Anchor" href="#7查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t"></a> 7<a href="https://www.nowcoder.com/practice/6d4a4cff1d58495182f536c548fee1ae?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t</a></h2><blockquote><ul><li>将select出来的数据重命名</li><li>having用法</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.emp_no, <span class="keyword">count</span>(s.emp_no) <span class="keyword">as</span> t</span><br><span class="line"><span class="keyword">from</span> salaries s</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s.emp_no</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(salary) &gt; <span class="number">15</span> </span><br><span class="line"><span class="comment">-- 由于吧count(s.emp_no)替换成t了, 因此这边可以写成 having t &gt; 15, 见执行顺序avg,count等聚合函数优先于having</span></span><br></pre></td></tr></table></figure><h3 id="question"><a class="markdownIt-Anchor" href="#question"></a> Question:</h3><p>Q: <code>select count(s.emp_no) as t</code>的执行顺序在<code>having t &gt; 15</code>之前吗?</p><p>A: No是聚合函数count优先于having</p><h3 id="sql-别名-as"><a class="markdownIt-Anchor" href="#sql-别名-as"></a> <strong>SQL 别名: AS</strong></h3><ul><li>SQL 别名用于为 表 或 表中的列 提供临时名称。</li><li>SQL 别名通常用于使 表名 或 列名 更具可读性。</li><li>SQL 一个别名只存在于查询期间。</li></ul><p>别名使用 AS 关键字赋予。</p><h4 id="什么情况下需要给表起别名"><a class="markdownIt-Anchor" href="#什么情况下需要给表起别名"></a> 什么情况下需要给表起别名？</h4><p>1.表名比较长<br>2.当需要在多个表中进行查询并把查询内容同时输出的时候<br>3.当需要进行表连接的时候（其实和2一个意思，一般情况下多个表进行连接主要目的就是为了从多个表中查询所需要的内容）</p><h3 id="having"><a class="markdownIt-Anchor" href="#having"></a> having</h3><p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与<u>聚合函数</u>一起使用。</p><p>HAVING 子句可以让我们筛选分组后的各组数据。</p><h3 id="聚合函数"><a class="markdownIt-Anchor" href="#聚合函数"></a> 聚合函数</h3><blockquote><p>聚合函数对一组值执行计算并返回单一的值</p></blockquote><h4 id="聚合函数有什么特点"><a class="markdownIt-Anchor" href="#聚合函数有什么特点"></a> 聚合函数有什么特点？</h4><ol><li>除了 COUNT 以外，聚合函数忽略空值。</li><li>聚合函数经常与 SELECT 语句的 <strong>GROUP BY</strong> 子句一同使用。</li><li>所有聚合函数都具有确定性。任何时候用一组给定的输入值调用它们时，都返回相同的值。</li><li>标量函数：只能对单个的数字或值进行计算。主要包括字符函数、日期/时间函数、数值函数和转换函数这四类。</li></ol><h2 id="8-找出所有员工当前具体的薪水salary情况"><a class="markdownIt-Anchor" href="#8-找出所有员工当前具体的薪水salary情况"></a> 8<a href="https://www.nowcoder.com/practice/ae51e6d057c94f6d891735a48d1c2397?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 找出所有员工当前具体的薪水salary情况</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> salary </span><br><span class="line"><span class="keyword">from</span> salaries</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">to_date</span> = <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或者使用group by</span></span><br><span class="line"><span class="keyword">select</span> salary </span><br><span class="line">    <span class="keyword">from</span> salaries </span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">to_date</span> = <span class="string">'9999-01-01'</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> salary</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>说明：<br>对于distinct与group by的使用：<br>1.当对系统的性能高并且数据量大时使用group by<br>2.当对系统的性能不高时或者使用数据量少时两者借口<br>3.尽量使用group by</p><h2 id="9获取所有部门当前manager的当前薪水情况"><a class="markdownIt-Anchor" href="#9获取所有部门当前manager的当前薪水情况"></a> 9<a href="https://www.nowcoder.com/practice/4c8b4a10ca5b44189e411107e1d8bec1?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">获取所有部门当前manager的当前薪水情况</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用where连接并列查询的两表</span></span><br><span class="line"><span class="keyword">select</span> d.dept_no, s.emp_no, s.salary </span><br><span class="line"><span class="keyword">from</span> dept_manager <span class="keyword">as</span> d, salaries <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">where</span> d.emp_no = s.emp_no <span class="keyword">and</span> d.to_date=<span class="string">'9999-01-01'</span> <span class="keyword">and</span> s.to_date=<span class="string">'9999-01-01'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用inner join合并两表</span></span><br><span class="line"><span class="keyword">select</span> d.dept_no, s.emp_no, s.salary</span><br><span class="line"><span class="keyword">from</span> dept_manager <span class="keyword">as</span> d</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> salaries <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">on</span> d.to_date = <span class="string">'9999-01-01'</span> <span class="keyword">and</span> s.to_date = <span class="string">'9999-01-01'</span> <span class="keyword">and</span> d.emp_no = s.emp_no;</span><br></pre></td></tr></table></figure><h2 id="10-获取所有非manager的员工emp_no"><a class="markdownIt-Anchor" href="#10-获取所有非manager的员工emp_no"></a> 10<a href="https://www.nowcoder.com/practice/32c53d06443346f4a2f2ca733c19660c?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 获取所有非manager的员工emp_no</a></h2><blockquote><p>把在dept_manager中的都筛选掉, 之前join的练习: A - A∩B</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- LEFT JOIN左连接 + IS NULL</span></span><br><span class="line"><span class="keyword">select</span> e.emp_no</span><br><span class="line"><span class="keyword">from</span> employees <span class="keyword">as</span> e</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> dept_manager d</span><br><span class="line"><span class="keyword">on</span> e.emp_no = d.emp_no </span><br><span class="line"><span class="keyword">where</span> d.emp_no <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line"><span class="comment">-- where d.emp_no isnull 中 isnull是个关键字, 正确用法是</span></span><br><span class="line"><span class="comment">-- ISNULL ( check_expression , replacement_value )将被检查是否为 NULL的表达式替换为replacement_value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- NOT IN+子查询</span></span><br><span class="line"><span class="keyword">select</span> emp_no</span><br><span class="line"><span class="keyword">from</span> employees <span class="keyword">where</span> emp_no </span><br><span class="line"><span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> emp_no <span class="keyword">from</span> dept_manager)</span><br></pre></td></tr></table></figure><p>使用见: <a href="#join">#join</a></p><ul><li>只有left join的效果</li></ul><p><img src="/2020/09/04/SQL练习/left_join.jpg" alt="left_join"></p><ul><li>加上is null的效果 ==&gt; 找出B表中emp_no不匹配的(他们填充的数据都是null)</li></ul><p><img src="/2020/09/04/SQL练习/isnull.jpg" alt="isnull"></p><h2 id="11-获取所有员工当前的manager"><a class="markdownIt-Anchor" href="#11-获取所有员工当前的manager"></a> 11<a href="https://www.nowcoder.com/practice/e50d92b8673a440ebdf3a517b5b37d62?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 获取所有员工当前的manager</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- my</span></span><br><span class="line"><span class="keyword">select</span> de.emp_no, dm.emp_no <span class="keyword">as</span> manager_no</span><br><span class="line"><span class="keyword">from</span> dept_emp <span class="keyword">as</span> de</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span>  dept_manager dm</span><br><span class="line"><span class="keyword">on</span> de.dept_no = dm.dept_no</span><br><span class="line"><span class="keyword">where</span> dm.to_date =<span class="string">'9999-01-01'</span> <span class="keyword">and</span> dm.emp_no != de.emp_no</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 题解: INNER JOIN+不等于; 不等于可以用&lt;&gt;或者!=表示</span></span><br><span class="line"><span class="keyword">SELECT</span> de.emp_no, dm.emp_no <span class="keyword">AS</span> manager_no </span><br><span class="line"><span class="keyword">FROM</span> dept_emp <span class="keyword">AS</span> de <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept_manager <span class="keyword">AS</span> dm</span><br><span class="line"><span class="keyword">ON</span> de.dept_no = dm.dept_no </span><br><span class="line"><span class="keyword">WHERE</span> dm.to_date = <span class="string">'9999-01-01'</span> <span class="keyword">AND</span> de.to_date = <span class="string">'9999-01-01'</span> <span class="keyword">AND</span> de.emp_no &lt;&gt; dm.emp_no</span><br></pre></td></tr></table></figure><h2 id="12-获取所有部门中当前员工薪水最高的相关信息"><a class="markdownIt-Anchor" href="#12-获取所有部门中当前员工薪水最高的相关信息"></a> 12<a href="https://www.nowcoder.com/practice/4a052e3e1df5435880d4353eb18a91c6?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 获取所有部门中当前员工薪水最高的相关信息</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> de.dept_no, de.emp_no, <span class="keyword">max</span>(s.salary) </span><br><span class="line"><span class="keyword">from</span> dept_emp <span class="keyword">as</span> de </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> salaries <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">on</span> s.emp_no = de.emp_no <span class="keyword">and</span> de.to_date = <span class="string">'9999-01-01'</span> <span class="keyword">and</span> s.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> de.dept_no</span><br></pre></td></tr></table></figure><p>使用GROUP BY子句时，SELECT子句中只能有聚合键、聚合函数、常数。</p><h2 id="13-从titls表获取按照title进行分组"><a class="markdownIt-Anchor" href="#13-从titls表获取按照title进行分组"></a> 13<a href="https://www.nowcoder.com/practice/72ca694734294dc78f513e147da7821e?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 从titls表获取按照title进行分组</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> title, <span class="keyword">count</span>(title) <span class="keyword">as</span> t</span><br><span class="line"><span class="keyword">from</span> titles</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> title</span><br><span class="line"><span class="keyword">having</span> t &gt;= <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="14-从titles表获取按照title进行分组注意对于重复的emp_no进行忽略"><a class="markdownIt-Anchor" href="#14-从titles表获取按照title进行分组注意对于重复的emp_no进行忽略"></a> 14 <a href="https://www.nowcoder.com/practice/c59b452f420c47f48d9c86d69efdff20?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 从titles表获取按照title进行分组，注意对于重复的emp_no进行忽略</a></h2><blockquote><p>忽略重复的emp_no， 上题的count(title) 其实可以写成count(emp_no) , 即有一条包含title的条目就++，而emp_no是其主键, 因此可以用emp_no的数目来代替title的数目。因此这题要求的不重复emp_no直接加个distinct即可</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> title, <span class="keyword">count</span>(<span class="keyword">distinct</span> emp_no) <span class="keyword">as</span> t</span><br><span class="line"><span class="keyword">from</span> titles</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> title</span><br><span class="line"><span class="keyword">having</span> t &gt;= <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="15-查找employees表所有emp_no为奇数"><a class="markdownIt-Anchor" href="#15-查找employees表所有emp_no为奇数"></a> 15<a href="https://www.nowcoder.com/practice/a32669eb1d1740e785f105fa22741d5c?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 查找employees表所有emp_no为奇数</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp_no, birth_date, first_name, last_name, gender, hire_date</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> emp_no % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">and</span> last_name != <span class="string">'Mary'</span> </span><br><span class="line"><span class="comment">-- 补充：emp_no % 2=1也可以改成MOD(emp_no, 2)=1，但是某些sql版本可能不支持后者(比如题库就不支持)</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> hire_date <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><h2 id="16-统计出当前各个title类型对应的员工当前薪水对应的平均工资"><a class="markdownIt-Anchor" href="#16-统计出当前各个title类型对应的员工当前薪水对应的平均工资"></a> 16<a href="https://www.nowcoder.com/practice/c8652e9e5a354b879e2a244200f1eaae?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 统计出当前各个title类型对应的员工当前薪水对应的平均工资</a></h2><blockquote><p>通过t.title来进行分组</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t.title, <span class="keyword">avg</span>(s.salary)</span><br><span class="line"><span class="keyword">from</span> titles <span class="keyword">as</span> t</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> salaries <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">on</span> t.emp_no = s.emp_no <span class="keyword">and</span> t.to_date =<span class="string">'9999-01-01'</span> <span class="keyword">and</span> s.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="comment">--  on t.emp_no=s.emp_no where t.to_date='9999-01-01' and s.to_date='9999-01-01' 也行, 表示在on执行后生成的虚拟表上再执行where</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t.title</span><br></pre></td></tr></table></figure><p>注意：AVG(*)是自动命名为avg的，所以不用重命名</p><h2 id="17-获取当前薪水第二多的员工的emp_no以及其对应的薪水"><a class="markdownIt-Anchor" href="#17-获取当前薪水第二多的员工的emp_no以及其对应的薪水"></a> 17 <a href="https://www.nowcoder.com/practice/8d2c290cc4e24403b98ca82ce45d04db?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 获取当前薪水第二多的员工的emp_no以及其对应的薪水</a></h2><blockquote><p>考验limit用法</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp_no, salary </span><br><span class="line"><span class="keyword">from</span> salaries</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">1</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="18-查找当前薪水排名第二多的员工编号emp_no"><a class="markdownIt-Anchor" href="#18-查找当前薪水排名第二多的员工编号emp_no"></a> 18<a href="https://www.nowcoder.com/practice/c1472daba75d4635b7f8540b837cc719?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 查找当前薪水排名第二多的员工编号emp_no</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用MAX函数，先查出最大salary，再利用&lt;得到不含最大salary的子表，在子表上再求最大值</span></span><br><span class="line"><span class="keyword">select</span> e.emp_no, <span class="keyword">max</span>(s.salary), e.last_name, e.first_name</span><br><span class="line"><span class="keyword">from</span> employees <span class="keyword">as</span> e</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> salaries <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">on</span> e.emp_no = s.emp_no</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">to_date</span> = <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">and</span> salary &lt; ( <span class="keyword">select</span> <span class="keyword">max</span>(salary) <span class="keyword">from</span> salaries <span class="keyword">as</span> s <span class="keyword">where</span> s.to_date = <span class="string">'9999-01-01'</span>)</span><br></pre></td></tr></table></figure><h2 id="19查找所有员工的last_name和first_name以及对应的dept_name"><a class="markdownIt-Anchor" href="#19查找所有员工的last_name和first_name以及对应的dept_name"></a> 19<a href="https://www.nowcoder.com/practice/5a7975fabe1146329cee4f670c27ad55?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">查找所有员工的last_name和first_name以及对应的dept_name</a></h2><blockquote><ol><li>列出<code>employees</code>表里所有员工last_name, first_name,</li><li>根据<code>employees</code>中emp_no对应<code>dept_emp</code>中的dept_no,没有分配的员工找不到对应–&gt;采用<code>LEFT JOIN</code></li><li>再根据dept_no对应<code>departments</code>表中的dept_name,没有分配的员工找不到对应–&gt;采用<code>LEFT JOIN</code></li></ol></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.last_name, e.first_name, dm.dept_name</span><br><span class="line"><span class="keyword">from</span> employees <span class="keyword">as</span> e</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> dept_emp <span class="keyword">as</span> de<span class="comment">-- 这边使用left join因为要针对没有分配部门的员工</span></span><br><span class="line"><span class="keyword">on</span> e.emp_no = de.emp_no</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> departments <span class="keyword">as</span> dm</span><br><span class="line"><span class="keyword">on</span> de.dept_no = dm.dept_no</span><br></pre></td></tr></table></figure><h2 id="20查找员工编号emp_now为10001其自入职以来的薪水salary涨幅值growth"><a class="markdownIt-Anchor" href="#20查找员工编号emp_now为10001其自入职以来的薪水salary涨幅值growth"></a> 20<a href="https://www.nowcoder.com/practice/c727647886004942a89848e2b5130dc2?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">查找员工编号emp_now为10001其自入职以来的薪水salary涨幅值growth</a></h2><blockquote><p>最大值-最小值</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 题解, sum的结果默认为growth</span></span><br><span class="line"><span class="keyword">select</span> (<span class="keyword">max</span>(salary)-<span class="keyword">min</span>(salary)) <span class="keyword">as</span> growth</span><br><span class="line"><span class="keyword">from</span> salaries</span><br><span class="line"><span class="keyword">where</span> emp_no=<span class="string">'10001'</span>;</span><br></pre></td></tr></table></figure><h2 id="21-查找所有员工自入职以来的薪水涨幅情况"><a class="markdownIt-Anchor" href="#21-查找所有员工自入职以来的薪水涨幅情况"></a> 21<a href="https://www.nowcoder.com/practice/fc7344ece7294b9e98401826b94c6ea5?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 查找所有员工自入职以来的薪水涨幅情况</a></h2><blockquote><p>这题比较有难度</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> la.emp_no, (now.salary - la.salary) <span class="keyword">as</span> growth</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> e.emp_no, s.salary</span><br><span class="line">     <span class="keyword">from</span> employees <span class="keyword">as</span> e</span><br><span class="line">     <span class="keyword">left</span> <span class="keyword">join</span> salaries <span class="keyword">as</span> s</span><br><span class="line">     <span class="keyword">on</span> e.emp_no = s.emp_no <span class="keyword">and</span> e.hire_date = s.from_date ) <span class="keyword">as</span> la    <span class="comment">-- 入职时的工资表</span></span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">    (<span class="keyword">select</span> e.emp_no, s.salary</span><br><span class="line">    <span class="keyword">from</span> employees <span class="keyword">as</span> e</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> salaries <span class="keyword">as</span> s</span><br><span class="line">    <span class="keyword">on</span> e.emp_no = s.emp_no </span><br><span class="line">    <span class="keyword">where</span> s.to_date = <span class="string">'9999-01-01'</span>) <span class="keyword">as</span> <span class="keyword">now</span>      <span class="comment">-- 现在的工资表</span></span><br><span class="line"><span class="keyword">on</span> la.emp_no = now.emp_no</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> growth <span class="keyword">asc</span><span class="comment">-- order by 默认asc</span></span><br></pre></td></tr></table></figure><h2 id="22统计各个部门的工资记录数"><a class="markdownIt-Anchor" href="#22统计各个部门的工资记录数"></a> 22<a href="https://www.nowcoder.com/practice/6a62b6c0a7324350a6d9959fa7c21db3?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">统计各个部门的工资记录数</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- my</span></span><br><span class="line"><span class="keyword">select</span> d.dept_no, d.dept_name, <span class="keyword">count</span>(d.emp_no) <span class="keyword">as</span> <span class="string">`sum`</span></span><br><span class="line"><span class="keyword">from</span>  </span><br><span class="line">    (<span class="keyword">select</span> * <span class="keyword">from</span> dept_emp <span class="keyword">as</span> de</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> departments <span class="keyword">as</span> dm</span><br><span class="line">    <span class="keyword">on</span> de.dept_no = dm.dept_no) <span class="keyword">as</span> d</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> salaries <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">on</span> d.emp_no = s.emp_no</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> d.dept_no<span class="comment">-- 根据题目要求（统计各个部门的工资记录数）确定group by对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 题解</span></span><br><span class="line"><span class="keyword">select</span> dm.dept_no, dm.dept_name, <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">from</span>  departments <span class="keyword">as</span> dm</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> </span><br><span class="line">    (<span class="keyword">select</span> * <span class="keyword">from</span> dept_emp <span class="keyword">as</span> de</span><br><span class="line">     <span class="comment">--    (dept_emp as de也可以</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> salaries <span class="keyword">as</span> s</span><br><span class="line">    <span class="keyword">on</span> de.emp_no = s.emp_no) <span class="keyword">as</span> d</span><br><span class="line"><span class="keyword">on</span> dm.dept_no = d.dept_no</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> d.dept_no</span><br></pre></td></tr></table></figure><h2 id="23对所有员工的当前薪水按照salary进行按照1-n的排名"><a class="markdownIt-Anchor" href="#23对所有员工的当前薪水按照salary进行按照1-n的排名"></a> 23<a href="https://www.nowcoder.com/practice/b9068bfe5df74276bd015b9729eec4bf?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">对所有员工的当前薪水按照salary进行按照1-N的排名</a></h2><blockquote><p>SQL窗口函数（OLAP函数）中用于排序的专用窗口函数用法: RANK函数的使用 -&gt;mysql不支持</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp_no, salary, <span class="keyword">dense_rank</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>) <span class="keyword">as</span> <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">from</span> salaries</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">to_date</span> = <span class="string">'9999-01-01'</span></span><br></pre></td></tr></table></figure><p>下面介绍三种用于进行排序的专用窗口函数：</p><p>1、RANK()</p><p>在计算排序时，若存在相同位次，会跳过之后的位次。</p><p>例如，有3条排在第1位时，排序为：1，1，1，4······</p><p>2、DENSE_RANK()</p><p>这就是题目中所用到的函数，在计算排序时，若存在相同位次，不会跳过之后的位次。</p><p>例如，有3条排在第1位时，排序为：1，1，1，2······</p><p>3、ROW_NUMBER()</p><p>这个函数赋予唯一的连续位次。</p><p>例如，有3条排在第1位时，排序为：1，2，3，4······</p><p>窗口函数用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;开窗函数&gt; over ([partition by &lt;列清单&gt;] order by &lt;排序用列清单&gt;)</span><br></pre></td></tr></table></figure><p><strong>开窗函数大体可以分为以下两种：</strong></p><p>1.能够作为开窗函数的聚合函数（sum，avg，count，max，min）<br>2.rank，dense_rank。row_number等专用开窗函数。</p><h3 id="14-开窗函数和聚合函数的区别"><a class="markdownIt-Anchor" href="#14-开窗函数和聚合函数的区别"></a> 1.4 开窗函数和聚合函数的区别</h3><p>（1）SQL 标准允许将所有聚合函数用作开窗函数，用OVER 关键字区分开窗函数和聚合函数。<br>（2）聚合函数每组只返回一个值，开窗函数每组可返回多个值。</p><h2 id="24-获取所有非manager员工当前的薪水情况"><a class="markdownIt-Anchor" href="#24-获取所有非manager员工当前的薪水情况"></a> 24<a href="https://www.nowcoder.com/practice/8fe212a6c71b42de9c15c56ce354bebe?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 获取所有非manager员工当前的薪水情况</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方法1：多表联查+NOT IN</span></span><br><span class="line"><span class="keyword">SELECT</span> de.dept_no, de.emp_no, s.salary</span><br><span class="line">    <span class="keyword">FROM</span> dept_emp <span class="keyword">AS</span> de, employees <span class="keyword">AS</span> e, salaries <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">WHERE</span> de.emp_no=e.emp_no</span><br><span class="line">    <span class="keyword">AND</span> de.emp_no=s.emp_no</span><br><span class="line">    <span class="keyword">AND</span> s.to_date=<span class="string">'9999-01-01'</span></span><br><span class="line">    <span class="keyword">AND</span> e.emp_no <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> emp_no</span><br><span class="line"><span class="keyword">FROM</span> dept_manager</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">to_date</span>=<span class="string">'9999-01-01'</span>)</span><br></pre></td></tr></table></figure><h2 id="25-获取员工其当前的薪水比其manager当前薪水还高的相"><a class="markdownIt-Anchor" href="#25-获取员工其当前的薪水比其manager当前薪水还高的相"></a> 25<a href="https://www.nowcoder.com/practice/f858d74a030e48da8e0f69e21be63bef?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 获取员工其当前的薪水比其manager当前薪水还高的相</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> de.emp_no, dm.emp_no <span class="keyword">as</span> manager_no, s1.salary <span class="keyword">as</span> emp_salary, s2.salary <span class="keyword">as</span> manager_salary</span><br><span class="line"><span class="keyword">from</span> dept_emp <span class="keyword">as</span> de, dept_manager <span class="keyword">as</span> dm, salaries s1, salaries s2 </span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">    de.dept_no = dm.dept_no     <span class="comment">-- 找到部门的boss</span></span><br><span class="line"><span class="keyword">and</span> de.emp_no = s1.emp_no</span><br><span class="line"><span class="keyword">and</span> dm.emp_no = s2.emp_no</span><br><span class="line"><span class="keyword">and</span> s1.salary &gt; s2.salary</span><br><span class="line"><span class="keyword">and</span> s2.to_date=<span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">and</span> s1.to_date=<span class="string">'9999-01-01'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 依次构造两张表, 再链表查询</span></span><br><span class="line"><span class="keyword">SELECT</span> a.emp_no, b.manager_no, a.emp_salary, b.manager_salary</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> de.dept_no, de.emp_no, s.salary <span class="keyword">AS</span> emp_salary</span><br><span class="line">    <span class="keyword">FROM</span> dept_emp <span class="keyword">AS</span> de, salaries <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">WHERE</span> de.emp_no=s.emp_no</span><br><span class="line">    <span class="keyword">AND</span> de.to_date=<span class="string">'9999-01-01'</span></span><br><span class="line">    <span class="keyword">AND</span> s.to_date=<span class="string">'9999-01-01'</span>) <span class="keyword">AS</span> a,</span><br><span class="line">    (</span><br><span class="line">    <span class="keyword">SELECT</span> dm.dept_no, dm.emp_no <span class="keyword">AS</span> manager_no, s.salary <span class="keyword">AS</span> manager_salary</span><br><span class="line">    <span class="keyword">FROM</span> dept_manager <span class="keyword">AS</span> dm, salaries <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">WHERE</span> dm.emp_no=s.emp_no</span><br><span class="line">    <span class="keyword">AND</span> dm.to_date=<span class="string">'9999-01-01'</span></span><br><span class="line">    <span class="keyword">AND</span> s.to_date=<span class="string">'9999-01-01'</span>) <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    a.dept_no=b.dept_no</span><br><span class="line">    <span class="keyword">AND</span> a.emp_salary&gt;b.manager_salary;</span><br></pre></td></tr></table></figure><h2 id="26-汇总各个部门当前员工的title类型的分配数目"><a class="markdownIt-Anchor" href="#26-汇总各个部门当前员工的title类型的分配数目"></a> 26<a href="https://www.nowcoder.com/practice/4bcb6a7d3e39423291d2f7bdbbff87f8?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"> 汇总各个部门当前员工的title类型的分配数目</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> niuke;</span><br><span class="line"><span class="keyword">select</span> dp.dept_no, dp.dept_name, t.title, <span class="keyword">count</span>(t.title) </span><br><span class="line"><span class="keyword">from</span> departments  <span class="keyword">as</span> dp, dept_emp <span class="keyword">as</span> de, titles  <span class="keyword">as</span> t</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">    dp.dept_no = de.dept_no</span><br><span class="line"><span class="keyword">and</span> de.emp_no = t.emp_no</span><br><span class="line"><span class="keyword">and</span> de.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">and</span> t.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dp.dept_no,t.title<span class="comment">-- 题目的难点在于理解group by的条件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 题解</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    de.dept_no <span class="keyword">AS</span> dept_no,</span><br><span class="line">    d.dept_name <span class="keyword">AS</span> dept_name,</span><br><span class="line">    t.title <span class="keyword">AS</span> title,</span><br><span class="line">    <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="string">`count`</span><span class="comment">-- 分好组后计算每个组内有多少行</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dept_emp <span class="keyword">AS</span> de1 <span class="keyword">WHERE</span> de1.to_date=<span class="string">'9999-01-01'</span>) <span class="keyword">AS</span> de,</span><br><span class="line">    (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> titles <span class="keyword">AS</span> t1 <span class="keyword">WHERE</span> t1.to_date=<span class="string">'9999-01-01'</span>) <span class="keyword">AS</span> t,</span><br><span class="line">    departments <span class="keyword">AS</span> d</span><br><span class="line"><span class="keyword">WHERE</span> d.dept_no = de.dept_no</span><br><span class="line"><span class="keyword">AND</span> de.emp_no = t.emp_no</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> d.dept_no, t.title</span><br></pre></td></tr></table></figure><p>对于group by多个关键字的使用， 见<a href="https://www.bilibili.com/video/BV1r54y1e77F?from=search&amp;seid=16839861860769481900" target="_blank" rel="noopener">B站视频</a></p><ul><li>group by和distinct可以实现相同效果， 在redshift中group by快于distinct</li></ul><p><img src="/2020/09/04/SQL练习/groupby.jpg" alt="groupby"></p><h2 id="27-给出每个员工每年薪水涨幅超过5000的员工编号emp_no"><a class="markdownIt-Anchor" href="#27-给出每个员工每年薪水涨幅超过5000的员工编号emp_no"></a> <a href="https://www.nowcoder.com/practice/eb9b13e5257744db8265aa73de04fd44?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">27 给出每个员工每年薪水涨幅超过5000的员工编号emp_no</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 两个salary子查询相减: 表内根据某一列进行差值比较, 就需要分别获得两行数据, 因此可以获得两次表, on找到对应数据</span></span><br><span class="line"><span class="keyword">SELECT</span> s1.emp_no, s2.from_date, (s2.salary - s1.salary) <span class="keyword">AS</span> salary_growth</span><br><span class="line">    <span class="keyword">FROM</span> salaries <span class="keyword">AS</span> s1</span><br><span class="line">    <span class="keyword">JOIN</span> salaries <span class="keyword">AS</span> s2</span><br><span class="line"><span class="keyword">ON</span> s1.emp_no = s2.emp_no <span class="keyword">AND</span> s1.to_date = s2.from_date</span><br><span class="line">    <span class="keyword">WHERE</span> s2.salary - s1.salary &gt; <span class="number">5000</span></span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary_growth <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>注意: 这边只能是(inner) JOIN, 如果LEFT JOIN, RIGHT JOIN会报错;  原数据7条, <code>join</code>以后变成49条(把s2的每一条都对应给了s1的每一条, 7*7)==&gt;和<code>SELECT * FROM salaries AS s1, salaries AS s2;</code>效果一样，但left join、right join效果不一样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 其他题</span></span><br><span class="line"><span class="keyword">SELECT</span> s1.emp_no, s2.from_date, (s2.salary - s1.salary) <span class="keyword">AS</span> salary_growth</span><br><span class="line"><span class="keyword">FROM</span> salaries <span class="keyword">AS</span> s1, salaries <span class="keyword">AS</span> s2</span><br><span class="line"><span class="keyword">WHERE</span> s1.emp_no=s2.emp_no</span><br><span class="line"><span class="keyword">AND</span> (STRFTIME(<span class="string">'%Y'</span>, s2.from_date) - STRFTIME(<span class="string">'%Y'</span>, s1.from_date) = <span class="number">1</span></span><br><span class="line"><span class="keyword">OR</span> STRFTIME(<span class="string">'%Y'</span>, s2.to_date) - STRFTIME(<span class="string">'%Y'</span>, s1.to_date) = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">AND</span> salary_growth&gt;<span class="number">5000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary_growth <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h2 id="28-查找描述信息中包括robot的电影对应的分类名称以及电影数目"><a class="markdownIt-Anchor" href="#28-查找描述信息中包括robot的电影对应的分类名称以及电影数目"></a> <a href="https://www.nowcoder.com/practice/3a303a39cc40489b99a7e1867e6507c5?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">28 查找描述信息中包括robot的电影对应的分类名称以及电影数目</a></h2><blockquote><p>这题题意其实是有一点绕的： 查找描述信息中<strong>包含robot的电影</strong>对应的<u>分类名称</u>以及<u>电影数目</u>，注意需要该分类包含电影总数量&gt;=5部</p></blockquote><p>包含robot的数据, 通过like选出: <code>select * from film where film.description like '%robot%';</code></p><p>记录:</p><ul><li>category: 16条</li><li>film: 10条</li><li>film_category: 10条</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film f,<span class="keyword">category</span> c,film_category fc<span class="comment">-- 1600条数据</span></span><br><span class="line"><span class="keyword">where</span> f.description <span class="keyword">like</span> <span class="string">'%robot%'</span> <span class="comment">-- 160条数据</span></span><br><span class="line"><span class="keyword">and</span> f.film_id = fc.film_id<span class="comment">-- 16条数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 题解:</span></span><br><span class="line"><span class="keyword">select</span> c.name <span class="keyword">AS</span> <span class="string">`分类名称category.name`</span>, <span class="keyword">COUNT</span>(fc.film_id) <span class="keyword">AS</span> <span class="string">`电影数目count(film.film_id)`</span></span><br><span class="line"><span class="keyword">from</span> film f,<span class="keyword">category</span> c,film_category fc</span><br><span class="line"><span class="keyword">where</span> f.description <span class="keyword">like</span> <span class="string">'%robot%'</span></span><br><span class="line"><span class="keyword">and</span> f.film_id=fc.film_id</span><br><span class="line"><span class="keyword">and</span> fc.category_id=c.category_id</span><br><span class="line"><span class="keyword">and</span> c.category_id <span class="keyword">in</span> (<span class="keyword">select</span> category_id</span><br><span class="line">                      <span class="keyword">from</span> film_category</span><br><span class="line">                      <span class="keyword">group</span> <span class="keyword">by</span> category_id</span><br><span class="line">                       <span class="keyword">having</span> <span class="keyword">count</span>(film_id)&gt;=<span class="number">5</span>) <span class="comment">-- 需要该分类包含电影总数量(count(film_category.category_id))&gt;=5部</span></span><br></pre></td></tr></table></figure><p>▲注: 这题无论怎么写在本地的MYSQL上都跑不出来, 但是OJ上能过. 具体报错为: <code>In aggregated query without GROUP BY, expression #1 of SELECT list contains nonaggregated column 'niuke.c.name'; this is incompatible with sql_mode=only_full_group_by</code>, 这个是由于sql_mode设置不当引起的，修改下sql_mode即可. 做法为: <a href="https://cloud.tencent.com/developer/article/1404739" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1404739</a></p><h2 id="29-使用join查询方式找出没有分类的电影id以及名称"><a class="markdownIt-Anchor" href="#29-使用join查询方式找出没有分类的电影id以及名称"></a> <a href="https://www.nowcoder.com/practice/a158fa6e79274ac497832697b4b83658?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">29 使用join查询方式找出没有分类的电影id以及名称</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> f.film_id <span class="keyword">as</span> <span class="string">'电影id'</span>, f.title <span class="keyword">as</span> <span class="string">'名称'</span></span><br><span class="line"><span class="keyword">from</span> film f</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> film_category <span class="keyword">as</span> fc</span><br><span class="line">    <span class="keyword">on</span> f.film_id = fc.film_id</span><br><span class="line"><span class="keyword">where</span> fc.category_id <span class="keyword">is</span> <span class="literal">null</span><span class="comment">-- 注意什么时候用on 什么时候用where, 这边是固定用法</span></span><br></pre></td></tr></table></figure><h2 id="30-使用子查询的方式找出属于action分类的所有电影对应的titledescription"><a class="markdownIt-Anchor" href="#30-使用子查询的方式找出属于action分类的所有电影对应的titledescription"></a> <a href="https://www.nowcoder.com/practice/2f2e556d335d469f96b91b212c4c203e?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">30 使用子查询的方式找出属于Action分类的所有电影对应的title,description</a></h2><blockquote><p>要求子查询， 就需要先根据类别为Action将子表给筛选出来</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 联子表， 用inner join一样的</span></span><br><span class="line"><span class="keyword">select</span> f.title, f.description</span><br><span class="line">    <span class="keyword">from</span> film <span class="keyword">as</span> f, (<span class="keyword">SELECT</span> fc.film_id</span><br><span class="line">    <span class="keyword">from</span> film_category fc, <span class="keyword">category</span> c</span><br><span class="line"><span class="keyword">where</span> fc.category_id = c.category_id</span><br><span class="line"><span class="keyword">and</span> c.name = <span class="string">'Action'</span>) <span class="keyword">as</span> ff</span><br><span class="line"><span class="keyword">where</span> f.film_id = ff.film_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 题解</span></span><br><span class="line"><span class="keyword">select</span> title,description</span><br><span class="line"><span class="keyword">from</span> film f</span><br><span class="line"><span class="keyword">where</span> f.film_id <span class="keyword">in</span> (<span class="keyword">select</span> fc.film_id</span><br><span class="line">                    <span class="keyword">from</span> <span class="keyword">category</span> c <span class="keyword">join</span> film_category fc <span class="keyword">on</span>                        c.category_id=fc.category_id</span><br><span class="line">                    <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'Action'</span>)</span><br></pre></td></tr></table></figure><h3 id="inner-join-和-where比较实际上是cross-join笛卡尔积"><a class="markdownIt-Anchor" href="#inner-join-和-where比较实际上是cross-join笛卡尔积"></a> inner join 和 where比较(实际上是cross join<strong>笛卡尔积</strong>)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A: <span class="keyword">select</span> a.x, b.x </span><br><span class="line">    <span class="keyword">from</span> table1 a,table2 b </span><br><span class="line">    <span class="keyword">where</span> a.id=b.id</span><br><span class="line">B: <span class="keyword">select</span> * <span class="keyword">from</span> table1 a </span><br><span class="line"><span class="keyword">cross</span> <span class="keyword">join</span> table2 b </span><br><span class="line"><span class="keyword">where</span> a.id=b.id (注：<span class="keyword">cross</span> <span class="keyword">join</span>后加条件只能用<span class="keyword">where</span>,不能用<span class="keyword">on</span>)</span><br><span class="line">C: <span class="keyword">select</span> * <span class="keyword">from</span> table1 a </span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> table2 b </span><br><span class="line">    <span class="keyword">on</span> a.id=b.id</span><br></pre></td></tr></table></figure><p>一般不建议使用方法A和B，因为如果有WHERE子句的话，往往会先生成两个表<u>行数乘积的行的数据表</u>然后才根据WHERE条件从中选择。因此，如果两个需要求交际的表太大，将会非常非常慢，不建议使用。</p><h3 id="连接查询与子查询"><a class="markdownIt-Anchor" href="#连接查询与子查询"></a> 连接查询与子查询</h3><p>初步实践证明：连接查询的性能优于子查询，所以能用连接查询的地方尽量少用子查询</p><p><strong>连接查询</strong></p><p>连接查询是将两个或多个的表按某个条件连接起来，从中选取需要的数据，连接查询是同时查询两个或两个以上的表的使用的。当不同的表中存在相同意义的字段时，可以通过该字段来连接这几个表。</p><h2 id="32-将employees表的所有员工的last_name和first_name拼接起来作为name中间以一个空格区分"><a class="markdownIt-Anchor" href="#32-将employees表的所有员工的last_name和first_name拼接起来作为name中间以一个空格区分"></a> <a href="https://www.nowcoder.com/practice/6744b90bbdde40209f8ecaac0b0516fe?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">32 将employees表的所有员工的last_name和first_name拼接起来作为Name，中间以一个空格区分</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- sqlite中无concat函数</span></span><br><span class="line"><span class="keyword">select</span> (last_name||<span class="string">' '</span>||first_name) <span class="keyword">as</span> <span class="keyword">Name</span> <span class="keyword">from</span> employees</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- mysql</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">if</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`employees`</span>(</span><br><span class="line"><span class="string">`last_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">60</span>),</span><br><span class="line"><span class="string">`first_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">60</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`employees`</span> <span class="keyword">VALUES</span>(<span class="string">'mr'</span>, <span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(last_name, <span class="string">' '</span>, first_name) <span class="keyword">as</span> <span class="string">'Name'</span> <span class="keyword">from</span> employees<span class="comment">-- sqlite</span></span><br></pre></td></tr></table></figure><hr><h1 id="练习crud"><a class="markdownIt-Anchor" href="#练习crud"></a> 练习CRUD</h1><h2 id="33-创建一个actor表包含如下列信息"><a class="markdownIt-Anchor" href="#33-创建一个actor表包含如下列信息"></a> <a href="https://www.nowcoder.com/practice/ac233de508ef4849b0eeb4f38dcf09cf?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">33 创建一个actor表，包含如下列信息</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 发现图中有的含义列不需要用comment表示出</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="string">`actor`</span>(</span><br><span class="line">    <span class="string">`actor_id`</span> <span class="built_in">smallint</span>(<span class="number">5</span>) <span class="keyword">not</span> <span class="literal">null</span> ,</span><br><span class="line">    <span class="string">`first_name`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">not</span> <span class="literal">null</span> ,</span><br><span class="line">    <span class="string">`last_name`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">not</span> <span class="literal">null</span> ,</span><br><span class="line">    <span class="string">`last_update`</span> <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(actor_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 题解</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> actor (</span><br><span class="line">actor_id <span class="built_in">smallint</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>, <span class="comment">-- 设置主键</span></span><br><span class="line">first_name <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">last_name <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">last_update <span class="keyword">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> (datetime(<span class="string">'now'</span>,<span class="string">'localtime'</span>))) <span class="comment">-- 获取默认系统时间</span></span><br></pre></td></tr></table></figure><h2 id="34-批量插入数据"><a class="markdownIt-Anchor" href="#34-批量插入数据"></a> <a href="https://www.nowcoder.com/practice/51c12cea6a97468da149c04b7ecf362e?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">34 批量插入数据</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`actor`</span><span class="keyword">values</span></span><br><span class="line">    (<span class="number">1</span>, <span class="string">'PENELOPE'</span>, <span class="string">'GUINESS'</span>, <span class="string">'2006-02-15 12:34:33'</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="string">'NICK'</span>, <span class="string">'WAHLBERG'</span>, <span class="string">'2006-02-15 12:34:33'</span>);</span><br></pre></td></tr></table></figure><h2 id="35-批量插入数据如果数据已经存在请忽略不使用replace操作"><a class="markdownIt-Anchor" href="#35-批量插入数据如果数据已经存在请忽略不使用replace操作"></a> <a href="https://www.nowcoder.com/practice/153c8a8e7805400ba8e384e03acc6b3e?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">35 批量插入数据,如果数据已经存在，请忽略，不使用replace操作</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- sqlite</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">or</span> <span class="keyword">ignore</span> <span class="keyword">into</span> actor</span><br><span class="line"><span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'ED'</span>,<span class="string">'CHASE'</span>,<span class="string">'2006-02-15 12:34:33'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- mysql</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> actor</span><br><span class="line"><span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'ED'</span>,<span class="string">'CHASE'</span>,<span class="string">'2006-02-15 12:34:33'</span>);</span><br></pre></td></tr></table></figure><h2 id="36-创建一个actor_name表将actor表中的所有first_name以及last_name导入改表"><a class="markdownIt-Anchor" href="#36-创建一个actor_name表将actor表中的所有first_name以及last_name导入改表"></a> <a href="https://www.nowcoder.com/practice/881385f388cf4fe98b2ed9f8897846df?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">36 创建一个actor_name表，将actor表中的所有first_name以及last_name导入改表</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`actor_name`</span>(</span><br><span class="line"><span class="string">`first_name`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="string">`last_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`actor_name`</span> <span class="keyword">SELECT</span> first_name, last_name <span class="keyword">from</span> actor;</span><br></pre></td></tr></table></figure><h2 id="37-对first_name创建唯一索引uniq_idx_firstname对last_name创建普通索引idx_lastname"><a class="markdownIt-Anchor" href="#37-对first_name创建唯一索引uniq_idx_firstname对last_name创建普通索引idx_lastname"></a> <a href="https://www.nowcoder.com/practice/e1824daa0c49404aa602cf0cb34bdd75?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">37 对first_name创建唯一索引uniq_idx_firstname，对last_name创建普通索引idx_lastname</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- sqlite在已有表上创建索引方式</span></span><br><span class="line"><span class="comment">-- 1.创建单列普通索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name (column_name);</span><br><span class="line"><span class="comment">-- 2.创建唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">on</span></span><br><span class="line">table_name (column_name);</span><br><span class="line"><span class="comment">-- 注意, 这边索引是不能用``或者''框起来的</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> uniq_idx_firstname <span class="keyword">on</span> actor (first_name);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_lastname <span class="keyword">ON</span> actor (last_name);</span><br></pre></td></tr></table></figure><h2 id="38-针对actor表创建视图actor_name_view"><a class="markdownIt-Anchor" href="#38-针对actor表创建视图actor_name_view"></a> <a href="https://www.nowcoder.com/practice/b9db784b5e3d488cbd30bd78fdb2a862?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">38 针对actor表创建视图actor_name_view</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> actor_name_view <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> first_name first_name_v ,last_name last_name_v</span><br><span class="line"><span class="keyword">FROM</span>  actor;</span><br></pre></td></tr></table></figure><h2 id="39-针对上面的salaries表emp_no字段创建索引idx_emp_no查询emp_no为10005"><a class="markdownIt-Anchor" href="#39-针对上面的salaries表emp_no字段创建索引idx_emp_no查询emp_no为10005"></a> <a href="https://www.nowcoder.com/practice/f9fa9dc1a1fc4130b08e26c22c7a1e5f?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">39 针对上面的salaries表emp_no字段创建索引idx_emp_no，查询emp_no为10005,</a></h2><blockquote><p>针对salaries表emp_no字段创建了索引idx_emp_no。请强制使用索引查询emp_no为10005</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; -- sqlite使用索引查询的语法为</span><br><span class="line">&gt; SELECT|DELETE|UPDATE column1, column2...</span><br><span class="line">&gt; INDEXED BY (index_name)</span><br><span class="line">&gt; table_name</span><br><span class="line">&gt; WHERE (CONDITION);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>它可以与 DELETE、UPDATE 或 SELECT 语句一起使用。<br>“INDEXED BY index-name” 子句规定必须用命名的索引来查找前面表中值，如果索引名 index-name 不存在或不能用于查询，SQLite 语句的查询失败。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> salaries INDEXED <span class="keyword">BY</span> idx_emp_no <span class="keyword">WHERE</span> emp_no = <span class="number">10005</span></span><br></pre></td></tr></table></figure><h2 id="40-在last_update后面新增加一列名字为create_date"><a class="markdownIt-Anchor" href="#40-在last_update后面新增加一列名字为create_date"></a> <a href="https://www.nowcoder.com/practice/119f04716d284cb7a19fba65dd876b03?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">40 在last_update后面新增加一列名字为create_date</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 向表中添加列 </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> col_name <span class="built_in">char</span></span><br><span class="line"><span class="comment">-- 答案</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> actor <span class="keyword">ADD</span> create_date datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span>(<span class="string">'0000-00-00 00:00:00'</span>);</span><br></pre></td></tr></table></figure><h2 id="41-构造一个触发器audit_log在向employees表中插入一条数据的时候触发插入相关的数据到audit中"><a class="markdownIt-Anchor" href="#41-构造一个触发器audit_log在向employees表中插入一条数据的时候触发插入相关的数据到audit中"></a> <a href="https://www.nowcoder.com/practice/7e920bb2e1e74c4e83750f5c16033e2e?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">41 构造一个触发器audit_log，在向employees表中插入一条数据的时候，触发插入相关的数据到audit中</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在MySQL中，创建触发器语法如下：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">trigger_time trigger_event <span class="keyword">ON</span> tbl_name</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line">trigger_stmt</span><br></pre></td></tr></table></figure><ul><li>trigger_name：标识触发器名称，用户自行指定；</li><li>trigger_time：标识触发时机，取值为 BEFORE 或 AFTER；</li><li>trigger_event：标识触发事件，取值为 INSERT、UPDATE 或 DELETE；</li><li>tbl_name：标识建立触发器的表名，即在哪张表上建立触发器；</li><li>trigger_stmt：触发器程序体，可以是一句SQL语句，或者用 BEGIN 和 END 包含的多条语句，每条语句结束要分号结尾。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> audit_log </span><br><span class="line"><span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> employees_test</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">audit</span> <span class="keyword">values</span>(new.id,new.name);</span><br><span class="line">    <span class="comment">-- new为插入到employees_test的数据</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>【NEW 与 OLD 详解】</strong><br>MySQL 中定义了 NEW 和 OLD，用来表示触发器的所在表中，触发了触发器的那一行数据。<br>具体地：</p><ol><li>在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据；</li><li>在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据；</li><li>在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据；<br>使用方法： NEW.columnName （columnName 为相应数据表某一列名）</li></ol><h2 id="42-删除emp_no重复的记录只保留最小的id对应的记录"><a class="markdownIt-Anchor" href="#42-删除emp_no重复的记录只保留最小的id对应的记录"></a> <a href="https://www.nowcoder.com/practice/3d92551a6f6d4f1ebde272d20872cf05?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">42 删除emp_no重复的记录，只保留最小的id对应的记录。</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> titles_test <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">min</span>(<span class="keyword">id</span>)</span><br><span class="line">    <span class="keyword">from</span> titles_test</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> emp_no</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="43-将所有to_date为9999-01-01的全部更新为null且-from_date更新为2001-01-01"><a class="markdownIt-Anchor" href="#43-将所有to_date为9999-01-01的全部更新为null且-from_date更新为2001-01-01"></a> <a href="https://www.nowcoder.com/practice/859f28f43496404886a77600ea68ef59?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">43 将所有to_date为9999-01-01的全部更新为NULL,且 from_date更新为2001-01-01</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> titles_test <span class="keyword">set</span> <span class="keyword">to_date</span> = <span class="literal">null</span>, from_date = <span class="string">'2001-01-01'</span> <span class="keyword">where</span> <span class="keyword">to_date</span> =<span class="string">'9999-01-01'</span>;</span><br></pre></td></tr></table></figure><h2 id="44-将id5以及emp_no10001的行数据替换成id5以及emp_no10005其他数据保持不变使用replace实现"><a class="markdownIt-Anchor" href="#44-将id5以及emp_no10001的行数据替换成id5以及emp_no10005其他数据保持不变使用replace实现"></a> <a href="https://www.nowcoder.com/practice/2bec4d94f525458ca3d0ebf3bc8cd240?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">44 将id=5以及emp_no=10001的行数据替换成id=5以及emp_no=10005,其他数据保持不变，使用replace实现。</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 考察replace函数: 其中包含三个参数，第一个参数为该字段的名称，第二参数为该字段的需要被修改值，第三个参数为该字段修改后的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> titles_test <span class="keyword">set</span> emp_no = <span class="keyword">replace</span>(emp_no, <span class="number">10001</span>, <span class="number">10005</span>) <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h2 id="45-将titles_test表名修改为titles_2017"><a class="markdownIt-Anchor" href="#45-将titles_test表名修改为titles_2017"></a> <a href="https://www.nowcoder.com/practice/5277d7f92aa746ab8aa42886e5d570d4?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">45 将titles_test表名修改为titles_2017</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 因为在 MySQL里面修改表名和表里的字段都是用的 ALTER TABLE + table_name + 后面的修改部分</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> titles_test <span class="keyword">rename</span> <span class="keyword">to</span> titles_2017;</span><br></pre></td></tr></table></figure><p>结合[40 在last_update后面新增加一列名字为create_date](#40 在last_update后面新增加一列名字为create_date)一起看</p><ul><li><strong>ALTER TABLE 表名 ADD 列名/索引/主键/外键等；</strong></li><li><strong>ALTER TABLE 表名 DROP 列名/索引/主键/外键等；</strong></li><li><strong>ALTER TABLE 表名 ALTER 仅用来改变某列的默认值；</strong></li><li><strong>ALTER TABLE 表名 RENAME 列名/索引名 TO 新的列名/新索引名；</strong></li><li><strong>ALTER TABLE 表名 RENAME TO/AS 新表名;</strong></li><li></li><li><strong>ALTER TABLE 表名 MODIFY 列的定义但不改变列名；</strong></li><li><strong>ALTER TABLE 表名 CHANGE 列名和定义都可以改变。</strong></li></ul><h2 id="46-在audit表上创建外键约束其emp_no对应employees_test表的主键id"><a class="markdownIt-Anchor" href="#46-在audit表上创建外键约束其emp_no对应employees_test表的主键id"></a> <a href="https://www.nowcoder.com/practice/aeaa116185f24f209ca4fa40e226de48?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">46 在audit表上创建外键约束，其emp_no对应employees_test表的主键id</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">audit</span>; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">audit</span>( </span><br><span class="line">    emp_no <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>, </span><br><span class="line">    create_date datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>, </span><br><span class="line">    FOREIGN <span class="keyword">KEY</span>(emp_no) <span class="keyword">REFERENCES</span> employees_test(<span class="keyword">id</span>) </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="48-将所有获取奖金的员工当前的薪水增加10"><a class="markdownIt-Anchor" href="#48-将所有获取奖金的员工当前的薪水增加10"></a> <a href="https://www.nowcoder.com/practice/d3b058dcc94147e09352eb76f93b3274?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">48 将所有获取奖金的员工当前的薪水增加10%</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> salaries <span class="keyword">set</span> salary = <span class="number">1.1</span>*salary </span><br><span class="line"><span class="keyword">where</span> salaries.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">and</span> emp_no <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> emp_no </span><br><span class="line">    <span class="keyword">from</span> emp_bonus</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="50-将employees表中的所有员工的last_name和first_name通过连接起来"><a class="markdownIt-Anchor" href="#50-将employees表中的所有员工的last_name和first_name通过连接起来"></a> <a href="https://www.nowcoder.com/practice/810bf4ee3ac64949b08983aa66ec7bee?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">50 将employees表中的所有员工的last_name和first_name通过(’)连接起来。</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> (last_name || <span class="string">"'"</span> || first_name ) <span class="keyword">as</span> <span class="keyword">name</span> <span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure><h2 id="51-查找字符串10ab"><a class="markdownIt-Anchor" href="#51-查找字符串10ab"></a> <a href="https://www.nowcoder.com/practice/e3870bd5d6744109a902db43c105bd50?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">51 查找字符串’10,A,B’</a></h2><p>把串 “10,A,B” 中的 逗号用空串替代， 变成了 “10AB”, 然后原来串的长度 - 替换之后的串的长度 就是 被替换的 逗号的个数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ( <span class="keyword">length</span>(<span class="string">'10,A,B'</span>) - <span class="keyword">length</span>(<span class="keyword">replace</span>(<span class="string">'10,A,B'</span>, <span class="string">','</span>, <span class="string">''</span>)) ) <span class="keyword">as</span> cnt;</span><br></pre></td></tr></table></figure><h2 id="52-获取employees中的first_name查询按照first_name最后两个字母按照升序进行排列"><a class="markdownIt-Anchor" href="#52-获取employees中的first_name查询按照first_name最后两个字母按照升序进行排列"></a> <a href="https://www.nowcoder.com/practice/74d90728827e44e2864cce8b26882105?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">52 获取Employees中的first_name，查询按照first_name最后两个字母，按照升序进行排列</a></h2><blockquote><p>用mysql的话有函数<code>right</code>函数。就是取右边第几位的意思，同样还有一个 left 函数。<code>select * from salaries order by right(emp_no,2)</code>但是本题数据库是SQlite 只能用substr(emp_no,-2)</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.first_name</span><br><span class="line"><span class="keyword">from</span> employees <span class="keyword">as</span> e</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">substr</span>(e.first_name, <span class="number">-2</span>) <span class="keyword">asc</span>;</span><br><span class="line"><span class="comment">-- substr(e.first_name, -2, 2) 从最后第二位开始取2位</span></span><br></pre></td></tr></table></figure><h2 id="53-按照dept_no进行汇总属于同一个部门的emp_no按照逗号进行连接结果给出dept_no以及连接出的结果employees"><a class="markdownIt-Anchor" href="#53-按照dept_no进行汇总属于同一个部门的emp_no按照逗号进行连接结果给出dept_no以及连接出的结果employees"></a> <a href="https://www.nowcoder.com/practice/6e86365af15e49d8abe2c3d4b5126e87?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">53 按照dept_no进行汇总，属于同一个部门的emp_no按照逗号进行连接，结果给出dept_no以及连接出的结果employees</a></h2><blockquote><p>聚合函数<code>group_concat（X，Y）</code>，其中X是要连接的字段，Y是连接时用的符号，默认为逗号，可省略。此函数必须与GROUP BY配合使用。</p><p>此题以dept_no作为分组，将每个分组中不同的emp_no用逗号连接起来（即可省略Y）。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_no, <span class="keyword">group_concat</span>(emp_no) <span class="keyword">as</span> employees</span><br><span class="line"><span class="keyword">from</span> dept_emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_no</span><br></pre></td></tr></table></figure><h2 id="54-查找排除当前最大-最小salary之后的员工的平均工资avg_salary"><a class="markdownIt-Anchor" href="#54-查找排除当前最大-最小salary之后的员工的平均工资avg_salary"></a> <a href="https://www.nowcoder.com/practice/95078e5e1fba4438b85d9f11240bc591?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">54 查找排除当前最大、最小salary之后的员工的平均工资avg_salary</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(s.salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">from</span> salaries <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">to_date</span>= <span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">and</span> s.salary <span class="keyword">not</span> <span class="keyword">in</span> ( <span class="keyword">select</span> <span class="keyword">min</span>(salary) <span class="keyword">from</span> salaries <span class="keyword">where</span> <span class="keyword">to_date</span>= <span class="string">'9999-01-01'</span> )</span><br><span class="line"><span class="keyword">and</span> s.salary <span class="keyword">not</span> <span class="keyword">in</span> ( <span class="keyword">select</span> <span class="keyword">max</span>(salary) <span class="keyword">from</span> salaries <span class="keyword">where</span> <span class="keyword">to_date</span>= <span class="string">'9999-01-01'</span> );</span><br></pre></td></tr></table></figure><h2 id="55-分页查询employees表每5行一页返回第2页的数据"><a class="markdownIt-Anchor" href="#55-分页查询employees表每5行一页返回第2页的数据"></a> <a href="https://www.nowcoder.com/practice/f24966e0cb8a49c192b5e65339bc8c03?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">55 分页查询employees表，每5行一页，返回第2页的数据</a></h2><blockquote><p><code>limit offset, size</code><br>size是每页几条数据pageCnt，分页时offset输出页数（pageNum-1）*pageCnt</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">limit</span> (<span class="number">2</span><span class="number">-1</span>)*<span class="number">5</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h2 id="56-获取所有员工的emp_no"><a class="markdownIt-Anchor" href="#56-获取所有员工的emp_no"></a> <a href="https://www.nowcoder.com/practice/e2dab5477fdd4ec0ba84031f8e817b8a?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">56 获取所有员工的emp_no</a></h2><h2 id="57-使用含有关键字exists查找未分配具体部门的员工的所有信息"><a class="markdownIt-Anchor" href="#57-使用含有关键字exists查找未分配具体部门的员工的所有信息"></a> <a href="https://www.nowcoder.com/practice/c39cbfbd111a4d92b221acec1c7c1484?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">57 使用含有关键字exists查找未分配具体部门的员工的所有信息。</a></h2><h2 id="59-获取有奖金的员工相关信息"><a class="markdownIt-Anchor" href="#59-获取有奖金的员工相关信息"></a> <a href="https://www.nowcoder.com/practice/5cdbf1dcbe8d4c689020b6b2743820bf?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">59 获取有奖金的员工相关信息。</a></h2><h2 id="60-统计salary的累计和running_total"><a class="markdownIt-Anchor" href="#60-统计salary的累计和running_total"></a> <a href="https://www.nowcoder.com/practice/58824cd644ea47d7b2b670c506a159a6?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">60 统计salary的累计和running_total</a></h2><h2 id="66-牛客每个人最近的登录日期一"><a class="markdownIt-Anchor" href="#66-牛客每个人最近的登录日期一"></a> <a href="https://www.nowcoder.com/practice/ca274ebe6eac40ab9c33ced3f2223bb2?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">66 牛客每个人最近的登录日期(一)</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(<span class="built_in">date</span>)</span><br><span class="line"><span class="keyword">from</span> login</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_id</span><br></pre></td></tr></table></figure><h2 id="67-牛客每个人最近的登录日期二"><a class="markdownIt-Anchor" href="#67-牛客每个人最近的登录日期二"></a> <a href="https://www.nowcoder.com/practice/7cc3c814329546e89e71bb45c805c9ad?tpId=82&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener">67 牛客每个人最近的登录日期(二)</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user.name,client.name,<span class="keyword">max</span>(login.date)</span><br><span class="line"><span class="keyword">from</span> login</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">user</span> <span class="keyword">on</span> login.user_id = user.id</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">client</span> <span class="keyword">on</span> login.client_id = client.id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> user.name;</span><br></pre></td></tr></table></figure><p>用<code>group by</code>需要注意的:</p><ul><li>在select<strong>指定的字段</strong><ul><li>要么就要<strong>包含在Group By语句</strong>的后面，作为分组的依据；</li><li>要么就要<strong>被包含在聚合函数</strong>中。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sql练习&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#sql练习&quot;&gt;&lt;/a&gt; SQL练习&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;鉴于同学被字节狂问SQL题，因此也激发了我的危机感。 作为非科班的， 写SQL还是比较慌的， 因此做
      
    
    </summary>
    
    
      <category term="后端" scheme="https://nymrli.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="SQL" scheme="https://nymrli.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>getBargains的record和Solution</title>
    <link href="https://nymrli.top/2020/05/24/getBargains%E7%9A%84record%E5%92%8CSolution/"/>
    <id>https://nymrli.top/2020/05/24/getBargains的record和Solution/</id>
    <published>2020-05-24T08:44:25.000Z</published>
    <updated>2020-05-31T11:38:26.323Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该篇为**<a href="https://github.com/Freedomisgood/getBargains" target="_blank" rel="noopener">getBargains</a>**仓库README.md直接搬运，记录一些appnium和andriod 10碰到的问题</p></blockquote><h2 id="自动拿券"><a class="markdownIt-Anchor" href="#自动拿券"></a> 自动拿券</h2><blockquote><p>通过别人发的口令, 打开淘宝APP进行抢券</p></blockquote><h3 id="1itchat接收群消息"><a class="markdownIt-Anchor" href="#1itchat接收群消息"></a> 1.itchat接收群消息</h3><h3 id="2将口令复制到剪贴板"><a class="markdownIt-Anchor" href="#2将口令复制到剪贴板"></a> 2.将口令复制到剪贴板</h3><h3 id="3打开淘宝app点击抢券"><a class="markdownIt-Anchor" href="#3打开淘宝app点击抢券"></a> 3.打开淘宝APP点击抢券</h3><h2 id="碰到的问题"><a class="markdownIt-Anchor" href="#碰到的问题"></a> 碰到的问题:</h2><ol><li><p>出现如下警告:<code>Warning: Activity not started, its current task has been brought to the front</code> or <code>Warning: Activity not started, intent has been delivered to currently running top-most instance.</code></p><ul><li>A: 不用管他就行, 只是个警告, 提示你有应用切到了顶层</li></ul></li><li><p>出现提示: <code>/system/bin/sh: adb: inaccessible or not found</code></p><ul><li>A: 已经在adb shell中输入的命令不需要再加上<code>adb shell</code>前缀<br>e.g.<code>umi:/ $ adb shell am start ca.zgrs.clipper/.Main</code> (umi:/)提示已经在adb shell中了</li></ul></li><li><p>查找app包名和Activity活动页面(Andriod 10)</p><ul><li>A: 原本的<code>adb shell dumpsys activity | find &quot;mFocusedActivity&quot;</code>在andriod 10上好像检测不出来</li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看包名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> adb shell pm list packages</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看Activity</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> $ adb shell dumpsys activity com.taobao.taobao | grep ACTIVITY</span></span><br></pre></td></tr></table></figure><ol start="4"><li>adb打开应用的命令?</li></ol><ul><li>A: <code>adb shell am start -n package/launch activity</code></li></ul><ol start="5"><li><p>appnium声明driver的时候是打开指定app程序, 但如果每次都是重新打开, 那么加载淘宝的速度会很慢。应该使用切换后台</p><ul><li>A: 使用<code>driver.start_activity('com.taobao.taobao', 'com.taobao.tao.TBMainActivity')</code></li></ul><p><a href="https://blog.csdn.net/jianglianye21/article/details/89850033" target="_blank" rel="noopener">appium：一个手机运行两个APP，APP之间相互切换</a></p></li><li><p>ADB滑动解锁问题: 在一个位置按住</p><ul><li>A: 暂时还没解决, appnium可以, 但ADB好像没有找到解决方案</li></ul></li><li><p>桌面的activity:</p><ul><li>A: <code>.launcher.Launcher</code></li></ul></li><li><p>报错<code>selenium.common.exceptions.InvalidSessionIdException: Message: A session is either terminated or not started</code></p><ul><li>A: 原因是driver长时间没收到command自动关闭了, 与使用<code>driver.quit()</code>后再用driver执行操作报相同的错误。</li><li>-&gt;解决方案: 在desirable_caps中将<code>newCommandTimeout</code>设置大一点: <code>'newCommandTimeout': 1800</code></li></ul></li></ol><p>附录：</p><ul><li><p><a href="https://blog.csdn.net/lollipop666/article/details/82480403" target="_blank" rel="noopener">python3使用appnium运行手机上的APP</a></p></li><li><p><a href="https://github.com/majido/clipper/issues/9" target="_blank" rel="noopener">clipper - Broken on Android 10 (Android Q) #9</a></p></li><li><p><a href="https://testerhome.com/topics/3711" target="_blank" rel="noopener">Appium Python API 中文版 By-HZJ</a></p></li><li><p><a href="https://blog.csdn.net/u012002125/article/details/80870549" target="_blank" rel="noopener">Appium配置desired_capability详解</a></p></li><li><p>查看包名和activity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  # 在米6(Andriod 10)上尝试可行</span><br><span class="line">  $ adb shell dumpsys window windows | findstr mFocusedApp</span><br><span class="line">  $ adb shell dumpsys window windows | findstr &quot;Current&quot;</span><br><span class="line">  </span><br><span class="line"># 下失效</span><br><span class="line">  $ adb shell dumpsys activity | find  mFocusedActivity</span><br></pre></td></tr></table></figure><ul><li><p>如果在有apk的情况下, <code>aapt dump badging d:\\test.apk</code></p></li><li><p>打开APP-&gt;<code>adb logcat &gt; D:/log.txt</code>  -&gt; 胡乱的对APP做一些操作-&gt;Ctrl+c 结束adb命令-&gt;打开log.txt文件，搜索：Displayed</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;该篇为**&lt;a href=&quot;https://github.com/Freedomisgood/getBargains&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;getBargains&lt;/a&gt;**仓库README.md直接搬运，
      
    
    </summary>
    
    
  </entry>
  
</feed>
